import { ICanvasManager, ILeaferCanvas, IScreenSizeData, IHitCanvasManager, ILeafList, ILeaf, IHitCanvas, ICanvasAttr, InnerId, ICanvasContext2D, IBlendMode, IMatrixData, IPath2D, IWindingRule, ITextMetrics, IBounds, IBoundsData, ILeaferCanvasConfig, IExportFileType, IBlob, IExportImageType, IAutoBounds, IResizeEventListener, ICursorType, ICanvasStrokeOptions, IPointData, IMatrixWithBoundsData, IPathDrawer } from '@leafer/interface';

declare class CanvasManager implements ICanvasManager {
    list: ILeaferCanvas[];
    add(canvas: ILeaferCanvas): void;
    get(size: IScreenSizeData): ILeaferCanvas;
    recycle(old: ILeaferCanvas): void;
    clearRecycled(): void;
    clear(): void;
    destroy(): void;
}

declare class HitCanvasManager extends CanvasManager implements IHitCanvasManager {
    protected pathTypeList: ILeafList;
    protected imageTypeList: ILeafList;
    getImageType(leaf: ILeaf, size: IScreenSizeData): IHitCanvas;
    getPathType(leaf: ILeaf): IHitCanvas;
    clearImageType(): void;
    clearPathType(): void;
    protected __clearLeafList(leafList: ILeafList): void;
    clear(): void;
}

declare class Canvas implements ICanvasAttr {
    readonly innerId: InnerId;
    width: number;
    height: number;
    context: ICanvasContext2D;
    smooth: boolean;
    smoothLevel: ImageSmoothingQuality;
    opacity: number;
    set blendMode(value: IBlendMode);
    get blendMode(): IBlendMode;
    fillStyle: string | object;
    strokeStyle: string | object;
    strokeWidth: number;
    strokeCap: string;
    strokeJoin: string;
    set dashPattern(value: number[]);
    get dashPattern(): number[];
    dashOffset: number;
    miterLimit: number;
    shadowBlur: number;
    shadowColor: string;
    shadowOffsetX: number;
    shadowOffsetY: number;
    filter: string;
    font: string;
    fontKerning: string;
    fontStretch: string;
    fontVariantCaps: string;
    textAlign: string;
    textBaseline: string;
    textRendering: string;
    wordSpacing: string;
    letterSpacing: string;
    direction: string;
    __bindContext(): void;
    setTransform(_a: number | IMatrixData, _b?: number, _c?: number, _d?: number, _e?: number, _f?: number): void;
    resetTransform(): void;
    getTransform(): IMatrixData;
    save(): void;
    restore(): void;
    transform(a: number | IMatrixData, b?: number, c?: number, d?: number, e?: number, f?: number): void;
    translate(_x: number, _y: number): void;
    scale(_x: number, _y: number): void;
    rotate(_angle: number): void;
    fill(_path2d?: IPath2D | IWindingRule, _rule?: IWindingRule): void;
    stroke(_path2d?: IPath2D): void;
    clip(_path2d?: IPath2D | IWindingRule, _rule?: IWindingRule): void;
    fillRect(_x: number, _y: number, _width: number, _height: number): void;
    strokeRect(_x: number, _y: number, _width: number, _height: number): void;
    clearRect(_x: number, _y: number, _width: number, _height: number): void;
    drawImage(image: CanvasImageSource, sx: number, sy: number, sw?: number, sh?: number, dx?: number, dy?: number, dw?: number, dh?: number): void;
    beginPath(): void;
    moveTo(_x: number, _y: number): void;
    lineTo(_x: number, _y: number): void;
    bezierCurveTo(_cp1x: number, _cp1y: number, _cp2x: number, _cp2y: number, _x: number, _y: number): void;
    quadraticCurveTo(_cpx: number, _cpy: number, _x: number, _y: number): void;
    closePath(): void;
    arc(_x: number, _y: number, _radius: number, _startAngle: number, _endAngle: number, _anticlockwise?: boolean): void;
    arcTo(_x1: number, _y1: number, _x2: number, _y2: number, _radius: number): void;
    ellipse(_x: number, _y: number, _radiusX: number, _radiusY: number, _rotation: number, _startAngle: number, _endAngle: number, _anticlockwise?: boolean): void;
    rect(_x: number, _y: number, _width: number, _height: number): void;
    roundRect(_x: number, _y: number, _width: number, _height: number, _radius?: number | number[]): void;
    createConicGradient(_startAngle: number, _x: number, _y: number): CanvasGradient;
    createLinearGradient(_x0: number, _y0: number, _x1: number, _y1: number): CanvasGradient;
    createPattern(_image: CanvasImageSource, _repetition: string | null): CanvasPattern | null;
    createRadialGradient(_x0: number, _y0: number, _r0: number, _x1: number, _y1: number, _r1: number): CanvasGradient;
    fillText(_text: string, _x: number, _y: number, _maxWidth?: number): void;
    measureText(_text: string): ITextMetrics;
    strokeText(_text: string, _x: number, _y: number, _maxWidth?: number): void;
    destroy(): void;
}

declare const canvasSizeAttrs: string[];
declare class LeaferCanvasBase extends Canvas implements ILeaferCanvas {
    readonly innerId: InnerId;
    name: string;
    manager: ICanvasManager;
    pixelRatio: number;
    get pixelWidth(): number;
    get pixelHeight(): number;
    get allowBackgroundColor(): boolean;
    bounds: IBounds;
    clientBounds: IBoundsData;
    config: ILeaferCanvasConfig;
    autoLayout: boolean;
    view: any;
    parentView: any;
    unreal?: boolean;
    recycled?: boolean;
    worldTransform: IMatrixData;
    protected savedBlendMode: IBlendMode;
    constructor(config?: ILeaferCanvasConfig, manager?: ICanvasManager);
    init(): void;
    __createContext(): void;
    toBlob(type?: IExportFileType, quality?: number): Promise<IBlob>;
    toDataURL(type?: IExportImageType, quality?: number): string | Promise<string>;
    saveAs(filename: string, quality?: number): Promise<boolean>;
    getSaveCanvas(type: string): ILeaferCanvas;
    resize(size: IScreenSizeData): void;
    updateViewSize(): void;
    updateClientBounds(): void;
    startAutoLayout(_autoBounds: IAutoBounds, _listener: IResizeEventListener): void;
    stopAutoLayout(): void;
    setCursor(_cursor: ICursorType | ICursorType[]): void;
    setWorld(matrix: IMatrixData, parentMatrix?: IMatrixData, onlyTranslate?: boolean): void;
    useWorldTransform(worldTransform?: IMatrixData): void;
    setStroke(color: string | object, strokeWidth: number, options?: ICanvasStrokeOptions): void;
    setStrokeOptions(options: ICanvasStrokeOptions): void;
    saveBlendMode(blendMode: IBlendMode): void;
    restoreBlendMode(): void;
    hitFill(point: IPointData, fillRule?: IWindingRule): boolean;
    hitStroke(point: IPointData, strokeWidth?: number): boolean;
    setWorldShadow(x: number, y: number, blur: number, color?: string): void;
    setWorldBlur(blur: number): void;
    copyWorld(canvas: ILeaferCanvas, from?: IBoundsData, to?: IBoundsData, blendMode?: IBlendMode): void;
    copyWorldToInner(canvas: ILeaferCanvas, fromWorld: IMatrixWithBoundsData, toInnerBounds: IBoundsData, blendMode?: IBlendMode): void;
    copyWorldByReset(canvas: ILeaferCanvas, from?: IBoundsData, to?: IBoundsData, blendMode?: IBlendMode): void;
    useMask(maskCanvas: ILeaferCanvas, fromBounds?: IBoundsData, toBounds?: IBoundsData): void;
    useEraser(eraserCanvas: ILeaferCanvas, fromBounds?: IBoundsData, toBounds?: IBoundsData): void;
    fillWorld(bounds: IBoundsData, color: string | object, blendMode?: IBlendMode): void;
    strokeWorld(bounds: IBoundsData, color: string | object, blendMode?: IBlendMode): void;
    clearWorld(bounds: IBoundsData, ceilPixel?: boolean): void;
    clipWorld(bounds: IBoundsData, ceilPixel?: boolean): void;
    clear(): void;
    isSameSize(size: IScreenSizeData): boolean;
    getSameCanvas(useSameWorldTransform?: boolean): ILeaferCanvas;
    getBiggerCanvas(addWidth: number, addHeight: number): ILeaferCanvas;
    recycle(): void;
    updateRender(): void;
    unrealCanvas(): void;
    destroy(): void;
}

declare function canvasPatch(drawer: IPathDrawer): void;

export { CanvasManager, HitCanvasManager, LeaferCanvasBase, canvasPatch, canvasSizeAttrs };
