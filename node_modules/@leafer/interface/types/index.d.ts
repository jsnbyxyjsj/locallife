import { IFunction as IFunction$1, IObject as IObject$1, IEvent as IEvent$1, ILeaferCanvas as ILeaferCanvas$1, IScreenSizeData as IScreenSizeData$1 } from '@leafer/interface';

type __Number = number;
type __Boolean = boolean;
type __String = string;
type __Object = IObject;
type __Value = __Number | __Boolean | __String | __Object;
type ITimer = any;
type IPathString = string;
interface IObject {
    [name: string]: any;
}
interface IBooleanMap {
    [name: string]: boolean;
}
interface INumberMap {
    [name: string]: number;
}
interface IStringMap {
    [name: string]: string;
}
interface IDataTypeHandle {
    (target: any): void;
}

interface ILeafMap {
    [name: string]: ILeaf;
}
interface ILeafArrayMap {
    [name: string]: ILeaf[];
}
type ILeafListItemCallback = (item: ILeaf, index?: number) => void;
interface ILeafList {
    list: ILeaf[];
    keys: INumberMap;
    readonly length: number;
    has(leaf: ILeaf): boolean;
    indexAt(index: number): ILeaf;
    indexOf(leaf: ILeaf): number;
    unshift(leaf: ILeaf): void;
    pushList(list: ILeaf[]): void;
    push(leaf: ILeaf): void;
    sort(reverse?: boolean): void;
    remove(leaf: ILeaf): void;
    forEach(itemCallback: ILeafListItemCallback): void;
    clone(): ILeafList;
    reset(): void;
    destroy(): void;
}
interface ILeafLevelList {
    levelMap: ILeafArrayMap;
    keys: INumberMap;
    levels: number[];
    readonly length: number;
    has(leaf: ILeaf): boolean;
    without(leaf: ILeaf): boolean;
    sort(reverse?: boolean): void;
    pushList(list: ILeaf[]): void;
    push(leaf: ILeaf): void;
    forEach(itemCallback: ILeafListItemCallback): void;
    reset(): void;
    destroy(): void;
}

interface IControl {
    start(): void;
    stop(): void;
    destroy(): void;
}

interface IWatchEventData {
    updatedList: ILeafList;
}
interface IWatcherConfig {
}
interface IWatcher extends IControl {
    target: ILeaf;
    totalTimes: number;
    disabled: boolean;
    running: boolean;
    changed: boolean;
    hasVisible: boolean;
    hasAdd: boolean;
    hasRemove: boolean;
    readonly childrenChanged: boolean;
    config: IWatcherConfig;
    updatedList: ILeafList;
    disable(): void;
    update(): void;
}

interface IPointData {
    x: number;
    y: number;
}
interface IPoint extends IPointData {
    set(x?: number, y?: number): void;
    copy(point: IPointData): IPoint;
    clone(): IPoint;
    rotate(angle: number, center?: IPointData): IPoint;
    toInnerOf(matrix: IMatrixData, to?: IPointData): IPoint;
    toOuterOf(matrix: IMatrixData, to?: IPointData): IPoint;
    getCenter(to: IPointData): IPointData;
    getDistance(to: IPointData): number;
    getAngle(to: IPointData): number;
    getAtan2(to: IPointData): number;
    reset(): void;
}
interface IRadiusPointData extends IPointData {
    radiusX: number;
    radiusY: number;
}
interface ISizeData {
    width: number;
    height: number;
}
interface ISize extends ISizeData {
}
interface IScreenSizeData extends ISizeData {
    pixelRatio?: number;
}
interface IBoundsData extends IPointData, ISizeData {
}
interface IOffsetBoundsData extends IBoundsData {
    offsetX: number;
    offsetY: number;
}
interface IBoundsDataHandle {
    (target: any): IBoundsData;
}
interface IBounds extends IBoundsData {
    set(x?: number, y?: number, width?: number, height?: number): void;
    copy(bounds: IBoundsData): IBounds;
    clone(): IBounds;
    scale(scaleX: number, scaleY?: number): IBounds;
    toOuterOf(matrix: IMatrixData, to?: IBoundsData): IBounds;
    getFitMatrix(put: IBoundsData): IMatrix;
    spread(size: number): IBounds;
    ceil(): IBounds;
    unsign(): IBounds;
    add(bounds: IBoundsData): IBounds;
    addList(boundsList: IBounds[]): IBounds;
    setByList(boundsList: IBounds[], addMode?: boolean): IBounds;
    addListWithHandle(list: IObject[], boundsDataHandle: IBoundsDataHandle): IBounds;
    setByListWithHandle(list: IObject[], boundsDataHandle: IBoundsDataHandle, addMode: boolean): IBounds;
    setByPoints(points: IPointData[]): IBounds;
    hitPoint(point: IPointData, pointMatrix?: IMatrixData): boolean;
    hitRadiusPoint(point: IRadiusPointData, pointMatrix?: IMatrixWithLayoutData): boolean;
    hit(bounds: IBoundsData, boundsMatrix?: IMatrixData): boolean;
    includes(bounds: IBoundsData, boundsMatrix?: IMatrixData): boolean;
    intersect(bounds: IBoundsData, boundsMatrix?: IMatrixData): IBounds;
    getIntersect(bounds: IBoundsData, boundsMatrix?: IMatrixData): IBounds;
    isSame(bounds: IBoundsData): boolean;
    isEmpty(): boolean;
    reset(): void;
}
interface ITwoPointBoundsData {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
}
interface ITwoPointBounds extends ITwoPointBoundsData {
    addPoint(x: number, y: number): void;
    addBounds(x: number, y: number, width: number, height: number): void;
    add(pointBounds: ITwoPointBoundsData): void;
}
interface IAutoBoundsData {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
    width?: number;
    height?: number;
}
interface IAutoBounds extends IAutoBoundsData {
    set(top?: number, right?: number, bottom?: number, left?: number, width?: number, height?: number): void;
    copy(auto: IAutoBoundsData): void;
    getBoundsFrom(parent: ISizeData): IBounds;
}
interface IMatrixData {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
}
interface IMatrixDecompositionData {
    x: number;
    y: number;
    scaleX: number;
    scaleY: number;
    rotation: number;
    skewX: number;
    skewY: number;
}
type IMatrixDecompositionAttr = 'x' | 'y' | 'scaleX' | 'scaleY' | 'rotation' | 'skewX' | 'skewY';
interface IMatrix extends IMatrixData {
    set(a: number, b: number, c: number, d: number, e: number, f: number): void;
    copy(matrix: IMatrixData): IMatrix;
    clone(): IMatrix;
    translate(x: number, y: number): IMatrix;
    translateInner(x: number, y: number): IMatrix;
    scale(x: number, y?: number): IMatrix;
    scaleOfOuter(origin: IPointData, x: number, y?: number): IMatrix;
    scaleOfInner(origin: IPointData, x: number, y?: number): IMatrix;
    rotate(angle: number): IMatrix;
    rotateOfOuter(origin: IPointData, angle: number): IMatrix;
    rotateOfInner(origin: IPointData, angle: number): IMatrix;
    skew(x: number, y?: number): IMatrix;
    skewOfOuter(origin: IPointData, x: number, y?: number): IMatrix;
    skewOfInner(origin: IPointData, x: number, y?: number): IMatrix;
    multiply(matrix: IMatrixData): IMatrix;
    divide(matrix: IMatrixData): IMatrix;
    preMultiply(matrix: IMatrixData): IMatrix;
    invert(): IMatrix;
    toOuterPoint(inner: IPointData, to?: IPointData, distance?: boolean): void;
    toInnerPoint(outer: IPointData, to?: IPointData, distance?: boolean): void;
    decompose(): IMatrixDecompositionData;
    reset(): void;
}
interface IMatrixWithBoundsData extends IMatrixData, IBoundsData {
}
interface IMatrixWithLayoutData extends IMatrixData, IMatrixDecompositionData, IBoundsData {
}

interface ILayoutChangedData {
    matrixList: ILeaf[];
    boundsList: ILeaf[];
    surfaceList: ILeaf[];
}
interface ILayoutBlockData {
    updatedList: ILeafList;
    updatedBounds: IBounds;
    beforeBounds: IBounds;
    afterBounds: IBounds;
    setBefore?(): void;
    setAfter?(): void;
    merge?(data: ILayoutBlockData): void;
    destroy(): void;
}
interface IPartLayoutConfig {
    maxBlocks?: number;
    maxTimes?: number;
}
interface ILayouterConfig {
    partLayout?: IPartLayoutConfig;
}
interface ILayouter extends IControl {
    target: ILeaf;
    layoutedBlocks: ILayoutBlockData[];
    totalTimes: number;
    times: number;
    disabled: boolean;
    running: boolean;
    layouting: boolean;
    waitAgain: boolean;
    config: ILayouterConfig;
    disable(): void;
    layout(): void;
    layoutAgain(): void;
    layoutOnce(): void;
    partLayout(): void;
    fullLayout(): void;
    createBlock(data: ILeafList | ILeaf[]): ILayoutBlockData;
    getBlocks(list: ILeafList): ILayoutBlockData[];
    addBlocks(current: ILayoutBlockData[]): void;
}

interface IEvent {
    type?: string;
    target?: IEventTarget;
    current?: IEventTarget;
    bubbles?: boolean;
    phase?: number;
    isStopDefault?: boolean;
    isStop?: boolean;
    isStopNow?: boolean;
    stopDefault?(): void;
    stopNow?(): void;
    stop?(): void;
}
interface IEventTarget extends IEventer {
}
interface ILeaferEvent {
}
interface IRenderEvent {
}
interface IAnimateEvent {
}
interface IChildEvent extends IEvent {
    parent?: ILeaf;
    child?: ILeaf;
}
interface IResizeEvent extends IEvent {
    readonly width: number;
    readonly height: number;
    readonly pixelRatio: number;
    readonly bigger: boolean;
    readonly smaller: boolean;
    readonly samePixelRatio: boolean;
    readonly old: IScreenSizeData;
}
interface IResizeEventListener {
    (event: IResizeEvent): void;
}
interface IUpdateEvent extends IEvent {
}
interface IPropertyEvent extends IEvent {
    readonly attrName: string;
    readonly oldValue: unknown;
    readonly newValue: unknown;
}
interface ILayoutEvent extends IEvent {
    readonly data: ILayoutBlockData[];
    readonly times: number;
}
interface IWatchEvent extends IEvent {
    readonly data: IWatchEventData;
}
interface ITransformEventData {
    x: number;
    y: number;
    scaleX: number;
    scaleY: number;
    rotation: number;
    readonly zooming: boolean;
    readonly moving: boolean;
    readonly rotating: boolean;
    readonly changing: boolean;
}
interface ITransformEvent extends IEvent, ITransformEventData {
    readonly x: number;
    readonly y: number;
    readonly scaleX: number;
    readonly scaleY: number;
    readonly rotation: number;
}
type TransformMode = 'move' | 'zoom' | 'rotate';
interface IMultiTouchData {
    move: IPointData;
    scale: number;
    angle: number;
    center: IPointData;
}
interface IKeepTouchData {
    from: IPointData;
    to: IPointData;
}

type ILeafEventerModule = ILeafEventer & ThisType<ILeaf>;
interface ILeafEventer {
    on?(type: string | string[], listener: IEventListener, options?: IEventListenerOptions | boolean): void;
    off?(type: string | string[], listener: IEventListener, options?: IEventListenerOptions | boolean): void;
    on_?(type: string | string[], listener: IEventListener, bind?: IObject, options?: IEventListenerOptions | boolean): IEventListenerId;
    off_?(id: IEventListenerId | IEventListenerId[]): void;
    once?(type: string | string[], listener: IEventListener, capture?: boolean): void;
    emit?(type: string, event?: IEvent | IObject, capture?: boolean): void;
    emitEvent?(event?: IEvent, capture?: boolean): void;
    hasEvent?(type: string, capture?: boolean): boolean;
}

type IEventListener = IFunction$1;
interface IEventListenerOptions {
    capture?: boolean;
    once?: boolean;
}
interface IEventListenerItem extends IEventListenerOptions {
    listener: IEventListener;
}
interface IEventListenerMap {
    [name: string]: IEventListenerItem[];
}
interface IEventListenerId {
    type: string | string[];
    listener: IEventListener;
    options?: IEventListenerOptions | boolean;
}
type InnerId = number;
interface IEventer extends ILeafEventer {
    readonly innerId: InnerId;
    __captureMap?: IEventListenerMap;
    __bubbleMap?: IEventListenerMap;
    on(type: string | string[], listener: IEventListener, options?: IEventListenerOptions | boolean): void;
    off(type: string | string[], listener: IEventListener, options?: IEventListenerOptions | boolean): void;
    on_(type: string | string[], listener: IEventListener, bind?: IObject$1, options?: IEventListenerOptions | boolean): IEventListenerId;
    off_(id: IEventListenerId | IEventListenerId[]): void;
    once(type: string | string[], listener: IEventListener): void;
    emit(type: string, event?: IEvent$1 | IObject$1, capture?: boolean): void;
    emitEvent(event?: IEvent$1, capture?: boolean): void;
    hasEvent(type: string, capture?: boolean): boolean;
    destroy(): void;
}

type GlobalCompositeOperation = 'color' | 'color-burn' | 'color-dodge' | 'copy' | 'darken' | 'destination-atop' | 'destination-in' | 'destination-out' | 'destination-over' | 'difference' | 'exclusion' | 'hard-light' | 'hue' | 'lighten' | 'lighter' | 'luminosity' | 'multiply' | 'overlay' | 'saturation' | 'screen' | 'soft-light' | 'source-atop' | 'source-in' | 'source-out' | 'source-over' | 'xor';
type CanvasDirection = 'inherit' | 'ltr' | 'rtl';
type IWindingRule = 'evenodd' | 'nonzero';
type CanvasLineCap = 'butt' | 'round' | 'square';
type CanvasLineJoin = 'bevel' | 'miter' | 'round';
type CanvasTextAlign = 'center' | 'end' | 'left' | 'right' | 'start';
type CanvasTextBaseline = 'alphabetic' | 'bottom' | 'hanging' | 'ideographic' | 'middle' | 'top';
interface IPath2D extends CanvasPath {
    addPath(path: IPath2D, transform?: DOMMatrix2DInit): void;
}
interface CanvasCompositing {
    globalAlpha: number;
    globalCompositeOperation: GlobalCompositeOperation;
}
type CanvasImageSource$1 = any;
interface CanvasDrawImage {
    drawImage(image: CanvasImageSource$1, dx: number, dy: number): void;
    drawImage(image: CanvasImageSource$1, dx: number, dy: number, dw: number, dh: number): void;
    drawImage(image: CanvasImageSource$1, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
}
interface CanvasDrawPath {
    beginPath(): void;
    clip(fillRule?: IWindingRule): void;
    clip(path: IPath2D, fillRule?: IWindingRule): void;
    fill(fillRule?: IWindingRule): void;
    fill(path: IPath2D, fillRule?: IWindingRule): void;
    isPointInPath(x: number, y: number, fillRule?: IWindingRule): boolean;
    isPointInPath(path: IPath2D, x: number, y: number, fillRule?: IWindingRule): boolean;
    isPointInStroke(x: number, y: number): boolean;
    isPointInStroke(path: IPath2D, x: number, y: number): boolean;
    stroke(): void;
    stroke(path: IPath2D): void;
}
interface CanvasFillStrokeStyles {
    fillStyle: string | CanvasGradient | CanvasPattern;
    strokeStyle: string | CanvasGradient | CanvasPattern;
    createConicGradient(startAngle: number, x: number, y: number): CanvasGradient;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
    createPattern(image: CanvasImageSource$1, repetition: string | null): CanvasPattern | null;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
}
interface CanvasFilters {
    filter: string;
}
interface CanvasGradient {
    addColorStop(offset: number, color: string): void;
}
interface ImageDataSettings {
    colorSpace?: PredefinedColorSpace;
}
interface CanvasImageData {
    createImageData(sw: number, sh: number, settings?: ImageDataSettings): ImageData;
    createImageData(imagedata: ImageData): ImageData;
    getImageData(sx: number, sy: number, sw: number, sh: number, settings?: ImageDataSettings): ImageData;
    putImageData(imagedata: ImageData, dx: number, dy: number): void;
    putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void;
}
interface CanvasImageSmoothing {
    imageSmoothingEnabled: boolean;
    imageSmoothingQuality: ImageSmoothingQuality;
}
interface CanvasPath {
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    closePath(): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    lineTo(x: number, y: number): void;
    moveTo(x: number, y: number): void;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    rect(x: number, y: number, w: number, h: number): void;
    roundRect(x: number, y: number, width: number, height: number, radius?: number | number[]): void;
}
interface CanvasPathDrawingStyles {
    lineCap: CanvasLineCap;
    lineDashOffset: number;
    lineJoin: CanvasLineJoin;
    lineWidth: number;
    miterLimit: number;
    getLineDash(): number[];
    setLineDash(segments: number[]): void;
}
interface CanvasPattern {
    setTransform(transform?: DOMMatrix2DInit): void;
}
interface CanvasRect {
    clearRect(x: number, y: number, w: number, h: number): void;
    fillRect(x: number, y: number, w: number, h: number): void;
    strokeRect(x: number, y: number, w: number, h: number): void;
}
type PredefinedColorSpace = 'display-p3' | 'srgb';
interface CanvasRenderingContext2DSettings {
    alpha?: boolean;
    colorSpace?: PredefinedColorSpace;
    desynchronized?: boolean;
    willReadFrequently?: boolean;
}
interface ICanvasContext2D extends CanvasCompositing, CanvasDrawImage, CanvasDrawPath, CanvasFillStrokeStyles, CanvasFilters, CanvasImageData, CanvasImageSmoothing, CanvasPath, CanvasPathDrawingStyles, CanvasRect, CanvasShadowStyles, CanvasState, CanvasText, CanvasTextDrawingStyles, CanvasTransform, CanvasUserInterface {
    readonly canvas: HTMLCanvasElement;
    getContextAttributes(): CanvasRenderingContext2DSettings;
}
interface CanvasShadowStyles {
    shadowBlur: number;
    shadowColor: string;
    shadowOffsetX: number;
    shadowOffsetY: number;
}
interface CanvasState {
    restore(): void;
    save(): void;
}
interface CanvasUserInterface {
    drawFocusIfNeeded(element: any): void;
    drawFocusIfNeeded(path: IPath2D, element: any): void;
}
interface ITextMetrics {
    readonly actualBoundingBoxAscent: number;
    readonly actualBoundingBoxDescent: number;
    readonly actualBoundingBoxLeft: number;
    readonly actualBoundingBoxRight: number;
    readonly fontBoundingBoxAscent: number;
    readonly fontBoundingBoxDescent: number;
    readonly width: number;
}
interface CanvasText {
    fillText(text: string, x: number, y: number, maxWidth?: number): void;
    measureText(text: string): ITextMetrics;
    strokeText(text: string, x: number, y: number, maxWidth?: number): void;
}
interface CanvasTextDrawingStyles {
    direction: CanvasDirection;
    font: string;
    textAlign: CanvasTextAlign;
    textBaseline: CanvasTextBaseline;
}
interface CanvasTransform {
    getTransform(): DOMMatrix;
    resetTransform(): void;
    rotate(angle: number): void;
    scale(x: number, y: number): void;
    setTransform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    setTransform(transform?: DOMMatrix2DInit): void;
    transform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    translate(x: number, y: number): void;
}
interface DOMMatrix2DInit {
    a?: number;
    b?: number;
    c?: number;
    d?: number;
    e?: number;
    f?: number;
    m11?: number;
    m12?: number;
    m21?: number;
    m22?: number;
    m41?: number;
    m42?: number;
}
interface DOMMatrixInit extends DOMMatrix2DInit {
    is2D?: boolean;
    m13?: number;
    m14?: number;
    m23?: number;
    m24?: number;
    m31?: number;
    m32?: number;
    m33?: number;
    m34?: number;
    m43?: number;
    m44?: number;
}
interface DOMMatrixReadOnly {
    readonly a: number;
    readonly b: number;
    readonly c: number;
    readonly d: number;
    readonly e: number;
    readonly f: number;
    readonly is2D: boolean;
    readonly isIdentity: boolean;
    readonly m11: number;
    readonly m12: number;
    readonly m13: number;
    readonly m14: number;
    readonly m21: number;
    readonly m22: number;
    readonly m23: number;
    readonly m24: number;
    readonly m31: number;
    readonly m32: number;
    readonly m33: number;
    readonly m34: number;
    readonly m41: number;
    readonly m42: number;
    readonly m43: number;
    readonly m44: number;
    flipX(): DOMMatrix;
    flipY(): DOMMatrix;
    inverse(): DOMMatrix;
    multiply(other?: DOMMatrixInit): DOMMatrix;
    rotate(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;
    rotateAxisAngle(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;
    rotateFromVector(x?: number, y?: number): DOMMatrix;
    scale(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scale3d(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scaleNonUniform(scaleX?: number, scaleY?: number): DOMMatrix;
    skewX(sx?: number): DOMMatrix;
    skewY(sy?: number): DOMMatrix;
    toFloat32Array(): Float32Array;
    toFloat64Array(): Float64Array;
    toJSON(): any;
    transformPoint(point?: DOMPointInit): DOMPoint;
    translate(tx?: number, ty?: number, tz?: number): DOMMatrix;
    toString(): string;
}
declare var DOMMatrixReadOnly: {
    prototype: DOMMatrixReadOnly;
    new (init?: string | number[]): DOMMatrixReadOnly;
    fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly;
    fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly;
    fromMatrix(other?: DOMMatrixInit): DOMMatrixReadOnly;
    toString(): string;
};
interface DOMMatrix extends DOMMatrixReadOnly {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    m11: number;
    m12: number;
    m13: number;
    m14: number;
    m21: number;
    m22: number;
    m23: number;
    m24: number;
    m31: number;
    m32: number;
    m33: number;
    m34: number;
    m41: number;
    m42: number;
    m43: number;
    m44: number;
    invertSelf(): DOMMatrix;
    multiplySelf(other?: DOMMatrixInit): DOMMatrix;
    preMultiplySelf(other?: DOMMatrixInit): DOMMatrix;
    rotateAxisAngleSelf(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;
    rotateFromVectorSelf(x?: number, y?: number): DOMMatrix;
    rotateSelf(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;
    scale3dSelf(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scaleSelf(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    setMatrixValue(transformList: string): DOMMatrix;
    skewXSelf(sx?: number): DOMMatrix;
    skewYSelf(sy?: number): DOMMatrix;
    translateSelf(tx?: number, ty?: number, tz?: number): DOMMatrix;
}
declare var DOMMatrix: {
    prototype: DOMMatrix;
    new (init?: string | number[]): DOMMatrix;
    fromFloat32Array(array32: Float32Array): DOMMatrix;
    fromFloat64Array(array64: Float64Array): DOMMatrix;
    fromMatrix(other?: DOMMatrixInit): DOMMatrix;
};

type Command = number;
type x = number;
type y = number;
type x1 = number;
type y1 = number;
type x2 = number;
type y2 = number;
type radiusX = number;
type radiusY = number;
type xAxisRotation = number;
type largeArcFlag = number;
type sweepFlag = number;
type MCommandData = [Command, x, y];
type HCommandData = [Command, x];
type VCommandData = [Command, y];
type LCommandData = MCommandData;
type CCommandData = [Command, x1, y1, x2, y2, x, y];
type SCommandData = [Command, x2, y2, x, y];
type QCommandData = [Command, x1, y1, x, y];
type TCommandData = [Command, x, y];
type ZCommandData = [Command];
type ACommandData = [Command, radiusX, radiusY, xAxisRotation, largeArcFlag, sweepFlag, x, y];
type width = number;
type height = number;
type rotation = number;
type startAngle = number;
type endAngle = number;
type anticlockwise = boolean;
type cornerRadius = number | number[];
type radius = number;
type RectCommandData = [Command, x, y, width, height];
type RoundRectCommandData = [Command, x, y, width, height, cornerRadius];
type EllipseCommandData = [Command, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise];
type ArcCommandData = [Command, x, y, radius, startAngle, endAngle, anticlockwise];
type ArcToCommandData = [Command, x1, y1, x2, y2, radius];
type CanvasPathCommand = 1 | 2 | 5 | 7 | 11;
type IPathCommandData = number[];

interface IPathDrawer {
    beginPath?(): void;
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    closePath(): void;
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    rect(x: number, y: number, width: number, height: number): void;
    roundRect(x: number, y: number, width: number, height: number, radius?: number | number[]): void;
}
interface IPathCreator {
    path: IPathCommandData;
    beginPath(): IPathCreator;
    moveTo(x: number, y: number): IPathCreator;
    lineTo(x: number, y: number): IPathCreator;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): IPathCreator;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): IPathCreator;
    closePath(): IPathCreator;
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): IPathCreator;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): IPathCreator;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): IPathCreator;
    rect(x: number, y: number, width: number, height: number): IPathCreator;
    roundRect(x: number, y: number, width: number, height: number, radius?: number | number[]): IPathCreator;
    drawEllipse(x: number, y: number, radiusX: number, radiusY: number, rotation?: number, startAngle?: number, endAngle?: number, anticlockwise?: boolean): IPathCreator;
    drawArc(x: number, y: number, radius: number, startAngle?: number, endAngle?: number, anticlockwise?: boolean): IPathCreator;
    drawPoints(points: number[], curve?: boolean | number, close?: boolean): IPathCreator;
}

interface ICanvasManager {
    add(canvas: ILeaferCanvas$1): void;
    get(size: IScreenSizeData$1): ILeaferCanvas$1;
    recycle(old: ILeaferCanvas$1): void;
    clearRecycled(): void;
    clear(): void;
    destroy(): void;
}

interface ILeaferCanvasConfig extends IAutoBoundsData {
    view?: string | IObject;
    fill?: string;
    pixelRatio?: number;
    smooth?: boolean;
    hittable?: boolean;
    webgl?: boolean;
}
type IHitCanvasConfig = ILeaferCanvasConfig;
interface ICanvasStrokeOptions {
    strokeWidth?: number;
    strokeAlign?: string;
    strokeCap?: string;
    strokeJoin?: string;
    dashPattern?: number[];
    dashOffset?: number;
    miterLimit?: number;
}
interface ICanvasAttr extends ICanvasStrokeOptions, IObject {
    smooth: boolean;
    smoothLevel: string;
    opacity: number;
    blendMode: string;
    fillStyle: string | object;
    strokeStyle: string | object;
    strokeWidth: number;
    shadowBlur: number;
    shadowColor: string;
    shadowOffsetX: number;
    shadowOffsetY: number;
    filter: string;
    font: string;
    fontKerning: string;
    fontStretch: string;
    fontVariantCaps: string;
    textAlign: string;
    textBaseline: string;
    textRendering: string;
    wordSpacing: string;
    letterSpacing: string;
    direction: string;
}
interface ICanvasMethod {
    save(): void;
    restore(): void;
    fill(path?: IPath2D | IWindingRule, rule?: IWindingRule): void;
    stroke(path?: IPath2D): void;
    clip(path?: IPath2D | IWindingRule, rule?: IWindingRule): void;
    fillRect(x: number, y: number, width: number, height: number): void;
    strokeRect(x: number, y: number, width: number, height: number): void;
    clearRect(x: number, y: number, width: number, height: number): void;
    transform(a: number | IMatrixData, b?: number, c?: number, d?: number, e?: number, f?: number): void;
    translate(x: number, y: number): void;
    scale(x: number, y: number): void;
    rotate(angle: number): void;
    drawImage(image: CanvasImageSource, dx: number, dy: number): void;
    drawImage(image: CanvasImageSource, dx: number, dy: number, dw: number, dh: number): void;
    drawImage(image: CanvasImageSource, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
    setTransform(a: number | IMatrixData, b?: number, c?: number, d?: number, e?: number, f?: number): void;
    getTransform(): IMatrixData;
    resetTransform(): void;
    createConicGradient(startAngle: number, x: number, y: number): CanvasGradient;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
    createPattern(image: CanvasImageSource, repetition: string | null): CanvasPattern | null;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
    fillText(text: string, x: number, y: number, maxWidth?: number): void;
    measureText(text: string): ITextMetrics;
    strokeText(text: string, x: number, y: number, maxWidth?: number): void;
    saveBlendMode(blendMode?: string): void;
    restoreBlendMode(): void;
    hitFill(point: IPointData, fillRule?: string): boolean;
    hitStroke(point: IPointData, strokeWidth?: number): boolean;
    setStroke(strokeStyle: string | object, strokeWidth: number, options?: ICanvasStrokeOptions): void;
    setStrokeOptions(options: ICanvasStrokeOptions): void;
    setWorld(matrix: IMatrixData, parentMatrix?: IMatrixData): void;
    useWorldTransform(worldTransform?: IMatrixData): void;
    setWorldShadow(x: number, y: number, blur: number, color?: string): void;
    setWorldBlur(blur: number): void;
    copyWorld(canvas: ILeaferCanvas, fromBounds?: IBoundsData, toBounds?: IBoundsData, blendMode?: string): void;
    copyWorldByReset(canvas: ILeaferCanvas, from?: IBoundsData, to?: IBoundsData, blendMode?: string): void;
    copyWorldToInner(canvas: ILeaferCanvas, fromWorld: IMatrixWithBoundsData, toInnerBounds: IBoundsData, blendMode?: string): void;
    useMask(maskCanvas: ILeaferCanvas, fromBounds?: IBoundsData, toBounds?: IBoundsData): void;
    useEraser(eraserCanvas: ILeaferCanvas, fromBounds?: IBoundsData, toBounds?: IBoundsData): void;
    fillWorld(bounds: IBoundsData, color: string | object, blendMode?: string): void;
    strokeWorld(bounds: IBoundsData, color: string | object, blendMode?: string): void;
    clipWorld(bounds: IBoundsData, ceilPixel?: boolean): void;
    clearWorld(bounds: IBoundsData, ceilPixel?: boolean): void;
    clear(): void;
}
interface ILeaferCanvas extends ICanvasAttr, ICanvasMethod, IPathDrawer {
    readonly innerId: InnerId;
    name: string;
    manager: ICanvasManager;
    width: number;
    height: number;
    pixelRatio: number;
    readonly pixelWidth: number;
    readonly pixelHeight: number;
    readonly allowBackgroundColor?: boolean;
    backgroundColor?: string;
    hittable?: boolean;
    bounds: IBounds;
    clientBounds: IBoundsData;
    config: ILeaferCanvasConfig;
    autoLayout: boolean;
    view: any;
    parentView: any;
    unreal?: boolean;
    context: ICanvasContext2D;
    recycled?: boolean;
    worldTransform: IMatrixData;
    init(): void;
    toBlob(type?: string, quality?: number): Promise<IBlob>;
    toDataURL(type?: string, quality?: number): string | Promise<string>;
    saveAs(filename: string, quality?: number): Promise<boolean>;
    startAutoLayout(autoBounds: IAutoBounds, listener: IResizeEventListener): void;
    stopAutoLayout(): void;
    resize(size: IScreenSizeData): void;
    updateViewSize(): void;
    updateClientBounds(): void;
    setCursor(cursor: ICursorType | ICursorType[]): void;
    isSameSize(options: ILeaferCanvasConfig): boolean;
    getSameCanvas(useSameWorldTransform?: boolean): ILeaferCanvas;
    getBiggerCanvas(addWidth: number, addHeight: number): ILeaferCanvas;
    recycle(): void;
    updateRender(): void;
    unrealCanvas(): void;
    destroy(): void;
}
interface IHitCanvas extends ILeaferCanvas {
}
interface IBlobFunction {
    (blob: IBlob | null): void;
}
type IBlob = any;

interface IFunction {
    (...arg: any): any;
}
interface INumberFunction {
    (...arg: any): number;
}
interface IPointDataFunction {
    (...arg: any): IPointData;
}

interface IRenderOptions {
    bounds?: IBounds;
    hideBounds?: IBounds;
    matrix?: IMatrix;
    inCamera?: boolean;
}
interface IRendererConfig {
    usePartRender?: boolean;
    maxFPS?: number;
    fill?: string;
}
interface IRenderer extends IControl {
    target: ILeaf;
    canvas: ILeaferCanvas;
    updateBlocks: IBounds[];
    FPS: number;
    totalTimes: number;
    times: number;
    running: boolean;
    rendering: boolean;
    waitAgain: boolean;
    changed: boolean;
    config: IRendererConfig;
    update(): void;
    requestLayout(): void;
    render(callback?: IFunction): void;
    renderAgain(): void;
    renderOnce(callback?: IFunction): void;
    partRender(): void;
    clipRender(bounds: IBounds): void;
    fullRender(): void;
    renderHitView(options: IRenderOptions): void;
    renderBoundsView(options: IRenderOptions): void;
    addBlock(block: IBounds): void;
    mergeBlocks(): void;
}

type ILeafDataProxyModule = ILeafDataProxy & ThisType<ILeaf>;
interface ILeafDataProxy {
    __setAttr?(name: string, newValue: __Value): void;
    __getAttr?(name: string): __Value;
}

type ILeafMatrixModule = ILeafMatrix & ThisType<ILeaf>;
interface ILeafMatrix {
    __updateWorldMatrix?(): void;
    __updateLocalMatrix?(): void;
}

type ILeafBoundsModule = ILeafBounds & ThisType<ILeaf>;
interface ILeafBounds {
    __updateWorldBounds?(): void;
    __updateLocalBoxBounds?(): void;
    __updateLocalStrokeBounds?(): void;
    __updateLocalRenderBounds?(): void;
    __updateBoxBounds?(): void;
    __updateStrokeBounds?(): void;
    __updateRenderBounds?(): void;
    __updateNaturalSize?(): void;
    __updateStrokeSpread?(): number;
    __updateRenderSpread?(): number;
    __onUpdateSize?(): void;
}

type ILayoutLocationType = 'world' | 'local' | 'inner';
type ILayoutBoundsType = 'content' | 'box' | 'stroke' | 'margin' | 'render';
interface ILeafLayout {
    leaf: ILeaf;
    useZoomProxy: boolean;
    boxBounds: IBoundsData;
    strokeBounds: IBoundsData;
    renderBounds: IBoundsData;
    marginBounds: IBoundsData;
    contentBounds: IBoundsData;
    localStrokeBounds: IBoundsData;
    localRenderBounds: IBoundsData;
    matrixChanged: boolean;
    positionChanged: boolean;
    originChanged?: boolean;
    scaleChanged: boolean;
    rotationChanged: boolean;
    boundsChanged: boolean;
    boxChanged: boolean;
    strokeChanged: boolean;
    renderChanged: boolean;
    localBoxChanged: boolean;
    surfaceChanged: boolean;
    opacityChanged: boolean;
    hitCanvasChanged: boolean;
    childrenSortChanged?: boolean;
    affectScaleOrRotation: boolean;
    affectRotation: boolean;
    affectChildrenSort?: boolean;
    strokeSpread: number;
    renderSpread: number;
    strokeBoxSpread: number;
    renderShapeSpread: number;
    checkUpdate(force?: boolean): void;
    getTransform(locationType: ILayoutLocationType): IMatrixData;
    getBounds(type: ILayoutBoundsType, locationType: ILayoutLocationType): IBoundsData;
    spreadStroke(): void;
    spreadRender(): void;
    spreadStrokeCancel(): void;
    spreadRenderCancel(): void;
    boxChange(): void;
    localBoxChange(): void;
    strokeChange(): void;
    renderChange(): void;
    positionChange(): void;
    scaleChange(): void;
    rotationChange(): void;
    surfaceChange(): void;
    opacityChange(): void;
    childrenSortChange(): void;
    destroy(): void;
}

type ILeafHitModule = ILeafHit & ThisType<ILeaf>;
interface ILeafHit {
    __hitWorld?(point: IRadiusPointData): boolean;
    __hit?(local: IRadiusPointData): boolean;
    __drawHitPath?(canvas: ILeaferCanvas): void;
    __updateHitCanvas?(): void;
}

type ILeafRenderModule = ILeafRender & ThisType<ILeaf>;
interface ILeafRender {
    __render?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __draw?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawFast?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __renderShape?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __updateWorldOpacity?(): void;
    __updateChange?(): void;
}

type ILeafMaskModule = ILeafMask & ThisType<ILeaf>;
interface ILeafMask {
    __updateEraser?(value?: boolean): void;
    __updateMask?(value?: boolean): void;
    __renderMask?(canvas: ILeaferCanvas, content: ILeaferCanvas, mask: ILeaferCanvas): void;
    __removeMask?(child?: ILeaf): void;
}

interface IDataProcessor extends IObject {
    __leaf: ILeaf;
    __input: IObject;
    __middle: IObject;
    __single: boolean;
    __checkSingle(): void;
    __get(name: string): any;
    __setInput(name: string, value: any): void;
    __getInput(name: string): any;
    __removeInput(name: string): void;
    __getInputData(): IObject;
    __setMiddle(name: string, value: any): void;
    __getMiddle(name: string): any;
    destroy(): void;
}
interface ILeafData extends IDataProcessor, ILeafComputedData {
}

interface ICachedLeaf {
    canvas: ILeaferCanvas;
    matrix?: IMatrix;
    bounds: IBoundsData;
}
interface ILeafAttrData {
    id: __String;
    name: __String;
    className: __String;
    blendMode: IBlendMode;
    opacity: __Number;
    visible: __Boolean;
    isMask: __Boolean;
    isEraser: __Boolean;
    zIndex: __Number;
    x: __Number;
    y: __Number;
    width: __Number;
    height: __Number;
    scaleX: __Number;
    scaleY: __Number;
    rotation: __Number;
    skewX: __Number;
    skewY: __Number;
    scale: __Number | IPointData;
    around: 'center' | IPointData;
    draggable: __Boolean;
    hittable: __Boolean;
    hitFill: IHitType;
    hitStroke: IHitType;
    hitChildren: __Boolean;
    hitSelf: __Boolean;
    hitRadius: __Number;
    cursor: ICursorType | ICursorType[];
}
type IHitType = 'path' | 'pixel' | 'all' | 'none';
type IBlendMode = 'pass-through' | 'normal' | 'multiply' | 'screen' | 'overlay' | 'darken' | 'lighten' | 'color-dodge' | 'color-burn' | 'hard-light' | 'soft-light' | 'difference' | 'exclusion' | 'hue' | 'saturation' | 'color' | 'luminosity' | 'source-over' | 'source-in' | 'source-out' | 'source-atop' | 'destination-over' | 'destination-in' | 'destination-out' | 'destination-atop';
type IResizeType = 'size' | 'scale';
interface IImageCursor {
    url: string;
    x?: number;
    y?: number;
}
type IAround = 'center' | IPointData;
type ICursorType = IImageCursor | '' | 'auto' | 'default' | 'none' | 'context-menu' | 'help' | 'pointer' | 'progress' | 'wait' | 'cell' | 'crosshair' | 'text' | 'vertical-text' | 'alias' | 'copy' | 'move' | 'no-drop' | 'not-allowed' | 'grab' | 'grabbing' | 'e-resize' | 'n-resize' | 'ne-resize' | 'nw-resize' | 's-resize' | 'se-resize' | 'sw-resize' | 'w-resize' | 'ew-resize' | 'ns-resize' | 'nesw-resize' | 'nwse-resize' | 'col-resize' | 'row-resize' | 'all-scroll' | 'zoom -in' | 'zoom-out';
interface ICursorTypeMap {
    [name: string]: ICursorType | ICursorType[];
}
interface ILeafInputData extends IObject {
    tag?: string;
    id?: __String;
    name?: __String;
    className?: __String;
    blendMode?: IBlendMode;
    opacity?: __Number;
    visible?: __Boolean;
    isMask?: __Boolean;
    isEraser?: __Boolean;
    zIndex?: __Number;
    x?: __Number;
    y?: __Number;
    width?: __Number;
    height?: __Number;
    scaleX?: __Number;
    scaleY?: __Number;
    rotation?: __Number;
    skewX?: __Number;
    skewY?: __Number;
    scale?: __Number | IPointData;
    around?: IAround;
    draggable?: __Boolean;
    hittable?: __Boolean;
    hitFill?: IHitType;
    hitStroke?: IHitType;
    hitChildren?: __Boolean;
    hitSelf?: __Boolean;
    hitRadius?: __Number;
    cursor?: ICursorType | ICursorType[];
    children?: ILeafInputData[];
}
interface ILeafComputedData {
    id?: string;
    name?: string;
    className?: string;
    blendMode?: IBlendMode;
    opacity?: number;
    visible?: boolean;
    isMask?: boolean;
    isEraser?: boolean;
    zIndex?: number;
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    scaleX?: number;
    scaleY?: number;
    rotation?: number;
    skewX?: number;
    skewY?: number;
    around?: IAround;
    draggable?: boolean;
    hittable?: boolean;
    hitFill?: IHitType;
    hitStroke?: IHitType;
    hitChildren?: boolean;
    hitSelf?: boolean;
    hitRadius?: number;
    cursor?: ICursorType | ICursorType[];
    __childBranchNumber?: number;
    __complex?: boolean;
    __naturalWidth?: number;
    __naturalHeight?: number;
}
interface ILeaf extends ILeafMask, ILeafRender, ILeafHit, ILeafBounds, ILeafMatrix, ILeafDataProxy, ILeafInputData, IEventer {
    tag: string;
    readonly __tag: string;
    readonly innerName: string;
    readonly __DataProcessor: IObject;
    readonly __LayoutProcessor: IObject;
    leafer?: ILeafer;
    parent?: ILeaf;
    readonly isApp?: boolean;
    isLeafer?: boolean;
    isBranch?: boolean;
    isBranchLeaf?: boolean;
    __: ILeafData;
    __layout: ILeafLayout;
    __world: IMatrixWithLayoutData;
    __local: IMatrixWithBoundsData;
    __worldOpacity: number;
    readonly worldTransform: IMatrixWithLayoutData;
    readonly localTransform: IMatrixWithBoundsData;
    readonly boxBounds: IBoundsData;
    readonly worldBoxBounds: IBoundsData;
    readonly worldStrokeBounds: IBoundsData;
    readonly worldRenderBounds: IBoundsData;
    readonly worldOpacity: number;
    __renderTime?: number;
    __level: number;
    __tempNumber?: number;
    readonly resizeable: boolean;
    readonly __hasMirror: boolean;
    __hasMask?: boolean;
    __hasEraser?: boolean;
    __hitCanvas?: IHitCanvas;
    readonly __onlyHitMask: boolean;
    readonly __ignoreHitWorld: boolean;
    __parentWait?: IFunction[];
    __leaferWait?: IFunction[];
    destroyed: boolean;
    waitParent(item: IFunction): void;
    waitLeafer(item: IFunction): void;
    nextRender(item: IFunction): void;
    __bindLeafer(leafer: ILeafer | null): void;
    set(data: IObject): void;
    toJSON(): IObject;
    toString(): string;
    __setAttr(attrName: string, newValue: __Value): void;
    __getAttr(attrName: string): __Value;
    forceUpdate(attrName?: string): void;
    __updateWorldMatrix(): void;
    __updateLocalMatrix(): void;
    __updateWorldBounds(): void;
    __updateLocalBoxBounds(): void;
    __updateLocalStrokeBounds(): void;
    __updateLocalRenderBounds(): void;
    __updateBoxBounds(): void;
    __updateStrokeBounds(): void;
    __updateRenderBounds(): void;
    __updateNaturalSize(): void;
    __updateStrokeSpread(): number;
    __updateRenderSpread(): number;
    __onUpdateSize(): void;
    __updateEraser(value?: boolean): void;
    __updateMask(value?: boolean): void;
    __renderMask(canvas: ILeaferCanvas, content: ILeaferCanvas, mask: ILeaferCanvas): void;
    __removeMask(child?: ILeaf): void;
    getWorld(attrName: IMatrixDecompositionAttr): number;
    getBounds(type: ILayoutBoundsType, locationType?: ILayoutLocationType): IBoundsData;
    worldToLocal(world: IPointData, to?: IPointData, distance?: boolean, relative?: ILeaf): void;
    localToWorld(local: IPointData, to?: IPointData, distance?: boolean, relative?: ILeaf): void;
    worldToInner(world: IPointData, to?: IPointData, distance?: boolean, relative?: ILeaf): void;
    innerToWorld(inner: IPointData, to?: IPointData, distance?: boolean, relative?: ILeaf): void;
    getInnerPoint(world: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getInnerPointByLocal(local: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getLocalPoint(world: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getLocalPointByInner(inner: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getWorldPoint(inner: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getWorldPointByLocal(local: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    move(x: number, y?: number): void;
    scaleOf(origin: IPointData, x: number, y?: number): void;
    rotateOf(origin: IPointData, rotation: number): void;
    skewOf(origin: IPointData, x: number, y: number): void;
    __hitWorld(point: IRadiusPointData): boolean;
    __hit(local: IRadiusPointData): boolean;
    __drawHitPath(canvas: ILeaferCanvas): void;
    __updateHitCanvas(): void;
    __render(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawFast(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __draw(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __renderShape(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __updateWorldOpacity(): void;
    __updateChange(): void;
    __drawPath(canvas: ILeaferCanvas): void;
    __drawRenderPath(canvas: ILeaferCanvas): void;
    __updatePath(): void;
    __updateRenderPath(): void;
    children?: ILeaf[];
    __updateSortChildren(): void;
    add(child: ILeaf, index?: number): void;
    remove(child?: ILeaf, destroy?: boolean): void;
}

interface ISelectPathResult {
    leaf: ILeaf;
    path: ILeafList;
    throughPath?: ILeafList;
}
interface ISelectPathOptions {
    name?: string;
    through?: boolean;
    exclude?: ILeafList;
    ignoreHittable?: boolean;
}
interface ISelectorConfig {
}
interface ISelector {
    target: ILeaf;
    config: ISelectorConfig;
    getByPoint(hitPoint: IPointData, hitRadius: number, options?: ISelectPathOptions): ISelectPathResult;
    find(name: number | string, branch?: ILeaf): ILeaf | ILeaf[];
    getByInnerId(name: number, branch?: ILeaf): ILeaf;
    getById(name: string, branch?: ILeaf): ILeaf;
    getByClassName(name: string, branch?: ILeaf): ILeaf[];
    getByTagName(name: string, branch?: ILeaf): ILeaf[];
    destroy(): void;
}

type IExportImageType = 'jpg' | 'png' | 'webp';
type IExportFileType = IExportImageType | 'svg' | 'pdf' | 'json';

interface ILeaferImageConfig {
    url: string;
    thumb?: string;
    format?: IExportFileType;
}
interface ILeaferImageOnLoaded {
    (image?: ILeaferImage): any;
}
interface ILeaferImageOnError {
    (error?: string | IObject, image?: ILeaferImage): any;
}
interface ILeaferImage {
    readonly innerId: InnerId;
    readonly url: string;
    view: unknown;
    width: number;
    height: number;
    isSVG: boolean;
    readonly completed: boolean;
    ready: boolean;
    error: IObject;
    loading: boolean;
    use: number;
    config: ILeaferImageConfig;
    load(onSuccess?: ILeaferImageOnLoaded, onError?: ILeaferImageOnError): number;
    unload(index: number, stopEvent?: boolean): void;
    getCanvas(width: number, height: number, opacity?: number, _filters?: IObject): unknown;
    destroy(): void;
}

interface IUIEvent extends IEvent {
    x: number;
    y: number;
    altKey?: boolean;
    ctrlKey?: boolean;
    shiftKey?: boolean;
    metaKey?: boolean;
    readonly spaceKey?: boolean;
    readonly left?: boolean;
    readonly right?: boolean;
    readonly middle?: boolean;
    buttons?: number;
    path?: ILeafList;
    throughPath?: ILeafList;
    origin?: IObject;
    getInner?(target?: ILeaf): IPointData;
    getLocal?(target?: ILeaf): IPointData;
}
interface IPointerEvent extends IUIEvent {
    width?: number;
    height?: number;
    pointerType?: PointerType;
    pressure?: number;
    tangentialPressure?: number;
    tiltX?: number;
    tiltY?: number;
    twist?: number;
}
type PointerType = 'mouse' | 'pen' | 'touch';
interface IDragEvent extends IPointerEvent {
    moveX: number;
    moveY: number;
    totalX?: number;
    totalY?: number;
    getInnerMove?(target?: ILeaf): IPointData;
    getLocalMove?(target?: ILeaf): IPointData;
    getInnerTotal?(target?: ILeaf): IPointData;
    getLocalTotal?(target?: ILeaf): IPointData;
}
interface IDropEvent extends IPointerEvent {
    list: ILeafList;
    data?: IObject;
}
interface IRotateEvent extends IUIEvent {
    rotation: number;
}
interface IZoomEvent extends IUIEvent {
    scale: number;
}
interface IMoveEvent extends IDragEvent {
}
interface ISwipeEvent extends IDragEvent {
}
interface IKeyEvent extends IUIEvent {
    code?: string;
    key?: string;
}
interface IImageEvent extends IEvent {
    image?: ILeaferImage;
    attrName?: string;
    attrValue?: IObject;
    error?: string | IObject;
}

interface IInteraction extends IControl {
    target: ILeaf;
    canvas: IInteractionCanvas;
    selector: ISelector;
    running: boolean;
    readonly dragging: boolean;
    readonly moveMode: boolean;
    config: IInteractionConfig;
    cursor: ICursorType | ICursorType[];
    readonly hitRadius: number;
    shrinkCanvasBounds: IBounds;
    downData: IPointerEvent;
    hoverData: IPointerEvent;
    downTime: number;
    receive(event: any): void;
    pointerDown(data?: IPointerEvent, defaultPath?: boolean): void;
    pointerMove(data?: IPointerEvent): void;
    pointerMoveReal(data: IPointerEvent): void;
    pointerUp(data?: IPointerEvent): void;
    pointerCancel(): void;
    multiTouch(data: IUIEvent, list: IKeepTouchData[]): void;
    move(data: IMoveEvent): void;
    zoom(data: IZoomEvent): void;
    rotate(data: IRotateEvent): void;
    keyDown(data: IKeyEvent): void;
    keyUp(data: IKeyEvent): void;
    findPath(data: IPointerEvent, options?: ISelectPathOptions): ILeafList;
    updateDownData(data?: IPointerEvent): void;
    updateHoverData(data: IPointerEvent): void;
    updateCursor(hoverData?: IPointerEvent): void;
    emit(type: string, data: IUIEvent, path?: ILeafList, excludePath?: ILeafList): void;
}
interface IInteractionCanvas extends ILeaferCanvas {
}
interface IInteractionConfig {
    wheel?: IWheelConfig;
    pointer?: IPointerConfig;
    cursor?: ICursorConfig;
    zoom?: IZoomConfig;
    move?: IMoveConfig;
    eventer?: IObject;
}
interface IZoomConfig {
    min?: number;
    max?: number;
}
interface IMoveConfig {
    holdSpaceKey?: boolean;
    dragEmpty?: boolean;
    dragOut?: boolean;
    autoDistance?: number;
}
interface IWheelConfig {
    zoomMode?: boolean;
    zoomSpeed?: number;
    moveSpeed?: number;
    rotateSpeed?: number;
    delta?: IPointData;
    getScale?: INumberFunction;
    getMove?: IPointDataFunction;
    preventDefault?: boolean;
}
interface IPointerConfig {
    hitRadius?: number;
    through?: boolean;
    tapMore?: boolean;
    tapTime?: number;
    longPressTime?: number;
    transformTime?: number;
    dragHover?: boolean;
    dragDistance?: number;
    swipeDistance?: number;
    ignoreMove?: boolean;
    preventDefault?: boolean;
}
interface ICursorConfig {
    stop?: boolean;
}

interface IHitCanvasManager extends ICanvasManager {
    getPathType(leaf: ILeaf): IHitCanvas;
    getImageType(leaf: ILeaf, size: IScreenSizeData): IHitCanvas;
}

interface IBranch extends ILeaf {
    children: ILeaf[];
    __renderBranch?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    addMany(...children: ILeaf[]): void;
    removeAll(destroy?: boolean): void;
}

interface IZoomView extends IBranch {
    zoomLayer?: ILeaf;
    moveLayer?: ILeaf;
    transformData?: ITransformEventData;
    setZoomLayer(zoomLayer: ILeaf, moveLayer?: ILeaf): void;
}

type ILeaferType = 'draw' | 'design' | 'board' | 'document' | 'user';
interface ILeaferConfig extends IRendererConfig, ILeaferCanvasConfig, IInteractionConfig, ILayouterConfig {
    start?: boolean;
    type?: ILeaferType;
    realCanvas?: boolean;
}
interface ILeafer extends IZoomView, IControl {
    readonly isApp: boolean;
    readonly app: ILeafer;
    parent?: IApp;
    running: boolean;
    created: boolean;
    ready: boolean;
    viewReady: boolean;
    viewCompleted: boolean;
    pixelRatio: number;
    view: unknown;
    canvas: ILeaferCanvas;
    renderer: IRenderer;
    watcher: IWatcher;
    layouter: ILayouter;
    selector?: ISelector;
    interaction?: IInteraction;
    canvasManager: ICanvasManager;
    hitCanvasManager?: IHitCanvasManager;
    autoLayout?: IAutoBounds;
    config: ILeaferConfig;
    __eventIds: IEventListenerId[];
    __nextRenderWait: IFunction[];
    init(userConfig?: ILeaferConfig, parentApp?: IApp): void;
    setZoomLayer(zoomLayer: ILeaf, moveLayer?: ILeaf): void;
    forceFullRender(): void;
    updateCursor(): void;
    resize(size: IScreenSizeData): void;
    waitReady(item: IFunction): void;
    waitViewReady(item: IFunction): void;
    waitViewCompleted(item: IFunction): void;
}
interface ILeaferTypeCreator {
    list: ILeaferTypeList;
    register(name: string, fn: ILeaferTypeFunction): void;
    run(name: string, leafer: ILeafer): void;
}
interface ILeaferTypeFunction {
    (leafer: ILeafer): void;
}
interface ILeaferTypeList {
    [key: string]: ILeaferTypeFunction;
}
interface ICreator {
    image?(options?: ILeaferImageConfig): ILeaferImage;
    canvas?(options?: ILeaferCanvasConfig, manager?: ICanvasManager): ILeaferCanvas;
    hitCanvas?(options?: IHitCanvasConfig, manager?: ICanvasManager): IHitCanvas;
    watcher?(target: ILeaf, options?: IWatcherConfig): IWatcher;
    layouter?(target: ILeaf, options?: ILayouterConfig): ILayouter;
    renderer?(target: ILeaf, canvas: ILeaferCanvas, options?: IRendererConfig): IRenderer;
    selector?(target: ILeaf, options?: ISelectorConfig): ISelector;
    interaction?(target: ILeaf, canvas: IInteractionCanvas, selector: ISelector, options?: IInteractionConfig): IInteraction;
}
interface IUICreator {
    register(UI: IObject): void;
    get(tag: string, data: IObject): IObject;
}

interface IApp extends ILeafer {
    children: ILeafer[];
    realCanvas: boolean;
}

type IBranchRenderModule = IBranchRender & ThisType<IBranch>;
interface IBranchRender extends ILeafRender {
    __renderBranch?(canvas: ILeaferCanvas, options: IRenderOptions): void;
}

interface ITaskProcessorConfig {
    onComplete?: IFunction;
    onTask?: IFunction;
    onError?: IFunction;
    parallel?: number;
}
interface ITaskProcessor {
    config: ITaskProcessorConfig;
    running: boolean;
    isComplete: boolean;
    percent: number;
    total: number;
    index: number;
    finishedIndex: number;
    remain: number;
    start(): void;
    pause(): void;
    resume(): void;
    skip(): void;
    stop(): void;
    add(taskCallback: IFunction, options?: ITaskOptions | number): ITaskItem;
    destroy(): void;
}
interface ITaskItem {
    parent: ITaskProcessor;
    parallel: boolean;
    isComplete: boolean;
    isCancel: boolean;
    time: number;
    run(): Promise<void>;
    complete(): void;
    cancel(): void;
}
interface ITaskOptions {
    start?: boolean;
    time?: number;
    parallel?: boolean;
    delay?: number;
}

interface ILeaferImageMap {
    [name: string]: ILeaferImage;
}
interface IImageManager {
    map: ILeaferImageMap;
    recycledList: ILeaferImage[];
    tasker: ITaskProcessor;
    patternTasker: ITaskProcessor;
    readonly isComplete: boolean;
    get(config: ILeaferImageConfig): ILeaferImage;
    recycle(image: ILeaferImage): void;
    clearRecycled(): void;
    destroy(): void;
}

interface IPlatform {
    name?: 'web' | 'node' | 'miniapp';
    os?: 'Mac' | 'Windows' | 'Linux';
    requestRender?(render: IFunction): void;
    canvas?: ILeaferCanvas;
    isWorker?: boolean;
    isMobile?: boolean;
    devicePixelRatio?: number;
    intWheelDeltaY?: boolean;
    conicGradientSupport?: boolean;
    conicGradientRotate90?: boolean;
    fullImageShadow?: boolean;
    syncDomFont?: boolean;
    layout?(target: ILeaf): void;
    realtimeLayout?: boolean;
    origin?: {
        createCanvas(width: number, height: number, format?: 'svg' | 'pdf'): any;
        canvasToDataURL(canvas: any, type?: IExportImageType, quality?: number): string | Promise<string>;
        canvasToBolb(canvas: any, type?: IExportFileType, quality?: number): Promise<any>;
        canvasSaveAs(canvas: any, filename: string, quality?: number): Promise<void>;
        loadImage(url: string): Promise<any>;
        noRepeat?: string;
    };
    miniapp?: IMiniapp;
    imageSuffix?: string;
}
interface IMiniappSelect extends IObject {
}
interface IMiniappSizeView extends ISizeData {
    view: any;
}
interface IMiniapp {
    select(name: string): IMiniappSelect;
    getBounds(select: IMiniappSelect): Promise<IBoundsData>;
    getSizeView(select: IMiniappSelect): Promise<IMiniappSizeView>;
    onWindowResize(fun: IFunction): void;
    offWindowResize(fun: IFunction): void;
    saveToAlbum(path: string): Promise<any>;
}

interface IPlugin extends IObject {
    name?: string;
    importVersion: string;
    import: string[];
    run(LeaferUI: IObject, config: IObject): void;
    onLeafer?(leafer: ILeafer): void;
}

type ICanvasType = 'skia' | 'canvas' | 'wx';
interface ISkiaCanvas {
    toBuffer(format: IExportFileType, config: ISkiaCanvasExportConfig): Promise<any>;
    toBufferSync(format: IExportFileType, config: ISkiaCanvasExportConfig): any;
    toDataURL(format: IExportImageType, config: ISkiaCanvasExportConfig): Promise<string>;
    toDataURLSync(format: IExportImageType, config: ISkiaCanvasExportConfig): string;
    saveAs(filename: string, config: ISkiaCanvasExportConfig): Promise<void>;
    saveAsSync(filename: string, config: ISkiaCanvasExportConfig): void;
}
interface ISkiaCanvasExportConfig {
    page?: number;
    matte?: string;
    density?: number;
    quality?: number;
    outline?: boolean;
}

export type { ACommandData, ArcCommandData, ArcToCommandData, CCommandData, CanvasPathCommand, EllipseCommandData, HCommandData, IAnimateEvent, IApp, IAround, IAutoBounds, IAutoBoundsData, IBlendMode, IBlob, IBlobFunction, IBooleanMap, IBounds, IBoundsData, IBoundsDataHandle, IBranch, IBranchRender, IBranchRenderModule, ICachedLeaf, ICanvasAttr, ICanvasContext2D, ICanvasManager, ICanvasStrokeOptions, ICanvasType, IChildEvent, IControl, ICreator, ICursorType, ICursorTypeMap, IDataProcessor, IDataTypeHandle, IDragEvent, IDropEvent, IEvent, IEventListener, IEventListenerId, IEventListenerItem, IEventListenerMap, IEventListenerOptions, IEventTarget, IEventer, IExportFileType, IExportImageType, IFunction, IHitCanvas, IHitCanvasConfig, IHitCanvasManager, IHitType, IImageEvent, IImageManager, IInteraction, IInteractionCanvas, IInteractionConfig, IKeepTouchData, IKeyEvent, ILayoutBlockData, ILayoutBoundsType, ILayoutChangedData, ILayoutEvent, ILayoutLocationType, ILayouter, ILayouterConfig, ILeaf, ILeafArrayMap, ILeafAttrData, ILeafBounds, ILeafBoundsModule, ILeafComputedData, ILeafData, ILeafDataProxy, ILeafDataProxyModule, ILeafEventer, ILeafEventerModule, ILeafHit, ILeafHitModule, ILeafInputData, ILeafLayout, ILeafLevelList, ILeafList, ILeafListItemCallback, ILeafMap, ILeafMask, ILeafMaskModule, ILeafMatrix, ILeafMatrixModule, ILeafRender, ILeafRenderModule, ILeafer, ILeaferCanvas, ILeaferCanvasConfig, ILeaferConfig, ILeaferEvent, ILeaferImage, ILeaferImageConfig, ILeaferImageOnError, ILeaferImageOnLoaded, ILeaferType, ILeaferTypeCreator, ILeaferTypeFunction, ILeaferTypeList, IMatrix, IMatrixData, IMatrixDecompositionAttr, IMatrixDecompositionData, IMatrixWithBoundsData, IMatrixWithLayoutData, IMiniapp, IMiniappSelect, IMiniappSizeView, IMoveEvent, IMultiTouchData, INumberMap, IObject, IOffsetBoundsData, IPartLayoutConfig, IPath2D, IPathCommandData, IPathCreator, IPathDrawer, IPathString, IPlatform, IPlugin, IPoint, IPointData, IPointerConfig, IPointerEvent, IPropertyEvent, IRadiusPointData, IRenderEvent, IRenderOptions, IRenderer, IRendererConfig, IResizeEvent, IResizeEventListener, IResizeType, IRotateEvent, IScreenSizeData, ISelectPathOptions, ISelectPathResult, ISelector, ISelectorConfig, ISize, ISizeData, ISkiaCanvas, ISkiaCanvasExportConfig, IStringMap, ISwipeEvent, ITaskItem, ITaskOptions, ITaskProcessor, ITaskProcessorConfig, ITextMetrics, ITimer, ITransformEvent, ITransformEventData, ITwoPointBounds, ITwoPointBoundsData, IUICreator, IUIEvent, IUpdateEvent, IWatchEvent, IWatchEventData, IWatcher, IWatcherConfig, IWheelConfig, IWindingRule, IZoomEvent, IZoomView, InnerId, LCommandData, MCommandData, PointerType, QCommandData, RectCommandData, RoundRectCommandData, SCommandData, TCommandData, TransformMode, VCommandData, ZCommandData, __Boolean, __Number, __Object, __String, __Value };
