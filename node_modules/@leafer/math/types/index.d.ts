import { INumberMap, IPoint, IPointData, IMatrixData, IBounds, IBoundsData, IMatrix, IObject, IBoundsDataHandle, IRadiusPointData, IMatrixWithLayoutData, IAutoBounds, IAutoBoundsData, ISizeData, ITwoPointBounds, ITwoPointBoundsData, IMatrixDecompositionData, IOffsetBoundsData } from '@leafer/interface';

declare const IncrementId: {
    RUNTIME: string;
    LEAF: string;
    TASK: string;
    CNAVAS: string;
    IMAGE: string;
    types: INumberMap;
    create(typeName: string): number;
};

declare class Point implements IPoint {
    x: number;
    y: number;
    constructor(x?: number | IPointData, y?: number);
    set(x?: number, y?: number): void;
    copy(point: IPointData): IPoint;
    clone(): IPoint;
    rotate(angle: number, center?: IPointData): IPoint;
    toInnerOf(matrix: IMatrixData, to?: IPointData): IPoint;
    toOuterOf(matrix: IMatrixData, to?: IPointData): IPoint;
    getCenter(to: IPointData): IPointData;
    getDistance(to: IPointData): number;
    getAngle(to: IPointData): number;
    getAtan2(to: IPointData): number;
    reset(): void;
}

declare class Bounds implements IBounds {
    x: number;
    y: number;
    width: number;
    height: number;
    constructor(x?: number | IBoundsData, y?: number, width?: number, height?: number);
    set(x?: number, y?: number, width?: number, height?: number): void;
    copy(bounds: IBoundsData): IBounds;
    clone(): IBounds;
    scale(scaleX: number, scaleY?: number): IBounds;
    toOuterOf(matrix: IMatrixData, to?: IBoundsData): IBounds;
    getFitMatrix(put: IBoundsData): IMatrix;
    spread(size: number): IBounds;
    ceil(): IBounds;
    unsign(): IBounds;
    add(bounds: IBoundsData): IBounds;
    addList(boundsList: IBounds[]): IBounds;
    setByList(boundsList: IBounds[], addMode?: boolean): IBounds;
    addListWithHandle(list: IObject[], boundsDataHandle: IBoundsDataHandle): IBounds;
    setByListWithHandle(list: IObject[], boundsDataHandle: IBoundsDataHandle, addMode?: boolean): IBounds;
    setByPoints(points: IPointData[]): IBounds;
    hitPoint(point: IPointData, pointMatrix?: IMatrixData): boolean;
    hitRadiusPoint(point: IRadiusPointData, pointMatrix?: IMatrixWithLayoutData): boolean;
    hit(bounds: IBoundsData, boundsMatrix?: IMatrixData): boolean;
    includes(bounds: IBoundsData, boundsMatrix?: IMatrixData): boolean;
    intersect(bounds: IBoundsData, boundsMatrix?: IMatrixData): IBounds;
    getIntersect(bounds: IBoundsData, boundsMatrix?: IMatrixData): IBounds;
    isSame(bounds: IBoundsData): boolean;
    isEmpty(): boolean;
    reset(): void;
}

declare class AutoBounds implements IAutoBounds {
    top: number;
    right: number;
    bottom: number;
    left: number;
    width: number;
    height: number;
    constructor(top?: number | IAutoBoundsData, right?: number, bottom?: number, left?: number, width?: number, height?: number);
    set(top?: number, right?: number, bottom?: number, left?: number, width?: number, height?: number): void;
    copy(autoSize: IAutoBoundsData): void;
    getBoundsFrom(parent: ISizeData): IBounds;
}

declare class TwoPointBounds implements ITwoPointBounds {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
    constructor(x: number, y: number);
    addPoint(x: number, y: number): void;
    addBounds(x: number, y: number, width: number, height: number): void;
    add(pb: ITwoPointBoundsData): void;
}

declare class Matrix implements IMatrix {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    constructor(a?: number | IMatrixData, b?: number, c?: number, d?: number, e?: number, f?: number);
    set(a?: number, b?: number, c?: number, d?: number, e?: number, f?: number): void;
    copy(matrix: IMatrixData): IMatrix;
    clone(): IMatrix;
    translate(x: number, y: number): IMatrix;
    translateInner(x: number, y: number): IMatrix;
    scale(x: number, y?: number): IMatrix;
    scaleOfOuter(origin: IPointData, x: number, y?: number): IMatrix;
    scaleOfInner(origin: IPointData, x: number, y?: number): IMatrix;
    rotate(angle: number): IMatrix;
    rotateOfOuter(origin: IPointData, angle: number): IMatrix;
    rotateOfInner(origin: IPointData, angle: number): IMatrix;
    skew(x: number, y?: number): IMatrix;
    skewOfOuter(origin: IPointData, x: number, y?: number): IMatrix;
    skewOfInner(origin: IPointData, x: number, y?: number): IMatrix;
    multiply(matrix: IMatrixData): IMatrix;
    preMultiply(matrix: IMatrixData): IMatrix;
    divide(matrix: IMatrixData): IMatrix;
    invert(): IMatrix;
    toOuterPoint(inner: IPointData, to?: IPointData, distance?: boolean): void;
    toInnerPoint(outer: IPointData, to?: IPointData, distance?: boolean): void;
    decompose(): IMatrixDecompositionData;
    reset(): void;
}

declare const PointHelper: {
    defaultPoint: IPointData;
    tempPoint: IPointData;
    tempRadiusPoint: IRadiusPointData;
    set(t: IPointData, x?: number, y?: number): void;
    setRadius(t: IRadiusPointData, x: number, y?: number): void;
    copy(t: IPointData, point: IPointData): void;
    move(t: IPointData, x: number, y: number): void;
    rotate(t: IPointData, rotation: number, center?: IPointData): void;
    tempToInnerOf(t: IPointData, matrix: IMatrixData): IPointData;
    tempToOuterOf(t: IPointData, matrix: IMatrixData): IPointData;
    tempToInnerRadiusPointOf(t: IRadiusPointData, matrix: IMatrixWithLayoutData): IRadiusPointData;
    toInnerRadiusPointOf(t: IRadiusPointData, matrix: IMatrixWithLayoutData, to?: IRadiusPointData): void;
    toInnerOf(t: IPointData, matrix: IMatrixData, to?: IPointData): void;
    toOuterOf(t: IPointData, matrix: IMatrixData, to?: IPointData): void;
    getCenter(t: IPointData, to: IPointData): IPointData;
    getDistance(t: IPointData, point: IPointData): number;
    getAngle(t: IPointData, to: IPointData): number;
    getChangeAngle(t: IPointData, orign: IPointData, to: IPointData, toOrigin?: IPointData): number;
    getAtan2(t: IPointData, to: IPointData): number;
    getDistancePoint(t: IPointData, to: IPointData, distance: number): IPointData;
    reset(t: IPointData): void;
};

declare const BoundsHelper: {
    tempBounds: IBoundsData;
    set(t: IBoundsData, x?: number, y?: number, width?: number, height?: number): void;
    copy(t: IBoundsData, bounds: IBoundsData): void;
    copyAndSpread(t: IBoundsData, bounds: IBoundsData, spreadX: number, spreadY?: number): void;
    right(t: IBoundsData): number;
    bottom(t: IBoundsData): number;
    move(t: IBoundsData, x: number, y: number): void;
    getByMove(t: IBoundsData, x: number, y: number): IBoundsData;
    toOffsetOutBounds(t: IBoundsData, to?: IOffsetBoundsData, parent?: IBoundsData): void;
    scale(t: IBoundsData, scaleX: number, scaleY?: number): void;
    tempToOuterOf(t: IBoundsData, matrix: IMatrixData): IBoundsData;
    getOuterOf(t: IBoundsData, matrix: IMatrixData): IBoundsData;
    toOuterOf(t: IBoundsData, matrix: IMatrixData, to?: IBoundsData): void;
    getFitMatrix(t: IBoundsData, put: IBoundsData): IMatrix;
    getSpread(t: IBoundsData, spreadX: number, spreadY?: number): IBoundsData;
    spread(t: IBoundsData, spreadX: number, spreadY?: number): void;
    ceil(t: IBoundsData): void;
    unsign(t: IBoundsData): void;
    add(t: IBoundsData, bounds: IBoundsData): void;
    addList(t: IBoundsData, list: IBoundsData[]): void;
    setByList(t: IBoundsData, list: IBoundsData[], addMode?: boolean): void;
    addListWithHandle(t: IBoundsData, list: IObject[], boundsDataHandle: IBoundsDataHandle): void;
    setByListWithHandle(t: IBoundsData, list: IObject[], boundsDataHandle: IBoundsDataHandle, addMode?: boolean): void;
    setByPoints(t: IBoundsData, points: IPointData[]): void;
    hitRadiusPoint(t: IBoundsData, point: IRadiusPointData, pointMatrix?: IMatrixWithLayoutData): boolean;
    hitPoint(t: IBoundsData, point: IPointData, pointMatrix?: IMatrixData): boolean;
    hit(t: IBoundsData, other: IBoundsData, otherMatrix?: IMatrixData): boolean;
    includes(t: IBoundsData, other: IBoundsData, otherMatrix?: IMatrixData): boolean;
    getIntersectData(t: IBoundsData, other: IBoundsData, otherMatrix?: IMatrixData): IBoundsData;
    intersect(t: IBoundsData, other: IBoundsData, otherMatrix?: IMatrixData): void;
    isSame(t: IBoundsData, bounds: IBoundsData): boolean;
    isEmpty(t: IBoundsData): boolean;
    reset(t: IBoundsData): void;
};

declare const TwoPointBoundsHelper: {
    tempPointBounds: ITwoPointBoundsData;
    setPoint(t: ITwoPointBoundsData, minX: number, minY: number): void;
    addPoint(t: ITwoPointBoundsData, x: number, y: number): void;
    addBounds(t: ITwoPointBoundsData, x: number, y: number, width: number, height: number): void;
    copy(t: ITwoPointBoundsData, pb: ITwoPointBoundsData): void;
    add(t: ITwoPointBoundsData, pb: ITwoPointBoundsData): void;
    toBounds(t: ITwoPointBoundsData, setBounds: IBoundsData): void;
};

declare function get(): IMatrixData;
declare const MatrixHelper: {
    defaultMatrix: IMatrixData;
    tempMatrix: IMatrixData;
    set(t: IMatrixData, a?: number, b?: number, c?: number, d?: number, e?: number, f?: number): void;
    get: typeof get;
    copy(t: IMatrixData, matrix: IMatrixData): void;
    translate(t: IMatrixData, x: number, y: number): void;
    translateInner(t: IMatrixData, x: number, y: number): void;
    scale(t: IMatrixData, x: number, y?: number): void;
    scaleOfOuter(t: IMatrixData, origin: IPointData, x: number, y?: number): void;
    scaleOfInner(t: IMatrixData, origin: IPointData, x: number, y?: number): void;
    rotate(t: IMatrixData, angle: number): void;
    rotateOfOuter(t: IMatrixData, origin: IPointData, angle: number): void;
    rotateOfInner(t: IMatrixData, origin: IPointData, angle: number): void;
    skew(t: IMatrixData, x: number, y?: number): void;
    skewOfOuter(t: IMatrixData, origin: IPointData, x: number, y?: number): void;
    skewOfInner(t: IMatrixData, origin: IPointData, x: number, y?: number): void;
    multiply(t: IMatrixData, matrix: IMatrixData): void;
    preMultiply(t: IMatrixData, matrix: IMatrixData): void;
    divide(t: IMatrixData, matrix: IMatrixData): void;
    tempInvert(t: IMatrixData): IMatrixData;
    invert(t: IMatrixData): void;
    toOuterPoint(t: IMatrixData, inner: IPointData, to?: IPointData, distance?: boolean): void;
    toInnerPoint(t: IMatrixData, outer: IPointData, to?: IPointData, distance?: boolean): void;
    decompose(t: IMatrixData): IMatrixDecompositionData;
    reset(t: IMatrixData): void;
};

declare const MathHelper: {
    within(value: number, min: number, max: number): number;
    fourNumber(num: number | number[]): number[];
    formatRotation(rotation: number, unsign?: boolean): number;
    getGapRotation(rotation: number, gap: number): number;
    formatSkew(skew: number): number;
};
declare const OneRadian: number;
declare const PI2: number;
declare const PI_2: number;

declare const StringNumberMap: INumberMap;

export { AutoBounds, Bounds, BoundsHelper, IncrementId, MathHelper, Matrix, MatrixHelper, OneRadian, PI2, PI_2, Point, PointHelper, StringNumberMap, TwoPointBounds, TwoPointBoundsHelper };
