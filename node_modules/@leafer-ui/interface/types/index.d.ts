import { IPointData, IExportFileType, IWindingRule, IPathCommandData, IBlendMode, IMatrixData, ILeaferImage, IBlob, ILeaf, IPathString, IPathCreator, IBoundsData, ILeaferImageConfig, ILeaferCanvas, IRenderOptions, IPathDrawer, ILeafData, IPath2D, ILeafComputedData, ILeafInputData, IObject, ILeafRender, ILeafBounds, ILeafHit, ICachedLeaf, IBooleanMap } from '@leafer/interface';
export * from '@leafer/interface';

type IPercent = string;
type IColorString = string;
type ICornerRadiusString = string;
type IStrokeWidthString = string;
type IDashPatternString = string;
type IPaintString = ISolidPaintString | IGradientPaintString | IImagePaintString;
type ISolidPaintString = string;
type IGradientPaintString = string;
type IImagePaintString = string;
type IShadowString = string;

interface IUnitData {
    type: 'percent' | 'px';
    value: number;
}
type IPaint = ISolidPaint | IGradientPaint | IImagePaint;
interface IPaintBase {
    type: IPaintType;
    blendMode?: IBlendMode;
    visible?: boolean;
    opacity?: number;
}
type IPaintType = 'image' | 'solid' | IGradientType;
type IGradientType = 'linear' | 'radial' | 'angular';
interface ISolidPaint extends IPaintBase {
    type: 'solid';
    color: IColor;
}
type IColor = IColorString | IRGB | IRGBA;
interface IRGB {
    r: number;
    g: number;
    b: number;
    a?: number;
}
interface IRGBA extends IRGB {
    a: number;
}
interface IGradientPaint extends IPaintBase {
    type: IGradientType;
    from?: IPointData;
    to?: IPointData;
    stretch?: number;
    stops: IColorStop[];
}
interface IColorStop {
    offset: number;
    color: IColor;
}
interface IImagePaint extends IPaintBase {
    type: "image";
    url: string;
    mode?: IImagePaintMode;
    format?: IExportFileType;
    filters?: IImageFilters;
    offset?: IPointData;
    scale?: number | IPointData;
    rotation?: number;
}
interface IImageFilters {
    exposure?: number;
    contrast?: number;
    saturation?: number;
    temperature?: number;
    tint?: number;
    highlights?: number;
    shadows?: number;
}
type IImagePaintMode = 'cover' | 'fit' | 'strench' | 'clip' | 'repeat';
type IStrokeAlign = 'inside' | 'outside' | 'center';
type IStrokeCap = 'none' | 'round' | 'square' | 'arrow-lines' | 'arrow-equilateral';
type IStrokeJoin = 'bevel' | 'round' | 'miter';
type ITextAlign = 'left' | 'center' | 'right' | 'justify';
type IVerticalAlign = 'top' | 'middle' | 'bottom';
type ITextCase = 'upper' | 'lower' | 'title' | 'none' | 'small-caps';
type IFontWeight = IFontWeightNumer | IFontWeightString;
type IFontWeightNumer = 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900;
type IFontWeightString = 'thin' | 'extra-light' | 'light' | 'normal' | 'medium' | 'semi-bold' | 'bold' | 'extra-bold' | 'black';
type ITextDecoration = 'none' | 'under' | 'delete';
interface IVectorPath {
    rule?: IWindingRule;
    data: string | IPathCommandData;
}
interface IShadowEffect {
    x: number;
    y: number;
    blur: number;
    spread?: number;
    color: IColorString | IColor;
    blendMode?: IBlendMode;
    visible?: boolean;
    box?: boolean;
}
interface IBlurEffect {
    blur: number;
    visible?: boolean;
}
interface IGrayscaleEffect {
    grayscale: number;
    visible?: boolean;
}
type IOverflow = 'show' | 'hide';

type ILeafPaintColor = IColorString | CanvasGradient | CanvasPattern;
interface ILeafPaint {
    type?: IPaintType;
    style?: ILeafPaintColor;
    transform?: IMatrixData;
    blendMode?: IBlendMode;
    opacity?: number;
    image?: ILeaferImage;
    loadId?: number;
    patternId?: string;
    data?: ILeafPaintPatternData;
}
interface ILeafPaintPatternData {
    width?: number;
    height?: number;
    scaleX?: number;
    scaleY?: number;
    opacity?: number;
    transform?: IMatrixData;
    mode?: IImagePaintMode;
}
type ILeafFill = ILeafPaint;
interface ILeafStrokePaint extends ILeafPaint {
    strokeAlign?: IStrokeAlign;
    strokeWidth?: number;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: number[];
    miterLimit?: number;
}
interface ILeafShadowEffect {
    x: number;
    y: number;
    blur: number;
    spread?: number;
    color: IColorString;
    blendMode?: IBlendMode;
    box?: boolean;
}

interface ICornerRadiusAttrData {
    cornerRadius: number | number[] | ICornerRadiusString;
    cornerSmoothing: number;
}
interface ICornerRadiusInputData {
    cornerRadius?: number | number[] | ICornerRadiusString;
    cornerSmoothing?: number;
}
interface ICornerRadiusComputedData {
    cornerRadius?: number;
    cornerSmoothing?: number;
}
interface IFillAttrData {
    fill: IPaint | IPaint[] | IPaintString;
}
interface IFillInputData {
    fill?: IPaint | IPaint[] | IPaintString;
}
interface IFillComputedData {
    fill?: IColorString | ILeafPaint[];
}
interface IBorderComputedData {
    borderWidth?: number | number[];
    borderRadius?: number | number[];
}
interface IStrokeAttrData {
    stroke: IPaint | IPaint[] | IPaintString;
    strokeAlign: IStrokeAlign;
    strokeWidth: number | number[] | IStrokeWidthString;
    strokeCap: IStrokeCap;
    strokeJoin: IStrokeJoin;
    dashPattern: number[] | IDashPatternString;
    dashOffset: number;
    miterLimit: number;
}
interface IStrokeInputData {
    stroke?: IPaint | IPaint[] | IPaintString;
    strokeAlign?: IStrokeAlign;
    strokeWidth?: number | number[] | IStrokeWidthString;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: number[] | IDashPatternString;
    dashOffset?: number;
    miterLimit?: number;
}
interface IStrokeComputedData {
    stroke?: IColorString | ILeafStrokePaint[];
    strokeAlign?: IStrokeAlign;
    strokeWidth?: number;
    strokeWidths?: number[];
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: number[];
    dashOffset?: number;
    miterLimit?: number;
}
interface ITextStyleAttrData {
    fontFamily: string;
    fontSize: number;
    fontWeight: IFontWeight;
    italic: boolean;
    textCase: ITextCase;
    textDecoration: ITextDecoration;
    letterSpacing: number | IUnitData;
    lineHeight: number | IUnitData;
    paraIndent: number;
    paraSpacing: number;
    textAlign: ITextAlign;
    verticalAlign: IVerticalAlign;
    textOverflow: IOverflow | string;
}
interface ITextStyleInputData {
    fontFamily?: string;
    fontSize?: number;
    fontWeight?: IFontWeight;
    italic?: boolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: number | IUnitData;
    lineHeight?: number | IUnitData;
    paraIndent?: number;
    paraSpacing?: number;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    textOverflow?: IOverflow | string;
}
interface ITextStyleComputedData {
    fontFamily?: string;
    fontSize?: number;
    fontWeight?: IFontWeight;
    italic?: boolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: number;
    lineHeight?: number;
    paraIndent?: number;
    paraSpacing?: number;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    textOverflow?: IOverflow;
}
interface IEffectAttrData {
    shadow: IShadowEffect | IShadowEffect[] | IShadowString;
    innerShadow: IShadowEffect | IShadowEffect[] | IShadowString;
    blur: number | IBlurEffect;
    backgroundBlur: number | IBlurEffect;
    grayscale: number | IGrayscaleEffect;
}
interface IEffectInputData {
    shadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    innerShadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    blur?: number | IBlurEffect;
    backgroundBlur?: number | IBlurEffect;
    grayscale?: number | IGrayscaleEffect;
}
interface IEffectComputedData {
    shadow?: ILeafShadowEffect[];
    innerShadow?: ILeafShadowEffect[];
    blur?: number;
    backgroundBlur?: number;
    grayscale?: number;
}

interface IExportOptions {
    quality?: number;
    blob?: boolean;
}
interface IExportResult {
    data: IBlob | string | boolean;
}
interface IExportResultFunction {
    (data: IExportResult): void;
}
interface IExportModule {
    export?(leaf: ILeaf, filename: IExportFileType | string, options?: IExportOptions | number | boolean): Promise<IExportResult>;
}

interface ILine extends IUI {
    __: ILineData;
    toPoint: IPointData;
    points: number[];
    curve: boolean | number;
}
interface ILineData extends IUIData {
}
interface ILineInputData extends IUIBaseInputData {
    toPoint?: IPointData;
    points?: number[];
    curve?: boolean | number;
}
interface IRect extends IUI {
    __: IRectData;
}
interface IRectData extends IUIData {
}
interface IRectInputData extends IUIBaseInputData {
}
interface IEllipse extends IUI {
    __: IEllipseData;
    startAngle: number;
    endAngle: number;
    innerRadius: number;
}
interface IEllipseAttrData {
    startAngle?: number;
    endAngle?: number;
    innerRadius?: number;
}
interface IEllipseData extends IEllipseAttrData, IUIData {
}
interface IEllipseInputData extends IEllipseAttrData, IUIBaseInputData {
}
interface IPolygon extends IUI {
    __: IPolygonData;
    sides: number;
    points: number[];
    curve: boolean | number;
}
interface IPolygonAttrData {
    sides?: number;
    points?: number[];
    curve?: boolean | number;
}
interface IPolygonData extends IPolygonAttrData, IUIData {
}
interface IPolygonInputData extends IPolygonAttrData, IUIBaseInputData {
}
interface IStar extends IUI {
    __: IStarData;
    corners: number;
    innerRadius: number;
}
interface IStarAttrData {
    corners?: number;
    innerRadius?: number;
}
interface IStarData extends IStarAttrData, IUIData {
}
interface IStarInputData extends IStarAttrData, IUIBaseInputData {
}
interface IPath extends IUI {
    __: IPathData;
    path: IPathCommandData | IPathString;
    windingRule: IWindingRule;
}
interface IPathData extends IUIData {
    path?: IPathCommandData;
    windingRule?: IWindingRule;
}
interface IPathInputData extends IUIBaseInputData {
    path?: IPathCommandData | IPathString;
    windingRule?: IWindingRule;
}
interface IPen extends IGroup, IPathCreator {
    __: IPenData;
    pathElement: IPath;
    pathStyle: IPathInputData;
    path: IPathCommandData;
    paint(): void;
    clear(): void;
}
interface IPenData extends IGroupData {
}
interface IPenInputData extends IGroupInputData {
}
interface IText extends ITextStyleAttrData, IUI {
    __: ITextData;
    text: string;
}
interface ITextAttrData {
    text?: string;
}
interface ITextData extends ITextAttrData, ITextStyleComputedData, IUIData {
    __baseLine?: number;
    __lineHeight?: number;
    __letterSpacing?: number;
}
interface ITextInputData extends ITextAttrData, ITextStyleInputData, IUIBaseInputData {
}
interface ITextRowData {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    text?: string;
    data?: ITextCharData[];
    words?: ITextWordData[];
    startCharSize?: number;
    endCharSize?: number;
    paraStart?: boolean;
    paraEnd?: boolean;
    isOverflow?: boolean;
}
interface ITextWordData {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    data?: ITextCharData[];
}
interface ITextCharData {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    char?: string;
}
interface ITextDrawData {
    bounds: IBoundsData;
    rows: ITextRowData[];
    paraNumber: number;
    font: string;
    decorationY?: number;
    decorationHeight?: number;
    overflow?: number;
}
interface IImage extends IRect, ILeaferImageConfig {
    __: IImageData;
    url: string;
    ready: boolean;
    image?: ILeaferImage;
}
interface IImageAttrData {
    url?: string;
}
interface IImageData extends IImageAttrData, IRectData {
}
interface IImageInputData extends IImageAttrData, IUIBaseInputData {
}
interface ICanvas extends IRect {
    __: ICanvasData;
    pixelRatio: number;
    smooth: boolean;
    canvas: ILeaferCanvas;
    __updateSize(): void;
}
interface ICanvasAttrData {
    pixelRatio?: number;
    smooth?: boolean;
}
interface ICanvasData extends ICanvasAttrData, IRectData {
}
interface ICanvasInputData extends ICanvasAttrData, IUIBaseInputData {
}
interface ILeaferData extends IGroupData {
    pixelRatio?: number;
}
interface ILeaferInputData extends IGroupInputData {
    pixelRatio?: number;
}
interface IFrame extends IBox {
    __: IFrameData;
}
interface IFrameData extends IBoxData {
}
interface IFrameInputData extends IBoxInputData {
}
interface IBox extends IGroup {
    __: IBoxData;
    overflow: IOverflow;
    __updateRectRenderBounds(): void;
    __renderGroup(canvas: ILeaferCanvas, options: IRenderOptions): void;
}
interface IBoxData extends IGroupData {
    overflow?: IOverflow;
}
interface IBoxInputData extends IGroupInputData {
    overflow?: IOverflow;
}
interface IGroup extends IUI {
    __: IGroupData;
    children: IUI[];
    mask?: IUI;
    add(child: IUI, index?: number): void;
    addAt(child: IUI, index: number): void;
    addAfter(child: IUI, after: IUI): void;
    addBefore(child: IUI, before: IUI): void;
    remove(child?: IUI): void;
    removeAll(): void;
}
interface IGroupData extends IUIData {
}
interface IGroupInputData extends IUIBaseInputData {
}
interface IUI extends IFillAttrData, IStrokeAttrData, ICornerRadiusAttrData, IEffectAttrData, ILeaf {
    __: IUIData;
    parent?: IGroup;
    set(data: IUIInputData): void;
    toJSON(): IUIInputData;
    getPath(curve?: boolean): IPathCommandData;
    getPathString(curve?: boolean): IPathString;
    __drawPathByData(drawer: IPathDrawer, data: IPathCommandData): void;
    __drawAfterFill?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    export(filename: string, options?: IExportOptions | number): Promise<IBlob | string | boolean>;
    clone(): IUI;
}
interface IUIData extends IUIComputedData, ILeafData {
    padding?: number | number[];
    locked?: boolean;
    __isFills?: boolean;
    __isStrokes?: boolean;
    __drawAfterFill?: boolean;
    __isOverflow?: boolean;
    __blendLayer?: boolean;
    __isTranslucentFill?: boolean;
    __isTranslucentStroke?: boolean;
    __useEffect?: boolean;
    path?: IPathCommandData;
    windingRule?: IWindingRule;
    __pathForRender?: IPathCommandData;
    __path2DForRender?: IPath2D;
    __boxStroke?: boolean;
    __font?: string;
    __textDrawData?: ITextDrawData;
}
interface IUIComputedData extends IFillComputedData, IBorderComputedData, IStrokeComputedData, ITextStyleComputedData, ICornerRadiusComputedData, IEffectComputedData, ILeafComputedData {
    padding?: number | number[];
    locked?: boolean;
}
interface IUIBaseInputData extends IFillInputData, IStrokeInputData, ITextStyleInputData, ICornerRadiusInputData, IEffectInputData, ILeafInputData {
    padding?: number | number[];
    locked?: boolean;
    children?: IUIBaseInputData[];
}
type IUITag = 'App' | 'Leafer' | 'Rect' | 'Ellipse' | 'Polygon' | 'Star' | 'Line' | 'Path' | 'Pen' | 'Text' | 'Image' | 'Canvas' | 'Group' | 'Frame' | 'Box';
interface IUIInputData extends IRectInputData, IEllipseInputData, IPolygonInputData, IStarInputData, ILineInputData, IPathInputData, ITextInputData, IImageInputData, IGroupInputData, IFrameInputData, IUIBaseInputData, IObject {
}

type IUIRenderModule = IUIRender & ThisType<IUI>;
interface IUIRender extends ILeafRender {
    __drawAfterFill?(canvas: ILeaferCanvas, options: IRenderOptions): void;
}
type IRectRenderModule = IRectRender & ThisType<IRect>;
interface IRectRender extends IUIRender {
}
type IImageRenderModule = IImageRender & ThisType<IImage>;
interface IImageRender extends IUIRender {
}
type ITextRenderModule = ITextRender & ThisType<IText>;
interface ITextRender extends IUIRender {
}
type IGroupRenderModule = IGroupRender & ThisType<IGroup>;
interface IGroupRender extends IUIRender {
}
type IFrameRenderModule = IFrameRender & ThisType<IFrame>;
interface IFrameRender extends IGroupRender {
}

type IUIBoundsModule = IUIBounds & ThisType<IUI>;
interface IUIBounds extends ILeafBounds {
}

type IUIHitModule = ILeafHit & ThisType<IUI>;

interface ITextConvertModule {
    getDrawData?(content: string, style: ITextData): ITextDrawData;
}

interface IColorConvertModule {
    string?(color: IColor, opacity?: number): string;
}

interface ICachedShape extends ICachedLeaf {
    worldCanvas?: ILeaferCanvas;
    shapeBounds: IBoundsData;
    scaleX: number;
    scaleY: number;
}

interface IPaintModule {
    compute?(attrName: 'fill' | 'stroke', ui: IUI): void;
    fill?(fill: string, ui: IUI, canvas: ILeaferCanvas): void;
    fills?(fills: ILeafPaint[], ui: IUI, canvas: ILeaferCanvas): void;
    fillText?(ui: IUI, canvas: ILeaferCanvas): void;
    stroke?(stroke: string, ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    strokes?(strokes: ILeafPaint[], ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    strokeText?(stroke: string, ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    strokesText?(strokes: ILeafPaint[], ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    drawTextStroke?(ui: IUI, canvas: ILeaferCanvas): void;
    shape?(ui: IUI, current: ILeaferCanvas, renderOptions: IRenderOptions): ICachedShape;
    recycleImage?(attrName: 'fill' | 'stroke', data: IUIData): IBooleanMap;
}

interface IEffectModule {
    shadow?(ui: IUI, current: ILeaferCanvas, shape: ICachedShape, renderOptions: IRenderOptions): void;
    innerShadow?(ui: IUI, current: ILeaferCanvas, shape: ICachedShape, renderOptions: IRenderOptions): void;
    blur?(ui: IUI, current: ILeaferCanvas, origin: ILeaferCanvas, renderOptions: IRenderOptions): void;
    backgroundBlur?(ui: IUI, current: ILeaferCanvas, shape: ICachedShape, renderOptions: IRenderOptions): void;
}

export type { IBlurEffect, IBox, IBoxData, IBoxInputData, ICachedShape, ICanvas, ICanvasData, ICanvasInputData, IColor, IColorConvertModule, IColorStop, ICornerRadiusString, IDashPatternString, IEffectModule, IEllipse, IEllipseData, IEllipseInputData, IExportModule, IExportOptions, IExportResult, IExportResultFunction, IFontWeight, IFrame, IFrameData, IFrameInputData, IFrameRenderModule, IGradientPaint, IGrayscaleEffect, IGroup, IGroupData, IGroupInputData, IGroupRenderModule, IImage, IImageData, IImageInputData, IImagePaint, IImagePaintMode, IImageRenderModule, ILeafFill, ILeafPaint, ILeafPaintColor, ILeafPaintPatternData, ILeafShadowEffect, ILeafStrokePaint, ILeaferData, ILeaferInputData, ILine, ILineData, ILineInputData, IOverflow, IPaint, IPaintModule, IPaintString, IPath, IPathData, IPathInputData, IPen, IPenData, IPenInputData, IPercent, IPolygon, IPolygonData, IPolygonInputData, IRGB, IRGBA, IRect, IRectData, IRectInputData, IRectRenderModule, IShadowEffect, IShadowString, IStar, IStarData, IStarInputData, IColorString as IStringColor, IStrokeAlign, IStrokeCap, IStrokeJoin, IStrokeWidthString, IText, ITextAlign, ITextCase, ITextCharData, ITextConvertModule, ITextData, ITextDecoration, ITextDrawData, ITextInputData, ITextRenderModule, ITextRowData, ITextWordData, IUI, IUIBaseInputData, IUIBoundsModule, IUIData, IUIHitModule, IUIInputData, IUIRenderModule, IUITag, IUnitData, IVectorPath, IVerticalAlign };
