const Platform = {
    imageSuffix: 'leaf'
};

const Creator = {};

const IncrementId = {
    RUNTIME: 'runtime',
    LEAF: 'leaf',
    TASK: 'task',
    CNAVAS: 'canvas',
    IMAGE: 'image',
    types: {},
    create(typeName) {
        const { types } = I$2;
        if (types[typeName]) {
            return types[typeName]++;
        }
        else {
            types[typeName] = 1;
            return 0;
        }
    }
};
const I$2 = IncrementId;

const MathHelper = {
    within(value, min, max) {
        if (value < min)
            value = min;
        if (value > max)
            value = max;
        return value;
    },
    fourNumber(num) {
        let one, two, three, four;
        if (num instanceof Array) {
            switch (num.length) {
                case 4:
                    return num;
                case 2:
                    one = three = num[0];
                    two = four = num[1];
                    break;
                case 3:
                    one = num[0];
                    two = four = num[1];
                    three = num[2];
                    break;
                case 1:
                    num = num[0];
                    break;
                default:
                    num = 0;
            }
        }
        return one === undefined ? [num, num, num, num] : [one, two, three, four];
    },
    formatRotation(rotation, unsign) {
        rotation %= 360;
        if (unsign) {
            if (rotation < 0)
                rotation += 360;
        }
        else {
            if (rotation > 180)
                rotation -= 360;
            if (rotation < -180)
                rotation += 360;
        }
        return rotation;
    },
    getGapRotation(rotation, gap) {
        if (gap > 1) {
            const r = Math.abs(rotation % gap);
            if (r < 1 || r > gap - 1)
                rotation = Math.round(rotation / gap) * gap;
        }
        return rotation;
    },
    formatSkew(skew) {
        return MathHelper.within(skew, -90, 90);
    }
};
const OneRadian = Math.PI / 180;
const PI2 = Math.PI * 2;
const PI_2 = Math.PI / 2;

const { sin: sin$6, cos: cos$6, acos, atan, sqrt: sqrt$3, PI: PI$3 } = Math;
const tempPoint$1 = {};
function get$5() {
    return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
}
const MatrixHelper = {
    defaultMatrix: get$5(),
    tempMatrix: {},
    set(t, a = 1, b = 0, c = 0, d = 1, e = 0, f = 0) {
        t.a = a;
        t.b = b;
        t.c = c;
        t.d = d;
        t.e = e;
        t.f = f;
    },
    get: get$5,
    copy(t, matrix) {
        t.a = matrix.a;
        t.b = matrix.b;
        t.c = matrix.c;
        t.d = matrix.d;
        t.e = matrix.e;
        t.f = matrix.f;
    },
    translate(t, x, y) {
        t.e += x;
        t.f += y;
    },
    translateInner(t, x, y) {
        t.e += t.a * x + t.c * y;
        t.f += t.b * x + t.d * y;
    },
    scale(t, x, y = x) {
        t.a *= x;
        t.b *= x;
        t.c *= y;
        t.d *= y;
    },
    scaleOfOuter(t, origin, x, y = x) {
        M$5.toInnerPoint(t, origin, tempPoint$1);
        M$5.scaleOfInner(t, tempPoint$1, x, y);
    },
    scaleOfInner(t, origin, x, y = x) {
        M$5.translateInner(t, origin.x, origin.y);
        M$5.scale(t, x, y);
        M$5.translateInner(t, -origin.x, -origin.y);
    },
    rotate(t, angle) {
        angle *= OneRadian;
        const cosR = cos$6(angle);
        const sinR = sin$6(angle);
        const { a, b, c, d } = t;
        t.a = (a * cosR) - (b * sinR);
        t.b = (a * sinR) + (b * cosR);
        t.c = (c * cosR) - (d * sinR);
        t.d = (c * sinR) + (d * cosR);
    },
    rotateOfOuter(t, origin, angle) {
        M$5.toInnerPoint(t, origin, tempPoint$1);
        M$5.rotateOfInner(t, tempPoint$1, angle);
    },
    rotateOfInner(t, origin, angle) {
        M$5.translateInner(t, origin.x, origin.y);
        M$5.rotate(t, angle);
        M$5.translateInner(t, -origin.x, -origin.y);
    },
    skew(t, x, y) {
        const { a, b, c, d } = t;
        if (y) {
            y *= OneRadian;
            t.a = a + c * y;
            t.b = b + d * y;
        }
        if (x) {
            x *= OneRadian;
            t.c = c + a * x;
            t.d = d + b * x;
        }
    },
    skewOfOuter(t, origin, x, y) {
        M$5.toInnerPoint(t, origin, tempPoint$1);
        M$5.skewOfInner(t, tempPoint$1, x, y);
    },
    skewOfInner(t, origin, x, y) {
        M$5.translateInner(t, origin.x, origin.y);
        M$5.skew(t, x, y);
        M$5.translateInner(t, -origin.x, -origin.y);
    },
    multiply(t, matrix) {
        const { a, b, c, d, e, f } = t;
        t.a = matrix.a * a + matrix.b * c;
        t.b = matrix.a * b + matrix.b * d;
        t.c = matrix.c * a + matrix.d * c;
        t.d = matrix.c * b + matrix.d * d;
        t.e = matrix.e * a + matrix.f * c + e;
        t.f = matrix.e * b + matrix.f * d + f;
    },
    preMultiply(t, matrix) {
        const { a, b, c, d, e, f } = t;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            t.a = (a * matrix.a) + (b * matrix.c);
            t.b = (a * matrix.b) + (b * matrix.d);
            t.c = (c * matrix.a) + (d * matrix.c);
            t.d = (c * matrix.b) + (d * matrix.d);
        }
        t.e = (e * matrix.a) + (f * matrix.c) + matrix.e;
        t.f = (e * matrix.b) + (f * matrix.d) + matrix.f;
    },
    divide(t, matrix) {
        M$5.preMultiply(t, M$5.tempInvert(matrix));
    },
    tempInvert(t) {
        const { tempMatrix: temp } = M$5;
        M$5.copy(temp, t);
        M$5.invert(temp);
        return temp;
    },
    invert(t) {
        const { a, b, c, d, e, f } = t;
        const s = 1 / (a * d - b * c);
        t.a = d * s;
        t.b = -b * s;
        t.c = -c * s;
        t.d = a * s;
        t.e = -(e * d - f * c) * s;
        t.f = -(f * a - e * b) * s;
    },
    toOuterPoint(t, inner, to, distance) {
        const { x, y } = inner;
        to || (to = inner);
        to.x = (x * t.a) + (y * t.c);
        to.y = (x * t.b) + (y * t.d);
        if (!distance) {
            to.x += t.e;
            to.y += t.f;
        }
    },
    toInnerPoint(t, outer, to, distance) {
        const { x, y } = outer;
        const { a, b, c, d } = t;
        const s = 1 / (a * d - b * c);
        to || (to = outer);
        to.x = (x * d - y * c) * s;
        to.y = (y * a - x * b) * s;
        if (!distance) {
            const { e, f } = t;
            to.x -= (e * d - f * c) * s;
            to.y -= (f * a - e * b) * s;
        }
    },
    decompose(t) {
        const { a, b, c, d } = t;
        let scaleX = a, scaleY = d, rotation = 0, skewX = 0, skewY = 0;
        if (b || c) {
            const s = a * d - b * c;
            const k = a * c + b * d;
            if (b) {
                const ab = a * a + b * b;
                scaleX = sqrt$3(ab);
                scaleY = s / scaleX;
                const r = a / scaleX;
                rotation = b > 0 ? acos(r) : -acos(r);
                skewX = atan(k / ab) / OneRadian;
            }
            else {
                const cd = c * c + d * d;
                scaleY = sqrt$3(cd);
                scaleX = s / scaleY;
                const r = c / scaleY;
                rotation = PI$3 / 2 - (d > 0 ? acos(-r) : -acos(r));
                skewY = atan(k / cd) / OneRadian;
            }
            rotation /= OneRadian;
        }
        return { x: t.e, y: t.f, scaleX, scaleY, rotation, skewX, skewY };
    },
    reset(t) {
        M$5.set(t);
    }
};
const M$5 = MatrixHelper;

const { toInnerPoint: toInnerPoint$2, toOuterPoint: toOuterPoint$2 } = MatrixHelper;
const { sin: sin$5, cos: cos$5, abs: abs$1, sqrt: sqrt$2, atan2: atan2$2 } = Math;
const PointHelper = {
    defaultPoint: { x: 0, y: 0 },
    tempPoint: {},
    tempRadiusPoint: {},
    set(t, x = 0, y = 0) {
        t.x = x;
        t.y = y;
    },
    setRadius(t, x, y) {
        t.radiusX = x;
        t.radiusY = y === undefined ? x : y;
    },
    copy(t, point) {
        t.x = point.x;
        t.y = point.y;
    },
    move(t, x, y) {
        t.x += x;
        t.y += y;
    },
    rotate(t, rotation, center) {
        if (!center)
            center = P$5.defaultPoint;
        const cosR = cos$5(rotation * OneRadian);
        const sinR = sin$5(rotation * OneRadian);
        const rx = t.x - center.x;
        const ry = t.y - center.y;
        t.x = center.x + rx * cosR - ry * sinR;
        t.y = center.y + rx * sinR + ry * cosR;
    },
    tempToInnerOf(t, matrix) {
        const { tempPoint: temp } = P$5;
        P$5.copy(temp, t);
        toInnerPoint$2(matrix, temp, temp);
        return temp;
    },
    tempToOuterOf(t, matrix) {
        const { tempPoint: temp } = P$5;
        P$5.copy(temp, t);
        toOuterPoint$2(matrix, temp, temp);
        return temp;
    },
    tempToInnerRadiusPointOf(t, matrix) {
        const { tempRadiusPoint: temp } = P$5;
        P$5.copy(temp, t);
        P$5.toInnerRadiusPointOf(t, matrix, temp);
        return temp;
    },
    toInnerRadiusPointOf(t, matrix, to) {
        to || (to = t);
        toInnerPoint$2(matrix, t, to);
        to.radiusX = Math.abs(t.radiusX / matrix.scaleX);
        to.radiusY = Math.abs(t.radiusY / matrix.scaleY);
    },
    toInnerOf(t, matrix, to) {
        toInnerPoint$2(matrix, t, to);
    },
    toOuterOf(t, matrix, to) {
        toOuterPoint$2(matrix, t, to);
    },
    getCenter(t, to) {
        return { x: t.x + (to.x - t.x) / 2, y: t.y + (to.y - t.y) / 2 };
    },
    getDistance(t, point) {
        const x = abs$1(point.x - t.x);
        const y = abs$1(point.y - t.y);
        return sqrt$2(x * x + y * y);
    },
    getAngle(t, to) {
        return P$5.getAtan2(t, to) / OneRadian;
    },
    getChangeAngle(t, orign, to, toOrigin) {
        if (!toOrigin)
            toOrigin = orign;
        let fromAngle = P$5.getAngle(t, orign);
        let toAngle = P$5.getAngle(to, toOrigin);
        const angle = toAngle - fromAngle;
        return angle < -180 ? angle + 360 : angle;
    },
    getAtan2(t, to) {
        return atan2$2(to.y - t.y, to.x - t.x);
    },
    getDistancePoint(t, to, distance) {
        const r = P$5.getAtan2(t, to);
        return { x: t.x + cos$5(r) * distance, y: t.y + sin$5(r) * distance };
    },
    reset(t) {
        P$5.reset(t);
    }
};
const P$5 = PointHelper;

class Point {
    constructor(x, y) {
        typeof x === 'object' ? PointHelper.copy(this, x) : PointHelper.set(this, x, y);
    }
    set(x, y) {
        PointHelper.set(this, x, y);
    }
    copy(point) {
        PointHelper.copy(this, point);
        return this;
    }
    clone() {
        return new Point(this);
    }
    rotate(angle, center) {
        PointHelper.rotate(this, angle, center);
        return this;
    }
    toInnerOf(matrix, to) {
        PointHelper.toInnerOf(this, matrix, to);
        return this;
    }
    toOuterOf(matrix, to) {
        PointHelper.toOuterOf(this, matrix, to);
        return this;
    }
    getCenter(to) {
        return PointHelper.getCenter(this, to);
    }
    getDistance(to) {
        return PointHelper.getDistance(this, to);
    }
    getAngle(to) {
        return PointHelper.getAngle(this, to);
    }
    getAtan2(to) {
        return PointHelper.getAtan2(this, to);
    }
    reset() {
        PointHelper.reset(this);
    }
}

class Matrix {
    constructor(a, b, c, d, e, f) {
        typeof a === 'object' ? MatrixHelper.copy(this, a) : MatrixHelper.set(this, a, b, c, d, e, f);
    }
    set(a, b, c, d, e, f) {
        MatrixHelper.set(this, a, b, c, d, e, f);
    }
    copy(matrix) {
        MatrixHelper.copy(this, matrix);
        return this;
    }
    clone() {
        return new Matrix(this);
    }
    translate(x, y) {
        MatrixHelper.translate(this, x, y);
        return this;
    }
    translateInner(x, y) {
        MatrixHelper.translateInner(this, x, y);
        return this;
    }
    scale(x, y) {
        MatrixHelper.scale(this, x, y);
        return this;
    }
    scaleOfOuter(origin, x, y) {
        MatrixHelper.scaleOfOuter(this, origin, x, y);
        return this;
    }
    scaleOfInner(origin, x, y) {
        MatrixHelper.scaleOfInner(this, origin, x, y);
        return this;
    }
    rotate(angle) {
        MatrixHelper.rotate(this, angle);
        return this;
    }
    rotateOfOuter(origin, angle) {
        MatrixHelper.rotateOfOuter(this, origin, angle);
        return this;
    }
    rotateOfInner(origin, angle) {
        MatrixHelper.rotateOfInner(this, origin, angle);
        return this;
    }
    skew(x, y) {
        MatrixHelper.skew(this, x, y);
        return this;
    }
    skewOfOuter(origin, x, y) {
        MatrixHelper.skewOfOuter(this, origin, x, y);
        return this;
    }
    skewOfInner(origin, x, y) {
        MatrixHelper.skewOfInner(this, origin, x, y);
        return this;
    }
    multiply(matrix) {
        MatrixHelper.multiply(this, matrix);
        return this;
    }
    preMultiply(matrix) {
        MatrixHelper.preMultiply(this, matrix);
        return this;
    }
    divide(matrix) {
        MatrixHelper.divide(this, matrix);
        return this;
    }
    invert() {
        MatrixHelper.invert(this);
        return this;
    }
    toOuterPoint(inner, to, distance) {
        MatrixHelper.toOuterPoint(this, inner, to, distance);
    }
    toInnerPoint(outer, to, distance) {
        MatrixHelper.toInnerPoint(this, outer, to, distance);
    }
    decompose() {
        return MatrixHelper.decompose(this);
    }
    reset() {
        MatrixHelper.reset(this);
    }
}

const TwoPointBoundsHelper = {
    tempPointBounds: {},
    setPoint(t, minX, minY) {
        t.minX = t.maxX = minX;
        t.minY = t.maxY = minY;
    },
    addPoint(t, x, y) {
        t.minX = x < t.minX ? x : t.minX;
        t.minY = y < t.minY ? y : t.minY;
        t.maxX = x > t.maxX ? x : t.maxX;
        t.maxY = y > t.maxY ? y : t.maxY;
    },
    addBounds(t, x, y, width, height) {
        addPoint$3(t, x, y);
        addPoint$3(t, x + width, y + height);
    },
    copy(t, pb) {
        t.minX = pb.minX;
        t.minY = pb.minY;
        t.maxX = pb.maxX;
        t.maxY = pb.maxY;
    },
    add(t, pb) {
        t.minX = pb.minX < t.minX ? pb.minX : t.minX;
        t.minY = pb.minY < t.minY ? pb.minY : t.minY;
        t.maxX = pb.maxX > t.maxX ? pb.maxX : t.maxX;
        t.maxY = pb.maxY > t.maxY ? pb.maxY : t.maxY;
    },
    toBounds(t, setBounds) {
        setBounds.x = t.minX;
        setBounds.y = t.minY;
        setBounds.width = t.maxX - t.minX;
        setBounds.height = t.maxY - t.minY;
    }
};
const { addPoint: addPoint$3 } = TwoPointBoundsHelper;

const { tempPointBounds: tempPointBounds$1, setPoint: setPoint$2, addPoint: addPoint$2, toBounds: toBounds$4 } = TwoPointBoundsHelper;
const { toOuterPoint: toOuterPoint$1 } = MatrixHelper;
let right, bottom, boundsRight, boundsBottom;
const point = {};
const toPoint = {};
const BoundsHelper = {
    tempBounds: {},
    set(t, x = 0, y = 0, width = 0, height = 0) {
        t.x = x;
        t.y = y;
        t.width = width;
        t.height = height;
    },
    copy(t, bounds) {
        t.x = bounds.x;
        t.y = bounds.y;
        t.width = bounds.width;
        t.height = bounds.height;
    },
    copyAndSpread(t, bounds, spreadX, spreadY) {
        if (!spreadY)
            spreadY = spreadX;
        B.set(t, bounds.x - spreadX, bounds.y - spreadY, bounds.width + spreadX * 2, bounds.height + spreadY * 2);
    },
    right(t) {
        return t.x + t.width;
    },
    bottom(t) {
        return t.y + t.height;
    },
    move(t, x, y) {
        t.x += x;
        t.y += y;
    },
    getByMove(t, x, y) {
        t = Object.assign({}, t);
        B.move(t, x, y);
        return t;
    },
    toOffsetOutBounds(t, to, parent) {
        if (!to) {
            to = t;
        }
        else {
            copy$7(to, t);
        }
        if (parent) {
            to.offsetX = -(B.right(parent) - t.x);
            to.offsetY = -(B.bottom(parent) - t.y);
        }
        else {
            to.offsetX = t.x + t.width;
            to.offsetY = t.y + t.height;
        }
        B.move(to, -to.offsetX, -to.offsetY);
    },
    scale(t, scaleX, scaleY) {
        if (!scaleY)
            scaleY = scaleX;
        if (t.x)
            t.x *= scaleX;
        if (t.y)
            t.y *= scaleY;
        t.width *= scaleX;
        t.height *= scaleY;
    },
    tempToOuterOf(t, matrix) {
        B.copy(B.tempBounds, t);
        B.toOuterOf(B.tempBounds, matrix);
        return B.tempBounds;
    },
    getOuterOf(t, matrix) {
        t = Object.assign({}, t);
        B.toOuterOf(t, matrix);
        return t;
    },
    toOuterOf(t, matrix, to) {
        to || (to = t);
        if (matrix.b === 0 && matrix.c === 0) {
            const { a, d } = matrix;
            if (a > 0) {
                to.width = t.width * a;
                to.x = matrix.e + t.x * a;
            }
            else {
                to.width = t.width * -a;
                to.x = matrix.e + t.x * a - to.width;
            }
            if (d > 0) {
                to.height = t.height * d;
                to.y = matrix.f + t.y * d;
            }
            else {
                to.height = t.height * -d;
                to.y = matrix.f + t.y * d - to.height;
            }
        }
        else {
            point.x = t.x;
            point.y = t.y;
            toOuterPoint$1(matrix, point, toPoint);
            setPoint$2(tempPointBounds$1, toPoint.x, toPoint.y);
            point.x = t.x + t.width;
            toOuterPoint$1(matrix, point, toPoint);
            addPoint$2(tempPointBounds$1, toPoint.x, toPoint.y);
            point.y = t.y + t.height;
            toOuterPoint$1(matrix, point, toPoint);
            addPoint$2(tempPointBounds$1, toPoint.x, toPoint.y);
            point.x = t.x;
            toOuterPoint$1(matrix, point, toPoint);
            addPoint$2(tempPointBounds$1, toPoint.x, toPoint.y);
            toBounds$4(tempPointBounds$1, to);
        }
    },
    getFitMatrix(t, put) {
        const scale = Math.min(1, Math.min(t.width / put.width, t.height / put.height));
        return new Matrix(scale, 0, 0, scale, -Math.ceil(put.x * scale), -Math.ceil(put.y * scale));
    },
    getSpread(t, spreadX, spreadY) {
        const n = {};
        B.copyAndSpread(n, t, spreadX, spreadY);
        return n;
    },
    spread(t, spreadX, spreadY) {
        B.copyAndSpread(t, t, spreadX, spreadY);
    },
    ceil(t) {
        t.x = Math.floor(t.x);
        t.y = Math.floor(t.y);
        t.width = Math.ceil(t.width);
        t.height = Math.ceil(t.height);
    },
    unsign(t) {
        if (t.width < 0) {
            t.x += t.width;
            t.width = -t.width;
        }
        if (t.height < 0) {
            t.y += t.height;
            t.height = -t.height;
        }
    },
    add(t, bounds) {
        right = t.x + t.width;
        bottom = t.y + t.height;
        boundsRight = bounds.x + bounds.width;
        boundsBottom = bounds.y + bounds.height;
        right = right > boundsRight ? right : boundsRight;
        bottom = bottom > boundsBottom ? bottom : boundsBottom;
        t.x = t.x < bounds.x ? t.x : bounds.x;
        t.y = t.y < bounds.y ? t.y : bounds.y;
        t.width = right - t.x;
        t.height = bottom - t.y;
    },
    addList(t, list) {
        B.setByListWithHandle(t, list, undefined, true);
    },
    setByList(t, list, addMode = false) {
        B.setByListWithHandle(t, list, undefined, addMode);
    },
    addListWithHandle(t, list, boundsDataHandle) {
        B.setByListWithHandle(t, list, boundsDataHandle, true);
    },
    setByListWithHandle(t, list, boundsDataHandle, addMode = false) {
        let bounds, first = true;
        for (let i = 0, len = list.length; i < len; i++) {
            bounds = boundsDataHandle ? boundsDataHandle(list[i]) : list[i];
            if (bounds && (bounds.width || bounds.height)) {
                if (first) {
                    first = false;
                    if (!addMode)
                        copy$7(t, bounds);
                }
                else {
                    add$2(t, bounds);
                }
            }
        }
        if (first)
            B.reset(t);
    },
    setByPoints(t, points) {
        points.forEach((point, index) => {
            index === 0 ? setPoint$2(tempPointBounds$1, point.x, point.y) : addPoint$2(tempPointBounds$1, point.x, point.y);
        });
        toBounds$4(tempPointBounds$1, t);
    },
    hitRadiusPoint(t, point, pointMatrix) {
        if (pointMatrix)
            point = PointHelper.tempToInnerRadiusPointOf(point, pointMatrix);
        return (point.x >= t.x - point.radiusX && point.x <= t.x + t.width + point.radiusX) && (point.y >= t.y - point.radiusY && point.y <= t.y + t.height + point.radiusY);
    },
    hitPoint(t, point, pointMatrix) {
        if (pointMatrix)
            point = PointHelper.tempToInnerOf(point, pointMatrix);
        return (point.x >= t.x && point.x <= t.x + t.width) && (point.y >= t.y && point.y <= t.y + t.height);
    },
    hit(t, other, otherMatrix) {
        if (otherMatrix)
            other = B.tempToOuterOf(other, otherMatrix);
        return !((t.y + t.height < other.y) || (other.y + other.height < t.y) || (t.x + t.width < other.x) || (other.x + other.width < t.x));
    },
    includes(t, other, otherMatrix) {
        if (otherMatrix)
            other = B.tempToOuterOf(other, otherMatrix);
        return (t.x <= other.x) && (t.y <= other.y) && (t.x + t.width >= other.x + other.width) && (t.y + t.height >= other.y + other.height);
    },
    getIntersectData(t, other, otherMatrix) {
        if (otherMatrix)
            other = B.tempToOuterOf(other, otherMatrix);
        let { x, y, width, height } = other;
        right = x + width;
        bottom = y + height;
        boundsRight = t.x + t.width;
        boundsBottom = t.y + t.height;
        x = x > t.x ? x : t.x;
        y = y > t.y ? y : t.y;
        right = right < boundsRight ? right : boundsRight;
        bottom = bottom < boundsBottom ? bottom : boundsBottom;
        width = right - x;
        height = bottom - y;
        return { x, y, width, height };
    },
    intersect(t, other, otherMatrix) {
        B.copy(t, B.getIntersectData(t, other, otherMatrix));
    },
    isSame(t, bounds) {
        return t.x === bounds.x && t.y === bounds.y && t.width === bounds.width && t.height === bounds.height;
    },
    isEmpty(t) {
        return t.x === 0 && t.y === 0 && t.width === 0 && t.height === 0;
    },
    reset(t) {
        B.set(t);
    }
};
const B = BoundsHelper;
const { add: add$2, copy: copy$7 } = B;

class Bounds {
    constructor(x, y, width, height) {
        typeof x === 'object' ? BoundsHelper.copy(this, x) : BoundsHelper.set(this, x, y, width, height);
    }
    set(x, y, width, height) {
        BoundsHelper.set(this, x, y, width, height);
    }
    copy(bounds) {
        BoundsHelper.copy(this, bounds);
        return this;
    }
    clone() {
        return new Bounds(this);
    }
    scale(scaleX, scaleY) {
        BoundsHelper.scale(this, scaleX, scaleY);
        return this;
    }
    toOuterOf(matrix, to) {
        BoundsHelper.toOuterOf(this, matrix, to);
        return this;
    }
    getFitMatrix(put) {
        return BoundsHelper.getFitMatrix(this, put);
    }
    spread(size) {
        BoundsHelper.spread(this, size);
        return this;
    }
    ceil() {
        BoundsHelper.ceil(this);
        return this;
    }
    unsign() {
        BoundsHelper.unsign(this);
        return this;
    }
    add(bounds) {
        BoundsHelper.add(this, bounds);
        return this;
    }
    addList(boundsList) {
        BoundsHelper.setByList(this, boundsList, true);
        return this;
    }
    setByList(boundsList, addMode) {
        BoundsHelper.setByList(this, boundsList, addMode);
        return this;
    }
    addListWithHandle(list, boundsDataHandle) {
        BoundsHelper.setByListWithHandle(this, list, boundsDataHandle, true);
        return this;
    }
    setByListWithHandle(list, boundsDataHandle, addMode) {
        BoundsHelper.setByListWithHandle(this, list, boundsDataHandle, addMode);
        return this;
    }
    setByPoints(points) {
        BoundsHelper.setByPoints(this, points);
        return this;
    }
    hitPoint(point, pointMatrix) {
        return BoundsHelper.hitPoint(this, point, pointMatrix);
    }
    hitRadiusPoint(point, pointMatrix) {
        return BoundsHelper.hitRadiusPoint(this, point, pointMatrix);
    }
    hit(bounds, boundsMatrix) {
        return BoundsHelper.hit(this, bounds, boundsMatrix);
    }
    includes(bounds, boundsMatrix) {
        return BoundsHelper.includes(this, bounds, boundsMatrix);
    }
    intersect(bounds, boundsMatrix) {
        BoundsHelper.intersect(this, bounds, boundsMatrix);
        return this;
    }
    getIntersect(bounds, boundsMatrix) {
        return new Bounds(BoundsHelper.getIntersectData(this, bounds, boundsMatrix));
    }
    isSame(bounds) {
        return BoundsHelper.isSame(this, bounds);
    }
    isEmpty() {
        return BoundsHelper.isEmpty(this);
    }
    reset() {
        BoundsHelper.reset(this);
    }
}

class AutoBounds {
    constructor(top, right, bottom, left, width, height) {
        typeof top === 'object' ? this.copy(top) : this.set(top, right, bottom, left, width, height);
    }
    set(top = 0, right = 0, bottom = 0, left = 0, width = 0, height = 0) {
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
        this.width = width;
        this.height = height;
    }
    copy(autoSize) {
        const { top, right, bottom, left, width, height } = autoSize;
        this.set(top, right, bottom, left, width, height);
    }
    getBoundsFrom(parent) {
        const { top, right, bottom, left, width, height } = this;
        return new Bounds(left, top, width ? width : parent.width - left - right, height ? height : parent.height - top - bottom);
    }
}

class TwoPointBounds {
    constructor(x, y) {
        TwoPointBoundsHelper.setPoint(this, x, y);
    }
    addPoint(x, y) {
        TwoPointBoundsHelper.addPoint(this, x, y);
    }
    addBounds(x, y, width, height) {
        TwoPointBoundsHelper.addBounds(this, x, y, width, height);
    }
    add(pb) {
        TwoPointBoundsHelper.add(this, pb);
    }
}

const StringNumberMap = {
    '0': 1,
    '1': 1,
    '2': 1,
    '3': 1,
    '4': 1,
    '5': 1,
    '6': 1,
    '7': 1,
    '8': 1,
    '9': 1,
    '.': 1,
    'e': 1,
    'E': 1
};

class Debug {
    constructor(name) {
        this.repeatMap = {};
        this.name = name;
    }
    static get(name) {
        return new Debug(name);
    }
    static set filter(name) {
        if (!name)
            name = [];
        else if (typeof name === 'string')
            name = [name];
        this.filterList = name;
    }
    static set exclude(name) {
        if (!name)
            name = [];
        else if (typeof name === 'string')
            name = [name];
        this.excludeList = name;
    }
    log(...messages) {
        if (D$4.enable) {
            if (D$4.filterList.length && D$4.filterList.every(name => name !== this.name))
                return;
            if (D$4.excludeList.length && D$4.excludeList.some(name => name === this.name))
                return;
            console.log('%c' + this.name, 'color:#21ae62', ...messages);
        }
    }
    warn(...messages) {
        if (D$4.enable)
            console.warn(this.name, ...messages);
    }
    repeat(name, ...messages) {
        if (!this.repeatMap[name]) {
            this.warn('repeat:' + name, ...messages);
            this.repeatMap[name] = true;
        }
    }
    error(...messages) {
        try {
            throw new Error();
        }
        catch (e) {
            console.error(this.name, ...messages, e);
        }
    }
}
Debug.filterList = [];
Debug.excludeList = [];
const D$4 = Debug;

const debug$f = Debug.get('RunTime');
class Run {
    static start(name, microsecond) {
        const id = IncrementId.create(IncrementId.RUNTIME);
        R.currentId = R.idMap[id] = microsecond ? performance.now() : Date.now();
        R.currentName = R.nameMap[id] = name;
        R.nameToIdMap[name] = id;
        return id;
    }
    static end(id, microsecond) {
        const time = R.idMap[id];
        const name = R.nameMap[id];
        R.idMap[id] = R.nameMap[id] = R.nameToIdMap[name] = undefined;
        if (microsecond) {
            debug$f.log(name, performance.now() - time, 'µs');
        }
        else {
            debug$f.log(name, Date.now() - time, 'ms');
        }
    }
    static endOfName(name, microsecond) {
        const id = R.nameToIdMap[name];
        if (id !== undefined)
            R.end(id, microsecond);
    }
}
Run.idMap = {};
Run.nameMap = {};
Run.nameToIdMap = {};
const R = Run;

const debug$e = Debug.get('UICreator');
const UICreator = {
    list: {},
    register(UI) {
        const { __tag: tag } = UI.prototype;
        if (list$2[tag]) {
            debug$e.repeat(tag);
        }
        else {
            list$2[tag] = UI;
        }
    },
    get(tag, data, x, y, width, height) {
        const ui = new list$2[tag](data);
        if (x !== undefined) {
            ui.x = x;
            if (y)
                ui.y = y;
            if (width)
                ui.width = width;
            if (height)
                ui.height = height;
        }
        return ui;
    }
};
const { list: list$2 } = UICreator;

const debug$d = Debug.get('EventCreator');
const EventCreator = {
    nameList: {},
    register(Event) {
        let name;
        Object.keys(Event).forEach(key => {
            name = Event[key];
            if (typeof name === 'string')
                nameList[name] ? debug$d.repeat(name) : nameList[name] = Event;
        });
    },
    changeName(oldName, newName) {
        const Event = nameList[oldName];
        if (Event) {
            const constName = Object.keys(Event).find(key => Event[key] === oldName);
            if (constName) {
                Event[constName] = newName;
                nameList[newName] = Event;
            }
        }
    },
    has(type) {
        return !!this.nameList[type];
    },
    get(type, ...params) {
        return new nameList[type](...params);
    }
};
const { nameList } = EventCreator;

class CanvasManager {
    constructor() {
        this.list = [];
    }
    add(canvas) {
        canvas.manager = this;
        this.list.push(canvas);
    }
    get(size) {
        let old;
        const { list } = this;
        for (let i = 0, len = list.length; i < len; i++) {
            old = list[i];
            if (old.recycled && old.isSameSize(size)) {
                old.recycled = false;
                old.manager || (old.manager = this);
                return old;
            }
        }
        const canvas = Creator.canvas(size);
        this.add(canvas);
        return canvas;
    }
    recycle(old) {
        if (!old.recycled) {
            old.clear();
            old.recycled = true;
        }
    }
    clearRecycled() {
        let canvas;
        const filter = [];
        for (let i = 0, len = this.list.length; i < len; i++) {
            canvas = this.list[i];
            canvas.recycled ? canvas.destroy() : filter.push(canvas);
        }
        this.list = filter;
    }
    clear() {
        this.list.forEach(item => { item.destroy(); });
        this.list.length = 0;
    }
    destroy() {
        this.clear();
    }
}

class LeafList {
    get length() { return this.list.length; }
    constructor(item) {
        this.reset();
        if (item)
            item instanceof Array ? this.pushList(item) : this.push(item);
    }
    has(leaf) {
        return leaf && this.keys[leaf.innerId] !== undefined;
    }
    indexAt(index) {
        return this.list[index];
    }
    indexOf(leaf) {
        const index = this.keys[leaf.innerId];
        return index === undefined ? -1 : index;
    }
    pushList(list) {
        list.forEach(leaf => { this.push(leaf); });
    }
    unshift(leaf) {
        const { keys } = this;
        if (keys[leaf.innerId] === undefined) {
            this.list.unshift(leaf);
            Object.keys(keys).forEach(innerId => {
                if (keys[innerId] !== undefined)
                    keys[innerId]++;
            });
            keys[leaf.innerId] = 0;
        }
    }
    push(leaf) {
        const { list, keys } = this;
        if (keys[leaf.innerId] === undefined) {
            list.push(leaf);
            keys[leaf.innerId] = list.length - 1;
        }
    }
    sort(reverse) {
        const { list } = this;
        if (reverse) {
            list.sort((a, b) => b.__level - a.__level);
        }
        else {
            list.sort((a, b) => a.__level - b.__level);
        }
    }
    remove(leaf) {
        const { list } = this;
        let findIndex;
        for (let i = 0, len = list.length; i < len; i++) {
            if (findIndex !== undefined) {
                this.keys[list[i].innerId] = i - 1;
            }
            else if (list[i].innerId === leaf.innerId) {
                findIndex = i;
                delete this.keys[leaf.innerId];
            }
        }
        if (findIndex !== undefined)
            list.splice(findIndex, 1);
    }
    forEach(itemCallback) {
        this.list.forEach(itemCallback);
    }
    clone() {
        const list = new LeafList();
        this.list.forEach(item => { list.push(item); });
        return list;
    }
    reset() {
        this.list = [];
        this.keys = {};
    }
    destroy() {
        this.list = null;
    }
}

class LeafLevelList {
    get length() { return this._length; }
    constructor(item) {
        this._length = 0;
        this.reset();
        if (item)
            item instanceof Array ? this.pushList(item) : this.push(item);
    }
    has(leaf) {
        return this.keys[leaf.innerId] !== undefined;
    }
    without(leaf) {
        return this.keys[leaf.innerId] === undefined;
    }
    sort(reverse) {
        const { levels } = this;
        if (reverse) {
            levels.sort((a, b) => b - a);
        }
        else {
            levels.sort((a, b) => a - b);
        }
    }
    pushList(list) {
        list.forEach(leaf => { this.push(leaf); });
    }
    push(leaf) {
        const { keys, levelMap } = this;
        if (!keys[leaf.innerId]) {
            keys[leaf.innerId] = 1;
            if (!levelMap[leaf.__level]) {
                levelMap[leaf.__level] = [leaf];
                this.levels.push(leaf.__level);
            }
            else {
                levelMap[leaf.__level].push(leaf);
            }
            this._length++;
        }
    }
    forEach(itemCallback) {
        let list;
        this.levels.forEach(level => {
            list = this.levelMap[level];
            for (let i = 0, len = list.length; i < len; i++) {
                itemCallback(list[i]);
            }
        });
    }
    reset() {
        this.levelMap = {};
        this.keys = {};
        this.levels = [];
        this._length = 0;
    }
    destroy() {
        this.levelMap = null;
    }
}

class HitCanvasManager extends CanvasManager {
    constructor() {
        super(...arguments);
        this.pathTypeList = new LeafList();
        this.imageTypeList = new LeafList();
    }
    getImageType(leaf, size) {
        this.imageTypeList.push(leaf);
        return Creator.hitCanvas(size);
    }
    getPathType(leaf) {
        this.pathTypeList.push(leaf);
        return Creator.hitCanvas();
    }
    clearImageType() {
        this.__clearLeafList(this.imageTypeList);
    }
    clearPathType() {
        this.__clearLeafList(this.pathTypeList);
    }
    __clearLeafList(leafList) {
        if (leafList.length) {
            leafList.forEach(leaf => {
                if (leaf.__hitCanvas) {
                    leaf.__hitCanvas.destroy();
                    leaf.__hitCanvas = null;
                }
            });
            leafList.reset();
        }
    }
    clear() {
        this.clearPathType();
        this.clearImageType();
    }
}

const DataHelper = {
    default(t, defaultData) {
        assign(defaultData, t);
        assign(t, defaultData);
        return t;
    },
    assign(t, merge) {
        let value;
        Object.keys(merge).forEach(key => {
            var _a;
            value = merge[key];
            if ((value === null || value === void 0 ? void 0 : value.constructor) === Object) {
                (((_a = t[key]) === null || _a === void 0 ? void 0 : _a.constructor) === Object) ? assign(t[key], merge[key]) : t[key] = merge[key];
            }
            else {
                t[key] = merge[key];
            }
        });
    },
    copyAttrs(t, from, include) {
        include.forEach(key => {
            if (from[key] !== undefined)
                t[key] = from[key];
        });
        return t;
    },
    clone(data) {
        return JSON.parse(JSON.stringify(data));
    }
};
const { assign } = DataHelper;

class LeafData {
    constructor(leaf) {
        this.__leaf = leaf;
    }
    __get(name) {
        if (this.__input) {
            const value = this.__input[name];
            if (value !== undefined)
                return value;
        }
        return this[name];
    }
    __setInput(name, value) {
        this.__input || (this.__input = {});
        this.__input[name] = value;
    }
    __getInput(name) {
        if (this.__input) {
            const value = this.__input[name];
            if (value !== undefined)
                return value;
        }
        return this['_' + name];
    }
    __removeInput(name) {
        if (this.__input && this.__input[name] !== undefined)
            this.__input[name] = undefined;
    }
    __getInputData() {
        const data = { tag: this.__leaf.tag }, { __input } = this;
        let realKey, value;
        for (let key in this) {
            realKey = key.substring(1);
            if (this[realKey] !== undefined) {
                value = __input ? __input[realKey] : undefined;
                data[realKey] = value === undefined ? this[key] : value;
            }
        }
        return data;
    }
    __setMiddle(name, value) {
        this.__middle || (this.__middle = {});
        this.__middle[name] = value;
    }
    __getMiddle(name) {
        return this.__middle && this.__middle[name];
    }
    __checkSingle() {
        if (this.blendMode === 'pass-through') {
            if (this.__leaf.__hasEraser || this.isEraser) {
                this.__single = true;
            }
            else if (this.__single) {
                this.__single = false;
            }
        }
        else {
            this.__single = true;
        }
    }
    destroy() {
        this.__input = this.__middle = null;
    }
}

const FileHelper = {
    mineType(type) {
        if (!type || type.startsWith('image'))
            return type;
        if (type === 'jpg')
            type = 'jpeg';
        return 'image/' + type;
    },
    fileType(filename) {
        const l = filename.split('.');
        return l[l.length - 1];
    }
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function contextAttr(realName) {
    return (target, key) => {
        if (!realName)
            realName = key;
        const property = {
            get() { return this.context[realName]; },
            set(value) { this.context[realName] = value; }
        };
        Object.defineProperty(target, key, property);
    };
}
const contextMethodNameList = [];
function contextMethod() {
    return (_target, key) => {
        contextMethodNameList.push(key);
    };
}
const emptyArray = [];
let Canvas$1 = class Canvas {
    set blendMode(value) {
        if (value === 'normal')
            value = 'source-over';
        this.context.globalCompositeOperation = value;
    }
    get blendMode() {
        return this.context.globalCompositeOperation;
    }
    set dashPattern(value) {
        this.context.setLineDash(value || emptyArray);
    }
    get dashPattern() {
        return this.context.getLineDash();
    }
    __bindContext() {
        let method;
        contextMethodNameList.forEach(name => {
            method = this.context[name];
            if (method)
                this[name] = method.bind(this.context);
        });
        this.textBaseline = "alphabetic";
    }
    setTransform(_a, _b, _c, _d, _e, _f) { }
    resetTransform() { }
    getTransform() { return void 0; }
    save() { }
    restore() { }
    transform(a, b, c, d, e, f) {
        if (typeof a === 'object') {
            this.context.transform(a.a, a.b, a.c, a.d, a.e, a.f);
        }
        else {
            this.context.transform(a, b, c, d, e, f);
        }
    }
    translate(_x, _y) { }
    scale(_x, _y) { }
    rotate(_angle) { }
    fill(_path2d, _rule) { }
    stroke(_path2d) { }
    clip(_path2d, _rule) { }
    fillRect(_x, _y, _width, _height) { }
    strokeRect(_x, _y, _width, _height) { }
    clearRect(_x, _y, _width, _height) { }
    drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
        switch (arguments.length) {
            case 9:
                if (sx < 0) {
                    const d = (-sx / sw) * dw;
                    sw += sx;
                    sx = 0;
                    dx += d;
                    dw -= d;
                }
                if (sy < 0) {
                    const d = (-sy / sh) * dh;
                    sh += sy;
                    sy = 0;
                    dy += d;
                    dh -= d;
                }
                this.context.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
                break;
            case 5:
                this.context.drawImage(image, sx, sy, sw, sh);
                break;
            case 3:
                this.context.drawImage(image, sx, sy);
        }
    }
    beginPath() { }
    moveTo(_x, _y) { }
    lineTo(_x, _y) { }
    bezierCurveTo(_cp1x, _cp1y, _cp2x, _cp2y, _x, _y) { }
    quadraticCurveTo(_cpx, _cpy, _x, _y) { }
    closePath() { }
    arc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) { }
    arcTo(_x1, _y1, _x2, _y2, _radius) { }
    ellipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) { }
    rect(_x, _y, _width, _height) { }
    roundRect(_x, _y, _width, _height, _radius) { }
    createConicGradient(_startAngle, _x, _y) { return void 0; }
    createLinearGradient(_x0, _y0, _x1, _y1) { return void 0; }
    createPattern(_image, _repetition) { return void 0; }
    createRadialGradient(_x0, _y0, _r0, _x1, _y1, _r1) { return void 0; }
    fillText(_text, _x, _y, _maxWidth) { }
    measureText(_text) { return void 0; }
    strokeText(_text, _x, _y, _maxWidth) { }
    destroy() {
        this.context = null;
    }
};
__decorate([
    contextAttr('imageSmoothingEnabled')
], Canvas$1.prototype, "smooth", void 0);
__decorate([
    contextAttr('imageSmoothingQuality')
], Canvas$1.prototype, "smoothLevel", void 0);
__decorate([
    contextAttr('globalAlpha')
], Canvas$1.prototype, "opacity", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "fillStyle", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "strokeStyle", void 0);
__decorate([
    contextAttr('lineWidth')
], Canvas$1.prototype, "strokeWidth", void 0);
__decorate([
    contextAttr('lineCap')
], Canvas$1.prototype, "strokeCap", void 0);
__decorate([
    contextAttr('lineJoin')
], Canvas$1.prototype, "strokeJoin", void 0);
__decorate([
    contextAttr('lineDashOffset')
], Canvas$1.prototype, "dashOffset", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "miterLimit", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "shadowBlur", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "shadowColor", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "shadowOffsetX", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "shadowOffsetY", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "filter", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "font", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "fontKerning", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "fontStretch", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "fontVariantCaps", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "textAlign", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "textBaseline", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "textRendering", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "wordSpacing", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "letterSpacing", void 0);
__decorate([
    contextAttr()
], Canvas$1.prototype, "direction", void 0);
__decorate([
    contextMethod()
], Canvas$1.prototype, "setTransform", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "resetTransform", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "getTransform", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "save", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "restore", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "translate", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "scale", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "rotate", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "fill", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "stroke", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "clip", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "fillRect", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "strokeRect", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "clearRect", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "beginPath", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "moveTo", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "lineTo", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "bezierCurveTo", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "quadraticCurveTo", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "closePath", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "arc", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "arcTo", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "ellipse", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "rect", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "roundRect", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "createConicGradient", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "createLinearGradient", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "createPattern", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "createRadialGradient", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "fillText", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "measureText", null);
__decorate([
    contextMethod()
], Canvas$1.prototype, "strokeText", null);

const temp = new Bounds();
const minSize = { width: 1, height: 1, pixelRatio: 1 };
const debug$c = Debug.get('LeaferCanvasBase');
const canvasSizeAttrs = ['width', 'height', 'pixelRatio'];
class LeaferCanvasBase extends Canvas$1 {
    get pixelWidth() { return this.width * this.pixelRatio; }
    get pixelHeight() { return this.height * this.pixelRatio; }
    get allowBackgroundColor() { return this.view && this.parentView; }
    constructor(config, manager) {
        super();
        this.worldTransform = {};
        if (!config)
            config = minSize;
        if (!config.pixelRatio)
            config.pixelRatio = Platform.devicePixelRatio;
        this.manager = manager;
        this.innerId = IncrementId.create(IncrementId.CNAVAS);
        const { width, height, pixelRatio } = config;
        this.autoLayout = !width || !height;
        this.pixelRatio = pixelRatio;
        this.config = config;
        this.init();
    }
    init() { }
    __createContext() {
        this.context = this.view.getContext('2d');
        this.__bindContext();
    }
    toBlob(type, quality) {
        return new Promise((resolve) => {
            const canvas = this.getSaveCanvas(type);
            Platform.origin.canvasToBolb(canvas.view, type, quality).then((blob) => {
                canvas.recycle();
                resolve(blob);
            }).catch((e) => {
                debug$c.error(e);
                resolve(null);
            });
        });
    }
    toDataURL(type, quality) {
        const canvas = this.getSaveCanvas(type);
        const data = Platform.origin.canvasToDataURL(canvas.view, type, quality);
        canvas.recycle();
        return data;
    }
    saveAs(filename, quality) {
        return new Promise((resolve) => {
            const canvas = this.getSaveCanvas(FileHelper.fileType(filename));
            Platform.origin.canvasSaveAs(canvas.view, filename, quality).then(() => {
                canvas.recycle();
                resolve(true);
            }).catch((e) => {
                debug$c.error(e);
                resolve(false);
            });
        });
    }
    getSaveCanvas(type) {
        const { backgroundColor, bounds } = this;
        const canvas = this.getSameCanvas();
        if (['jpg', 'jpeg'].includes(type))
            canvas.fillWorld(bounds, '#FFFFFF');
        if (backgroundColor)
            canvas.fillWorld(bounds, backgroundColor);
        canvas.copyWorld(this);
        return canvas;
    }
    resize(size) {
        if (this.isSameSize(size))
            return;
        let takeCanvas;
        if (this.context && !this.unreal && this.width) {
            takeCanvas = this.getSameCanvas();
            takeCanvas.copyWorld(this);
        }
        DataHelper.copyAttrs(this, size, canvasSizeAttrs);
        this.bounds = new Bounds(0, 0, this.width, this.height);
        this.pixelRatio || (this.pixelRatio = 1);
        if (!this.unreal) {
            this.updateViewSize();
            this.smooth = this.config.smooth;
        }
        this.updateClientBounds();
        if (this.context && !this.unreal && takeCanvas) {
            this.clearWorld(takeCanvas.bounds);
            this.copyWorld(takeCanvas);
            takeCanvas.recycle();
        }
    }
    updateViewSize() { }
    updateClientBounds() { }
    startAutoLayout(_autoBounds, _listener) { }
    stopAutoLayout() { }
    setCursor(_cursor) { }
    setWorld(matrix, parentMatrix, onlyTranslate) {
        const { pixelRatio } = this;
        const w = this.worldTransform;
        if (parentMatrix) {
            if (onlyTranslate) {
                this.setTransform(w.a = matrix.a * pixelRatio, w.b = matrix.b * pixelRatio, w.c = matrix.c * pixelRatio, w.d = matrix.d * pixelRatio, w.e = (matrix.e + parentMatrix.e) * pixelRatio, w.f = (matrix.f + parentMatrix.f) * pixelRatio);
            }
            else {
                const { a, b, c, d, e, f } = parentMatrix;
                this.setTransform(w.a = ((matrix.a * a) + (matrix.b * c)) * pixelRatio, w.b = ((matrix.a * b) + (matrix.b * d)) * pixelRatio, w.c = ((matrix.c * a) + (matrix.d * c)) * pixelRatio, w.d = ((matrix.c * b) + (matrix.d * d)) * pixelRatio, w.e = (((matrix.e * a) + (matrix.f * c) + e)) * pixelRatio, w.f = (((matrix.e * b) + (matrix.f * d) + f)) * pixelRatio);
            }
        }
        else {
            this.setTransform(w.a = matrix.a * pixelRatio, w.b = matrix.b * pixelRatio, w.c = matrix.c * pixelRatio, w.d = matrix.d * pixelRatio, w.e = matrix.e * pixelRatio, w.f = matrix.f * pixelRatio);
        }
    }
    useWorldTransform(worldTransform) {
        if (worldTransform)
            this.worldTransform = worldTransform;
        const w = this.worldTransform;
        if (w)
            this.setTransform(w.a, w.b, w.c, w.d, w.e, w.f);
    }
    setStroke(color, strokeWidth, options) {
        if (strokeWidth)
            this.strokeWidth = strokeWidth;
        if (color)
            this.strokeStyle = color;
        if (options)
            this.setStrokeOptions(options);
    }
    setStrokeOptions(options) {
        this.strokeCap = options.strokeCap;
        this.strokeJoin = options.strokeJoin;
        this.dashPattern = options.dashPattern;
        this.dashOffset = options.dashOffset;
        this.miterLimit = options.miterLimit;
    }
    saveBlendMode(blendMode) {
        this.savedBlendMode = this.blendMode;
        this.blendMode = blendMode;
    }
    restoreBlendMode() {
        this.blendMode = this.savedBlendMode;
    }
    hitFill(point, fillRule) {
        return fillRule ? this.context.isPointInPath(point.x, point.y, fillRule) : this.context.isPointInPath(point.x, point.y);
    }
    hitStroke(point, strokeWidth) {
        this.strokeWidth = strokeWidth;
        return this.context.isPointInStroke(point.x, point.y);
    }
    setWorldShadow(x, y, blur, color) {
        const { pixelRatio } = this;
        this.shadowOffsetX = x * pixelRatio;
        this.shadowOffsetY = y * pixelRatio;
        this.shadowBlur = blur * pixelRatio;
        this.shadowColor = color || 'black';
    }
    setWorldBlur(blur) {
        const { pixelRatio } = this;
        this.filter = `blur(${blur * pixelRatio}px)`;
    }
    copyWorld(canvas, from, to, blendMode) {
        if (blendMode)
            this.blendMode = blendMode;
        if (from) {
            const { pixelRatio } = this;
            if (!to)
                to = from;
            this.drawImage(canvas.view, from.x * pixelRatio, from.y * pixelRatio, from.width * pixelRatio, from.height * pixelRatio, to.x * pixelRatio, to.y * pixelRatio, to.width * pixelRatio, to.height * pixelRatio);
        }
        else {
            this.drawImage(canvas.view, 0, 0);
        }
        if (blendMode)
            this.blendMode = 'source-over';
    }
    copyWorldToInner(canvas, fromWorld, toInnerBounds, blendMode) {
        if (blendMode)
            this.blendMode = blendMode;
        if (fromWorld.b || fromWorld.c) {
            this.save();
            this.resetTransform();
            this.copyWorld(canvas, fromWorld, BoundsHelper.tempToOuterOf(toInnerBounds, fromWorld));
            this.restore();
        }
        else {
            const { pixelRatio } = this;
            this.drawImage(canvas.view, fromWorld.x * pixelRatio, fromWorld.y * pixelRatio, fromWorld.width * pixelRatio, fromWorld.height * pixelRatio, toInnerBounds.x, toInnerBounds.y, toInnerBounds.width, toInnerBounds.height);
        }
        if (blendMode)
            this.blendMode = 'source-over';
    }
    copyWorldByReset(canvas, from, to, blendMode) {
        this.resetTransform();
        this.copyWorld(canvas, from, to, blendMode);
        this.useWorldTransform();
    }
    useMask(maskCanvas, fromBounds, toBounds) {
        this.copyWorld(maskCanvas, fromBounds, toBounds, 'destination-in');
    }
    useEraser(eraserCanvas, fromBounds, toBounds) {
        this.copyWorld(eraserCanvas, fromBounds, toBounds, 'destination-out');
    }
    fillWorld(bounds, color, blendMode) {
        if (blendMode)
            this.blendMode = blendMode;
        this.fillStyle = color;
        temp.copy(bounds).scale(this.pixelRatio);
        this.fillRect(temp.x, temp.y, temp.width, temp.height);
        if (blendMode)
            this.blendMode = 'source-over';
    }
    strokeWorld(bounds, color, blendMode) {
        if (blendMode)
            this.blendMode = blendMode;
        this.strokeStyle = color;
        temp.copy(bounds).scale(this.pixelRatio);
        this.strokeRect(temp.x, temp.y, temp.width, temp.height);
        if (blendMode)
            this.blendMode = 'source-over';
    }
    clearWorld(bounds, ceilPixel) {
        temp.copy(bounds).scale(this.pixelRatio);
        if (ceilPixel)
            temp.ceil();
        this.clearRect(temp.x, temp.y, temp.width, temp.height);
    }
    clipWorld(bounds, ceilPixel) {
        this.beginPath();
        temp.copy(bounds).scale(this.pixelRatio);
        if (ceilPixel)
            temp.ceil();
        this.rect(temp.x, temp.y, temp.width, temp.height);
        this.clip();
    }
    clear() {
        const { pixelRatio } = this;
        this.clearRect(0, 0, this.width * pixelRatio, this.height * pixelRatio);
    }
    isSameSize(size) {
        return this.width === size.width && this.height === size.height && this.pixelRatio === size.pixelRatio;
    }
    getSameCanvas(useSameWorldTransform) {
        const { width, height, pixelRatio } = this;
        const options = { width, height, pixelRatio };
        const canvas = this.manager ? this.manager.get(options) : Creator.canvas(options);
        canvas.save();
        if (useSameWorldTransform)
            canvas.useWorldTransform(Object.assign({}, this.worldTransform));
        return canvas;
    }
    getBiggerCanvas(addWidth, addHeight) {
        let { width, height, pixelRatio } = this;
        if (addWidth)
            width += addWidth;
        if (addHeight)
            height += addHeight;
        const options = { width, height, pixelRatio };
        const canvas = this.manager ? this.manager.get(options) : Creator.canvas(options);
        canvas.save();
        return canvas;
    }
    recycle() {
        if (!this.recycled) {
            this.restore();
            this.manager ? this.manager.recycle(this) : this.destroy();
        }
    }
    updateRender() { }
    unrealCanvas() { }
    destroy() {
        this.manager = this.view = this.parentView = null;
    }
}

const PathHelper = {
    creator: {},
    parse(_pathString, _curveMode) { return undefined; },
    convertToCanvasData(_old, _curveMode) { return undefined; }
};

const CanvasCommandOnlyMap = {
    N: 21,
    D: 22,
    X: 23,
    G: 24,
    F: 25,
    O: 26,
    P: 27,
    U: 28
};
const PathCommandMap = Object.assign({ M: 1, m: 10, L: 2, l: 20, H: 3, h: 30, V: 4, v: 40, C: 5, c: 50, S: 6, s: 60, Q: 7, q: 70, T: 8, t: 80, A: 9, a: 90, Z: 11, z: 11, R: 12 }, CanvasCommandOnlyMap);
const PathCommandLengthMap = {
    M: 3,
    m: 3,
    L: 3,
    l: 3,
    H: 2,
    h: 2,
    V: 2,
    v: 2,
    C: 7,
    c: 7,
    S: 5,
    s: 5,
    Q: 5,
    q: 5,
    T: 3,
    t: 3,
    A: 8,
    a: 8,
    Z: 1,
    z: 1,
    N: 5,
    D: 9,
    X: 6,
    G: 9,
    F: 5,
    O: 7,
    P: 4,
    U: 6
};
const NeedConvertToCanvasCommandMap = {
    m: 10,
    l: 20,
    H: 3,
    h: 30,
    V: 4,
    v: 40,
    c: 50,
    S: 6,
    s: 60,
    q: 70,
    T: 8,
    t: 80,
    A: 9,
    a: 90,
};
const NeedConvertToCurveCommandMap = Object.assign(Object.assign({}, NeedConvertToCanvasCommandMap), CanvasCommandOnlyMap);
const P$4 = PathCommandMap;
const PathNumberCommandMap = {};
for (let key in P$4) {
    PathNumberCommandMap[P$4[key]] = key;
}
const PathNumberCommandLengthMap = {};
for (let key in P$4) {
    PathNumberCommandLengthMap[P$4[key]] = PathCommandLengthMap[key];
}

const RectHelper = {
    drawRoundRect(drawer, x, y, width, height, cornerRadius) {
        let [topLeft, topRight, bottomRight, bottomLeft] = MathHelper.fourNumber(cornerRadius);
        const max = Math.min(width / 2, height / 2);
        if (topLeft > max)
            topLeft = max;
        if (topRight > max)
            topRight = max;
        if (bottomRight > max)
            bottomRight = max;
        if (bottomLeft > max)
            bottomLeft = max;
        topLeft ? drawer.moveTo(x + topLeft, y) : drawer.moveTo(x, y);
        topRight ? drawer.arcTo(x + width, y, x + width, y + height, topRight) : drawer.lineTo(x + width, y);
        bottomRight ? drawer.arcTo(x + width, y + height, x, y + height, bottomRight) : drawer.lineTo(x + width, y + height);
        bottomLeft ? drawer.arcTo(x, y + height, x, y, bottomLeft) : drawer.lineTo(x, y + height);
        topLeft ? drawer.arcTo(x, y, x + width, y, topLeft) : drawer.lineTo(x, y);
    }
};

const { sin: sin$4, cos: cos$4, atan2: atan2$1, ceil, abs, PI: PI$2, sqrt: sqrt$1, pow } = Math;
const { setPoint: setPoint$1, addPoint: addPoint$1 } = TwoPointBoundsHelper;
const { set: set$2 } = PointHelper;
const { M: M$4, L: L$5, C: C$4, Q: Q$4, Z: Z$4 } = PathCommandMap;
const tempPoint = {};
const BezierHelper = {
    points(data, points, curve, close) {
        data.push(M$4, points[0], points[1]);
        if (curve && points.length > 5) {
            let aX, aY, bX, bY, cX, cY, c1X, c1Y, c2X, c2Y;
            let ba, cb, d, len = points.length;
            const t = curve === true ? 0.5 : curve;
            if (close) {
                points = [points[len - 2], points[len - 1], ...points, points[0], points[1], points[2], points[3]];
                len = points.length;
            }
            for (let i = 2; i < len - 2; i += 2) {
                aX = points[i - 2];
                aY = points[i - 1];
                bX = points[i];
                bY = points[i + 1];
                cX = points[i + 2];
                cY = points[i + 3];
                ba = sqrt$1(pow(bX - aX, 2) + pow(bY - aY, 2));
                cb = sqrt$1(pow(cX - bX, 2) + pow(cY - bY, 2));
                d = ba + cb;
                ba = (t * ba) / d;
                cb = (t * cb) / d;
                cX -= aX;
                cY -= aY;
                c1X = bX - ba * cX;
                c1Y = bY - ba * cY;
                if (i === 2) {
                    if (!close)
                        data.push(Q$4, c1X, c1Y, bX, bY);
                }
                else {
                    data.push(C$4, c2X, c2Y, c1X, c1Y, bX, bY);
                }
                c2X = bX + cb * cX;
                c2Y = bY + cb * cY;
            }
            if (!close)
                data.push(Q$4, c2X, c2Y, points[len - 2], points[len - 1]);
        }
        else {
            for (let i = 2, len = points.length; i < len; i += 2) {
                data.push(L$5, points[i], points[i + 1]);
            }
        }
        if (close)
            data.push(Z$4);
    },
    rect(data, x, y, width, height) {
        PathHelper.creator.path = data;
        PathHelper.creator.moveTo(x, y).lineTo(x + width, y).lineTo(x + width, y + height).lineTo(x, y + height).lineTo(x, y);
    },
    roundRect(data, x, y, width, height, radius) {
        PathHelper.creator.path = [];
        RectHelper.drawRoundRect(PathHelper.creator, x, y, width, height, radius);
        data.push(...PathHelper.convertToCanvasData(PathHelper.creator.path, true));
    },
    arcTo(data, fromX, fromY, x1, y1, toX, toY, radius, setPointBounds, setEndPoint, setStartPoint) {
        const BAx = x1 - fromX;
        const BAy = y1 - fromY;
        const CBx = toX - x1;
        const CBy = toY - y1;
        let startRadian = atan2$1(BAy, BAx);
        let endRadian = atan2$1(CBy, CBx);
        let totalRadian = endRadian - startRadian;
        if (totalRadian < 0)
            totalRadian += PI2;
        if (totalRadian === PI$2 || (abs(BAx + BAy) < 1.e-12) || (abs(CBx + CBy) < 1.e-12)) {
            if (data)
                data.push(L$5, x1, y1);
            if (setPointBounds) {
                setPoint$1(setPointBounds, fromX, fromY);
                addPoint$1(setPointBounds, x1, y1);
            }
            if (setStartPoint)
                set$2(setStartPoint, fromX, fromY);
            if (setEndPoint)
                set$2(setEndPoint, x1, y1);
            return;
        }
        const anticlockwise = BAx * CBy - CBx * BAy < 0;
        const sign = anticlockwise ? -1 : 1;
        const c = radius / cos$4(totalRadian / 2);
        const centerX = x1 + c * cos$4(startRadian + totalRadian / 2 + PI_2 * sign);
        const centerY = y1 + c * sin$4(startRadian + totalRadian / 2 + PI_2 * sign);
        startRadian -= PI_2 * sign;
        endRadian -= PI_2 * sign;
        return ellipse$6(data, centerX, centerY, radius, radius, 0, startRadian / OneRadian, endRadian / OneRadian, anticlockwise, setPointBounds, setEndPoint, setStartPoint);
    },
    arc(data, x, y, radius, startAngle, endAngle, anticlockwise, setPointBounds, setEndPoint, setStartPoint) {
        return ellipse$6(data, x, y, radius, radius, 0, startAngle, endAngle, anticlockwise, setPointBounds, setEndPoint, setStartPoint);
    },
    ellipse(data, cx, cy, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise, setPointBounds, setEndPoint, setStartPoint) {
        const rotationRadian = rotation * OneRadian;
        const rotationSin = sin$4(rotationRadian);
        const rotationCos = cos$4(rotationRadian);
        let startRadian = startAngle * OneRadian;
        let endRadian = endAngle * OneRadian;
        if (startRadian > PI$2)
            startRadian -= PI2;
        if (endRadian < 0)
            endRadian += PI2;
        let totalRadian = endRadian - startRadian;
        if (totalRadian < 0)
            totalRadian += PI2;
        else if (totalRadian > PI2)
            totalRadian -= PI2;
        if (anticlockwise)
            totalRadian -= PI2;
        const parts = ceil(abs(totalRadian / PI_2));
        const partRadian = totalRadian / parts;
        const partRadian4Sin = sin$4(partRadian / 4);
        const control = 8 / 3 * partRadian4Sin * partRadian4Sin / sin$4(partRadian / 2);
        endRadian = startRadian + partRadian;
        let startCos = cos$4(startRadian);
        let startSin = sin$4(startRadian);
        let endCos, endSin;
        let x, y, x1, y1, x2, y2;
        let startX = x = rotationCos * radiusX * startCos - rotationSin * radiusY * startSin;
        let startY = y = rotationSin * radiusX * startCos + rotationCos * radiusY * startSin;
        let fromX = cx + x, fromY = cy + y;
        if (data)
            data.push(L$5, fromX, fromY);
        if (setPointBounds)
            setPoint$1(setPointBounds, fromX, fromY);
        if (setStartPoint)
            set$2(setStartPoint, fromX, fromY);
        for (let i = 0; i < parts; i++) {
            endCos = cos$4(endRadian);
            endSin = sin$4(endRadian);
            x = rotationCos * radiusX * endCos - rotationSin * radiusY * endSin;
            y = rotationSin * radiusX * endCos + rotationCos * radiusY * endSin;
            x1 = cx + startX - control * (rotationCos * radiusX * startSin + rotationSin * radiusY * startCos);
            y1 = cy + startY - control * (rotationSin * radiusX * startSin - rotationCos * radiusY * startCos);
            x2 = cx + x + control * (rotationCos * radiusX * endSin + rotationSin * radiusY * endCos);
            y2 = cy + y + control * (rotationSin * radiusX * endSin - rotationCos * radiusY * endCos);
            if (data)
                data.push(C$4, x1, y1, x2, y2, cx + x, cy + y);
            if (setPointBounds)
                toTwoPointBounds$1(cx + startX, cy + startY, x1, y1, x2, y2, cx + x, cy + y, setPointBounds, true);
            startX = x;
            startY = y;
            startCos = endCos;
            startSin = endSin;
            startRadian = endRadian;
            endRadian += partRadian;
        }
        if (setEndPoint)
            set$2(setEndPoint, cx + x, cy + y);
    },
    quadraticCurveTo(data, fromX, fromY, x1, y1, toX, toY) {
        data.push(C$4, (fromX + 2 * x1) / 3, (fromY + 2 * y1) / 3, (toX + 2 * x1) / 3, (toY + 2 * y1) / 3, toX, toY);
    },
    toTwoPointBoundsByQuadraticCurve(fromX, fromY, x1, y1, toX, toY, pointBounds, addMode) {
        toTwoPointBounds$1(fromX, fromY, (fromX + 2 * x1) / 3, (fromY + 2 * y1) / 3, (toX + 2 * x1) / 3, (toY + 2 * y1) / 3, toX, toY, pointBounds, addMode);
    },
    toTwoPointBounds(fromX, fromY, x1, y1, x2, y2, toX, toY, pointBounds, addMode) {
        const tList = [];
        let a, b, c, t, t1, t2, v, sqrtV;
        let f = fromX, z1 = x1, z2 = x2, o = toX;
        for (let i = 0; i < 2; ++i) {
            if (i == 1) {
                f = fromY, z1 = y1, z2 = y2, o = toY;
            }
            a = -3 * f + 9 * z1 - 9 * z2 + 3 * o;
            b = 6 * f - 12 * z1 + 6 * z2;
            c = 3 * z1 - 3 * f;
            if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12)
                    continue;
                t = -c / b;
                if (0 < t && t < 1)
                    tList.push(t);
                continue;
            }
            v = b * b - 4 * c * a;
            sqrtV = Math.sqrt(v);
            if (v < 0)
                continue;
            t1 = (-b + sqrtV) / (2 * a);
            if (0 < t1 && t1 < 1)
                tList.push(t1);
            t2 = (-b - sqrtV) / (2 * a);
            if (0 < t2 && t2 < 1)
                tList.push(t2);
        }
        addMode ? addPoint$1(pointBounds, fromX, fromY) : setPoint$1(pointBounds, fromX, fromY);
        addPoint$1(pointBounds, toX, toY);
        for (let i = 0, len = tList.length; i < len; i++) {
            getPointAndSet(tList[i], fromX, fromY, x1, y1, x2, y2, toX, toY, tempPoint);
            addPoint$1(pointBounds, tempPoint.x, tempPoint.y);
        }
    },
    getPointAndSet(t, fromX, fromY, x1, y1, x2, y2, toX, toY, setPoint) {
        const o = 1 - t, a = o * o * o, b = 3 * o * o * t, c = 3 * o * t * t, d = t * t * t;
        setPoint.x = a * fromX + b * x1 + c * x2 + d * toX;
        setPoint.y = a * fromY + b * y1 + c * y2 + d * toY;
    },
    getPoint(t, fromX, fromY, x1, y1, x2, y2, toX, toY) {
        const point = {};
        getPointAndSet(t, fromX, fromY, x1, y1, x2, y2, toX, toY, point);
        return point;
    }
};
const { getPointAndSet, toTwoPointBounds: toTwoPointBounds$1, ellipse: ellipse$6 } = BezierHelper;

const { sin: sin$3, cos: cos$3, sqrt, atan2 } = Math;
const { ellipse: ellipse$5 } = BezierHelper;
const EllipseHelper = {
    ellipticalArc(data, fromX, fromY, radiusX, radiusY, rotation, largeFlag, sweepFlag, toX, toY, curveMode) {
        const halfX = (toX - fromX) / 2;
        const halfY = (toY - fromY) / 2;
        const rotationRadian = rotation * OneRadian;
        const rotationSin = sin$3(rotationRadian);
        const rotationCos = cos$3(rotationRadian);
        const px = -rotationCos * halfX - rotationSin * halfY;
        const py = -rotationCos * halfY + rotationSin * halfX;
        const rxSquare = radiusX * radiusX;
        const rySquare = radiusY * radiusY;
        const pySquare = py * py;
        const pxSquare = px * px;
        const a = rxSquare * rySquare - rxSquare * pySquare - rySquare * pxSquare;
        let s = 0;
        if (a < 0) {
            const t = sqrt(1 - a / (rxSquare * rySquare));
            radiusX *= t;
            radiusY *= t;
        }
        else {
            s = (largeFlag === sweepFlag ? -1 : 1) * sqrt(a / (rxSquare * pySquare + rySquare * pxSquare));
        }
        const cx = s * radiusX * py / radiusY;
        const cy = -s * radiusY * px / radiusX;
        const startRadian = atan2((py - cy) / radiusY, (px - cx) / radiusX);
        const endRadian = atan2((-py - cy) / radiusY, (-px - cx) / radiusX);
        let totalRadian = endRadian - startRadian;
        if (sweepFlag === 0 && totalRadian > 0) {
            totalRadian -= PI2;
        }
        else if (sweepFlag === 1 && totalRadian < 0) {
            totalRadian += PI2;
        }
        const centerX = fromX + halfX + rotationCos * cx - rotationSin * cy;
        const centerY = fromY + halfY + rotationSin * cx + rotationCos * cy;
        const anticlockwise = totalRadian < 0 ? 1 : 0;
        if (curveMode) {
            ellipse$5(data, centerX, centerY, radiusX, radiusY, rotation, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
        }
        else {
            if (radiusX === radiusY && !rotation) {
                data.push(PathCommandMap.O, centerX, centerY, radiusX, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
            }
            else {
                data.push(PathCommandMap.G, centerX, centerY, radiusX, radiusY, rotation, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
            }
        }
    }
};

const { M: M$3, m, L: L$4, l, H, h, V, v, C: C$3, c, S, s, Q: Q$3, q, T, t, A, a, Z: Z$3, z, N: N$3, D: D$3, X: X$3, G: G$3, F: F$3, O: O$3, P: P$3, U: U$3 } = PathCommandMap;
const { rect: rect$2, roundRect: roundRect$2, arcTo: arcTo$2, arc: arc$3, ellipse: ellipse$4, quadraticCurveTo: quadraticCurveTo$1 } = BezierHelper;
const { ellipticalArc } = EllipseHelper;
const debug$b = Debug.get('PathConvert');
const setEndPoint$1 = {};
const PathConvert = {
    current: { dot: 0 },
    stringify(data) {
        let i = 0, len = data.length, count, str = '', command, lastCommand;
        while (i < len) {
            command = data[i];
            count = PathNumberCommandLengthMap[command];
            if (command === lastCommand) {
                str += ' ';
            }
            else {
                str += PathNumberCommandMap[command];
            }
            for (let j = 1; j < count; j++) {
                str += data[i + j];
                (j === count - 1) || (str += ' ');
            }
            lastCommand = command;
            i += count;
        }
        return str;
    },
    parse(pathString, curveMode) {
        let needConvert, char, lastChar, num = '';
        const data = [];
        const convertCommand = curveMode ? NeedConvertToCurveCommandMap : NeedConvertToCanvasCommandMap;
        for (let i = 0, len = pathString.length; i < len; i++) {
            char = pathString[i];
            if (StringNumberMap[char]) {
                if (char === '.') {
                    current.dot++;
                    if (current.dot > 1) {
                        pushData(data, num);
                        num = '';
                    }
                }
                num += char;
            }
            else if (PathCommandMap[char]) {
                if (num) {
                    pushData(data, num);
                    num = '';
                }
                current.name = PathCommandMap[char];
                current.length = PathCommandLengthMap[char];
                current.index = 0;
                pushData(data, current.name);
                if (!needConvert && convertCommand[char])
                    needConvert = true;
            }
            else {
                if (char === '-' || char === '+') {
                    if (lastChar === 'e' || lastChar === 'E') {
                        num += char;
                    }
                    else {
                        if (num)
                            pushData(data, num);
                        num = char;
                    }
                }
                else {
                    if (num) {
                        pushData(data, num);
                        num = '';
                    }
                }
            }
            lastChar = char;
        }
        if (num)
            pushData(data, num);
        return needConvert ? PathConvert.toCanvasData(data, curveMode) : data;
    },
    toCanvasData(old, curveMode) {
        let x = 0, y = 0, x1 = 0, y1 = 0, i = 0, len = old.length, controlX, controlY, command, lastCommand, smooth;
        const data = [];
        while (i < len) {
            command = old[i];
            switch (command) {
                case m:
                    old[i + 1] += x;
                    old[i + 2] += y;
                case M$3:
                    x = old[i + 1];
                    y = old[i + 2];
                    data.push(M$3, x, y);
                    i += 3;
                    break;
                case h:
                    old[i + 1] += x;
                case H:
                    x = old[i + 1];
                    data.push(L$4, x, y);
                    i += 2;
                    break;
                case v:
                    old[i + 1] += y;
                case V:
                    y = old[i + 1];
                    data.push(L$4, x, y);
                    i += 2;
                    break;
                case l:
                    old[i + 1] += x;
                    old[i + 2] += y;
                case L$4:
                    x = old[i + 1];
                    y = old[i + 2];
                    data.push(L$4, x, y);
                    i += 3;
                    break;
                case s:
                    old[i + 1] += x;
                    old[i + 2] += y;
                    old[i + 3] += x;
                    old[i + 4] += y;
                    command = S;
                case S:
                    smooth = (lastCommand === C$3) || (lastCommand === S);
                    x1 = smooth ? (x * 2 - controlX) : old[i + 1];
                    y1 = smooth ? (y * 2 - controlY) : old[i + 2];
                    controlX = old[i + 1];
                    controlY = old[i + 2];
                    x = old[i + 3];
                    y = old[i + 4];
                    data.push(C$3, x1, y1, controlX, controlY, x, y);
                    i += 5;
                    break;
                case c:
                    old[i + 1] += x;
                    old[i + 2] += y;
                    old[i + 3] += x;
                    old[i + 4] += y;
                    old[i + 5] += x;
                    old[i + 6] += y;
                    command = C$3;
                case C$3:
                    controlX = old[i + 3];
                    controlY = old[i + 4];
                    x = old[i + 5];
                    y = old[i + 6];
                    data.push(C$3, old[i + 1], old[i + 2], controlX, controlY, x, y);
                    i += 7;
                    break;
                case t:
                    old[i + 1] += x;
                    old[i + 2] += y;
                    command = T;
                case T:
                    smooth = (lastCommand === Q$3) || (lastCommand === T);
                    controlX = smooth ? (x * 2 - controlX) : old[i + 1];
                    controlY = smooth ? (y * 2 - controlY) : old[i + 2];
                    curveMode ? quadraticCurveTo$1(data, x, y, controlX, controlY, old[i + 1], old[i + 2]) : data.push(Q$3, controlX, controlY, old[i + 1], old[i + 2]);
                    x = old[i + 1];
                    y = old[i + 2];
                    i += 3;
                    break;
                case q:
                    old[i + 1] += x;
                    old[i + 2] += y;
                    old[i + 3] += x;
                    old[i + 4] += y;
                    command = Q$3;
                case Q$3:
                    controlX = old[i + 1];
                    controlY = old[i + 2];
                    curveMode ? quadraticCurveTo$1(data, x, y, controlX, controlY, old[i + 3], old[i + 4]) : data.push(Q$3, controlX, controlY, old[i + 3], old[i + 4]);
                    x = old[i + 3];
                    y = old[i + 4];
                    i += 5;
                    break;
                case a:
                    old[i + 6] += x;
                    old[i + 7] += y;
                case A:
                    ellipticalArc(data, x, y, old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], old[i + 7], curveMode);
                    x = old[i + 6];
                    y = old[i + 7];
                    i += 8;
                    break;
                case z:
                case Z$3:
                    data.push(Z$3);
                    i++;
                    break;
                case N$3:
                    x = old[i + 1];
                    y = old[i + 2];
                    curveMode ? rect$2(data, x, y, old[i + 3], old[i + 4]) : copyData(data, old, i, 5);
                    i += 5;
                    break;
                case D$3:
                    x = old[i + 1];
                    y = old[i + 2];
                    curveMode ? roundRect$2(data, x, y, old[i + 3], old[i + 4], [old[i + 5], old[i + 6], old[i + 7], old[i + 8]]) : copyData(data, old, i, 9);
                    i += 9;
                    break;
                case X$3:
                    x = old[i + 1];
                    y = old[i + 2];
                    curveMode ? roundRect$2(data, x, y, old[i + 3], old[i + 4], old[i + 5]) : copyData(data, old, i, 6);
                    i += 6;
                    break;
                case G$3:
                    ellipse$4(curveMode ? data : copyData(data, old, i, 9), old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], old[i + 7], old[i + 8], null, setEndPoint$1);
                    x = setEndPoint$1.x;
                    y = setEndPoint$1.y;
                    i += 9;
                    break;
                case F$3:
                    curveMode ? ellipse$4(data, old[i + 1], old[i + 2], old[i + 3], old[i + 4], 0, 0, 360, false) : copyData(data, old, i, 5);
                    x = old[i + 1] + old[i + 3];
                    y = old[i + 2];
                    i += 5;
                    break;
                case O$3:
                    arc$3(curveMode ? data : copyData(data, old, i, 7), old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], null, setEndPoint$1);
                    x = setEndPoint$1.x;
                    y = setEndPoint$1.y;
                    i += 7;
                    break;
                case P$3:
                    curveMode ? arc$3(data, old[i + 1], old[i + 2], old[i + 3], 0, 360, false) : copyData(data, old, i, 4);
                    x = old[i + 1] + old[i + 3];
                    y = old[i + 2];
                    i += 4;
                    break;
                case U$3:
                    arcTo$2(curveMode ? data : copyData(data, old, i, 6), x, y, old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], null, setEndPoint$1);
                    x = setEndPoint$1.x;
                    y = setEndPoint$1.y;
                    i += 6;
                    break;
                default:
                    debug$b.error(`command: ${command} [index:${i}]`, old);
                    return data;
            }
            lastCommand = command;
        }
        return data;
    },
    copyData(data, old, index, count) {
        for (let i = index, end = index + count; i < end; i++) {
            data.push(old[i]);
        }
    },
    pushData(data, strNum) {
        if (current.index === current.length) {
            current.index = 1;
            data.push(current.name);
        }
        data.push(Number(strNum));
        current.index++;
        current.dot = 0;
    }
};
const { current, pushData, copyData } = PathConvert;

const { M: M$2, L: L$3, C: C$2, Q: Q$2, Z: Z$2, N: N$2, D: D$2, X: X$2, G: G$2, F: F$2, O: O$2, P: P$2, U: U$2 } = PathCommandMap;
const startPoint = {};
const PathCommandDataHelper = {
    beginPath(data) {
        data.length = 0;
    },
    moveTo(data, x, y) {
        data.push(M$2, x, y);
    },
    lineTo(data, x, y) {
        data.push(L$3, x, y);
    },
    bezierCurveTo(data, x1, y1, x2, y2, x, y) {
        data.push(C$2, x1, y1, x2, y2, x, y);
    },
    quadraticCurveTo(data, x1, y1, x, y) {
        data.push(Q$2, x1, y1, x, y);
    },
    closePath(data) {
        data.push(Z$2);
    },
    rect(data, x, y, width, height) {
        data.push(N$2, x, y, width, height);
    },
    roundRect(data, x, y, width, height, cornerRadius) {
        if (typeof cornerRadius === 'number') {
            data.push(X$2, x, y, width, height, cornerRadius);
        }
        else {
            const fourCorners = MathHelper.fourNumber(cornerRadius);
            if (fourCorners) {
                data.push(D$2, x, y, width, height, ...fourCorners);
            }
            else {
                data.push(N$2, x, y, width, height);
            }
        }
    },
    ellipse(data, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        if (rotation === undefined) {
            data.push(F$2, x, y, radiusX, radiusY);
        }
        else {
            if (startAngle === undefined)
                startAngle = 0;
            if (endAngle === undefined)
                endAngle = 360;
            data.push(G$2, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ? 1 : 0);
        }
    },
    arc(data, x, y, radius, startAngle, endAngle, anticlockwise) {
        if (startAngle === undefined) {
            data.push(P$2, x, y, radius);
        }
        else {
            if (endAngle === undefined)
                endAngle = 360;
            data.push(O$2, x, y, radius, startAngle, endAngle, anticlockwise ? 1 : 0);
        }
    },
    arcTo(data, x1, y1, x2, y2, radius) {
        data.push(U$2, x1, y1, x2, y2, radius);
    },
    drawEllipse(data, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        if (rotation === undefined)
            rotation = 0;
        if (startAngle === undefined)
            startAngle = 0;
        if (endAngle === undefined)
            endAngle = 360;
        BezierHelper.ellipse(null, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise, null, null, startPoint);
        data.push(M$2, startPoint.x, startPoint.y);
        ellipse$3(data, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    },
    drawArc(data, x, y, radius, startAngle, endAngle, anticlockwise) {
        if (startAngle === undefined)
            startAngle = 0;
        if (endAngle === undefined)
            endAngle = 360;
        BezierHelper.arc(null, x, y, radius, startAngle, endAngle, anticlockwise, null, null, startPoint);
        data.push(M$2, startPoint.x, startPoint.y);
        arc$2(data, x, y, radius, startAngle, endAngle, anticlockwise);
    },
    drawPoints(data, points, curve, close) {
        BezierHelper.points(data, points, curve, close);
    }
};
const { ellipse: ellipse$3, arc: arc$2 } = PathCommandDataHelper;

const { moveTo: moveTo$4, lineTo: lineTo$3, quadraticCurveTo, bezierCurveTo, closePath: closePath$3, beginPath, rect: rect$1, roundRect: roundRect$1, ellipse: ellipse$2, arc: arc$1, arcTo: arcTo$1, drawEllipse, drawArc, drawPoints: drawPoints$2 } = PathCommandDataHelper;
class PathCreator {
    constructor(path) {
        if (path) {
            this.path = typeof path === 'string' ? PathHelper.parse(path) : path;
        }
        else {
            this.path = [];
        }
    }
    beginPath() {
        beginPath(this.path);
        return this;
    }
    moveTo(x, y) {
        moveTo$4(this.path, x, y);
        return this;
    }
    lineTo(x, y) {
        lineTo$3(this.path, x, y);
        return this;
    }
    bezierCurveTo(x1, y1, x2, y2, x, y) {
        bezierCurveTo(this.path, x1, y1, x2, y2, x, y);
        return this;
    }
    quadraticCurveTo(x1, y1, x, y) {
        quadraticCurveTo(this.path, x1, y1, x, y);
        return this;
    }
    closePath() {
        closePath$3(this.path);
        return this;
    }
    rect(x, y, width, height) {
        rect$1(this.path, x, y, width, height);
        return this;
    }
    roundRect(x, y, width, height, cornerRadius) {
        roundRect$1(this.path, x, y, width, height, cornerRadius);
        return this;
    }
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        ellipse$2(this.path, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
        return this;
    }
    arc(x, y, radius, startAngle, endAngle, anticlockwise) {
        arc$1(this.path, x, y, radius, startAngle, endAngle, anticlockwise);
        return this;
    }
    arcTo(x1, y1, x2, y2, radius) {
        arcTo$1(this.path, x1, y1, x2, y2, radius);
        return this;
    }
    drawEllipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        drawEllipse(this.path, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
        return this;
    }
    drawArc(x, y, radius, startAngle, endAngle, anticlockwise) {
        drawArc(this.path, x, y, radius, startAngle, endAngle, anticlockwise);
        return this;
    }
    drawPoints(points, curve, close) {
        drawPoints$2(this.path, points, curve, close);
        return this;
    }
}

const { M: M$1, L: L$2, C: C$1, Q: Q$1, Z: Z$1, N: N$1, D: D$1, X: X$1, G: G$1, F: F$1, O: O$1, P: P$1, U: U$1 } = PathCommandMap;
const debug$a = Debug.get('PathDrawer');
const PathDrawer = {
    drawPathByData(drawer, data) {
        if (!data)
            return;
        let command;
        let i = 0, len = data.length;
        while (i < len) {
            command = data[i];
            switch (command) {
                case M$1:
                    drawer.moveTo(data[i + 1], data[i + 2]);
                    i += 3;
                    break;
                case L$2:
                    drawer.lineTo(data[i + 1], data[i + 2]);
                    i += 3;
                    break;
                case C$1:
                    drawer.bezierCurveTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6]);
                    i += 7;
                    break;
                case Q$1:
                    drawer.quadraticCurveTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4]);
                    i += 5;
                    break;
                case Z$1:
                    drawer.closePath();
                    i += 1;
                    break;
                case N$1:
                    drawer.rect(data[i + 1], data[i + 2], data[i + 3], data[i + 4]);
                    i += 5;
                    break;
                case D$1:
                    drawer.roundRect(data[i + 1], data[i + 2], data[i + 3], data[i + 4], [data[i + 5], data[i + 6], data[i + 7], data[i + 8]]);
                    i += 9;
                    break;
                case X$1:
                    drawer.roundRect(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5]);
                    i += 6;
                    break;
                case G$1:
                    drawer.ellipse(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5] * OneRadian, data[i + 6] * OneRadian, data[i + 7] * OneRadian, data[i + 8]);
                    i += 9;
                    break;
                case F$1:
                    drawer.ellipse(data[i + 1], data[i + 2], data[i + 3], data[i + 4], 0, 0, PI2, false);
                    i += 5;
                    break;
                case O$1:
                    drawer.arc(data[i + 1], data[i + 2], data[i + 3], data[i + 4] * OneRadian, data[i + 5] * OneRadian, data[i + 6]);
                    i += 7;
                    break;
                case P$1:
                    drawer.arc(data[i + 1], data[i + 2], data[i + 3], 0, PI2, false);
                    i += 4;
                    break;
                case U$1:
                    drawer.arcTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5]);
                    i += 6;
                    break;
                default:
                    debug$a.error(`command: ${command} [index:${i}]`, data);
                    return;
            }
        }
    }
};

const { M, L: L$1, C, Q, Z, N, D, X, G, F, O, P, U } = PathCommandMap;
const { toTwoPointBounds, toTwoPointBoundsByQuadraticCurve, arcTo, arc, ellipse: ellipse$1 } = BezierHelper;
const { add: add$1, copy: copy$6, addPoint, setPoint, addBounds, toBounds: toBounds$3 } = TwoPointBoundsHelper;
const debug$9 = Debug.get('PathBounds');
let radius, radiusX, radiusY;
const tempPointBounds = {};
const setPointBounds = {};
const setEndPoint = {};
const PathBounds = {
    toBounds(data, setBounds) {
        PathBounds.toTwoPointBounds(data, setPointBounds);
        toBounds$3(setPointBounds, setBounds);
    },
    toTwoPointBounds(data, setPointBounds) {
        if (!data || !data.length)
            return setPoint(setPointBounds, 0, 0);
        let command;
        let i = 0, x = 0, y = 0, x1, y1, toX, toY;
        const len = data.length;
        while (i < len) {
            command = data[i];
            if (i === 0) {
                if (command === Z || command === C || command === Q) {
                    setPoint(setPointBounds, x, y);
                }
                else {
                    setPoint(setPointBounds, data[i + 1], data[i + 2]);
                }
            }
            switch (command) {
                case M:
                case L$1:
                    x = data[i + 1];
                    y = data[i + 2];
                    addPoint(setPointBounds, x, y);
                    i += 3;
                    break;
                case C:
                    toX = data[i + 5];
                    toY = data[i + 6];
                    toTwoPointBounds(x, y, data[i + 1], data[i + 2], data[i + 3], data[i + 4], toX, toY, tempPointBounds);
                    add$1(setPointBounds, tempPointBounds);
                    x = toX;
                    y = toY;
                    i += 7;
                    break;
                case Q:
                    x1 = data[i + 1];
                    y1 = data[i + 2];
                    toX = data[i + 3];
                    toY = data[i + 4];
                    toTwoPointBoundsByQuadraticCurve(x, y, x1, y1, toX, toY, tempPointBounds);
                    add$1(setPointBounds, tempPointBounds);
                    x = toX;
                    y = toY;
                    i += 5;
                    break;
                case Z:
                    i += 1;
                    break;
                case N:
                    x = data[i + 1];
                    y = data[i + 2];
                    addBounds(setPointBounds, x, y, data[i + 3], data[i + 4]);
                    i += 5;
                    break;
                case D:
                case X:
                    x = data[i + 1];
                    y = data[i + 2];
                    addBounds(setPointBounds, x, y, data[i + 3], data[i + 4]);
                    i += (command === D ? 9 : 6);
                    break;
                case G:
                    ellipse$1(null, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], data[i + 7], data[i + 8], tempPointBounds, setEndPoint);
                    i === 0 ? copy$6(setPointBounds, tempPointBounds) : add$1(setPointBounds, tempPointBounds);
                    x = setEndPoint.x;
                    y = setEndPoint.y;
                    i += 9;
                    break;
                case F:
                    x = data[i + 1];
                    y = data[i + 2];
                    radiusX = data[i + 3];
                    radiusY = data[i + 4];
                    addBounds(setPointBounds, x - radiusX, y - radiusY, radiusX * 2, radiusY * 2);
                    x += radiusX;
                    i += 5;
                    break;
                case O:
                    arc(null, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], tempPointBounds, setEndPoint);
                    i === 0 ? copy$6(setPointBounds, tempPointBounds) : add$1(setPointBounds, tempPointBounds);
                    x = setEndPoint.x;
                    y = setEndPoint.y;
                    i += 7;
                    break;
                case P:
                    x = data[i + 1];
                    y = data[i + 2];
                    radius = data[i + 3];
                    addBounds(setPointBounds, x - radius, y - radius, radius * 2, radius * 2);
                    x += radius;
                    i += 4;
                    break;
                case U:
                    arcTo(null, x, y, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], tempPointBounds, setEndPoint);
                    i === 0 ? copy$6(setPointBounds, tempPointBounds) : add$1(setPointBounds, tempPointBounds);
                    x = setEndPoint.x;
                    y = setEndPoint.y;
                    i += 6;
                    break;
                default:
                    debug$9.error(`command: ${command} [index:${i}]`, data);
                    return;
            }
        }
    }
};

const PathCorner = {
    smooth(data, _cornerRadius, _cornerSmoothing) {
        return data;
    }
};

PathHelper.creator = new PathCreator();
PathHelper.parse = PathConvert.parse;
PathHelper.convertToCanvasData = PathConvert.toCanvasData;

const { drawRoundRect } = RectHelper;
function roundRect(drawer) {
    if (drawer && !drawer.roundRect) {
        drawer.roundRect = function (x, y, width, height, cornerRadius) {
            drawRoundRect(this, x, y, width, height, cornerRadius);
        };
    }
}

function canvasPatch(drawer) {
    roundRect(drawer);
}

const debug$8 = Debug.get('TaskProcessor');
class TaskItem {
    constructor(task) {
        this.parallel = true;
        this.time = 1;
        this.id = IncrementId.create(IncrementId.TASK);
        this.task = task;
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.task && !this.isComplete && this.parent.running)
                    yield this.task();
            }
            catch (error) {
                debug$8.error(error);
            }
        });
    }
    complete() {
        this.isComplete = true;
        this.parent = null;
        this.task = null;
    }
    cancel() {
        this.isCancel = true;
        this.complete();
    }
}

class TaskProcessor {
    get total() {
        return this.list.length + this.delayNumber;
    }
    get finishedIndex() {
        return this.isComplete ? 0 : this.index + this.parallelSuccessNumber;
    }
    get remain() {
        return this.isComplete ? this.total : this.total - this.finishedIndex;
    }
    get percent() {
        const { total } = this;
        let totalTime = 0, runTime = 0;
        for (let i = 0; i < total; i++) {
            if (i <= this.finishedIndex) {
                runTime += this.list[i].time;
                if (i === this.finishedIndex)
                    totalTime = runTime;
            }
            else {
                totalTime += this.list[i].time;
            }
        }
        return this.isComplete ? 1 : (runTime / totalTime);
    }
    constructor(config) {
        this.config = { parallel: 6 };
        this.list = [];
        this.running = false;
        this.isComplete = true;
        this.index = 0;
        this.delayNumber = 0;
        if (config)
            DataHelper.assign(this.config, config);
        this.empty();
    }
    add(taskCallback, options) {
        let start, parallel, time, delay;
        const task = new TaskItem(taskCallback);
        task.parent = this;
        if (typeof options === 'number') {
            delay = options;
        }
        else if (options) {
            parallel = options.parallel;
            start = options.start;
            time = options.time;
            delay = options.delay;
        }
        if (time)
            task.time = time;
        if (parallel === false)
            task.parallel = false;
        if (delay === undefined) {
            this.push(task, start);
        }
        else {
            this.delayNumber++;
            setTimeout(() => {
                this.delayNumber--;
                this.push(task, start);
            }, delay);
        }
        this.isComplete = false;
        return task;
    }
    push(task, start) {
        this.list.push(task);
        if (start !== false && !this.timer) {
            this.timer = setTimeout(() => this.start());
        }
    }
    empty() {
        this.index = 0;
        this.parallelSuccessNumber = 0;
        this.list = [];
        this.parallelList = [];
    }
    start() {
        if (!this.running) {
            this.running = true;
            this.isComplete = false;
            this.run();
        }
    }
    pause() {
        clearTimeout(this.timer);
        this.timer = null;
        this.running = false;
    }
    resume() {
        this.start();
    }
    skip() {
        this.index++;
        this.resume();
    }
    stop() {
        this.isComplete = true;
        this.list.forEach(task => { if (!task.isComplete)
            task.cancel(); });
        this.pause();
        this.empty();
    }
    run() {
        if (!this.running)
            return;
        this.setParallelList();
        if (this.parallelList.length > 1) {
            this.runParallelTasks();
        }
        else {
            this.remain ? this.runTask() : this.onComplete();
        }
    }
    runTask() {
        const task = this.list[this.index];
        if (!task) {
            this.nextTask();
            return;
        }
        task.run().then(() => {
            this.onTask(task);
            this.index++;
            this.nextTask();
        }).catch(error => {
            this.onError(error);
        });
    }
    runParallelTasks() {
        this.parallelList.forEach(task => this.runParallelTask(task));
    }
    runParallelTask(task) {
        task.run().then(() => {
            this.onTask(task);
            this.fillParallelTask();
        }).catch(error => {
            this.onParallelError(error);
        });
    }
    nextTask() {
        if (this.total === this.finishedIndex) {
            this.onComplete();
        }
        else {
            this.timer = setTimeout(() => this.run());
        }
    }
    setParallelList() {
        let task;
        this.parallelList = [];
        this.parallelSuccessNumber = 0;
        let end = this.index + this.config.parallel;
        if (end > this.list.length)
            end = this.list.length;
        for (let i = this.index; i < end; i++) {
            task = this.list[i];
            if (task.parallel) {
                this.parallelList.push(task);
            }
            else {
                break;
            }
        }
    }
    fillParallelTask() {
        let task;
        const parallelList = this.parallelList;
        this.parallelSuccessNumber++;
        parallelList.pop();
        const parallelWaitNumber = parallelList.length;
        const nextIndex = this.finishedIndex + parallelWaitNumber;
        if (parallelList.length) {
            if (!this.running)
                return;
            if (nextIndex < this.total) {
                task = this.list[nextIndex];
                if (task && task.parallel) {
                    parallelList.push(task);
                    this.runParallelTask(task);
                }
            }
        }
        else {
            this.index += this.parallelSuccessNumber;
            this.parallelSuccessNumber = 0;
            this.nextTask();
        }
    }
    onComplete() {
        this.stop();
        if (this.config.onComplete)
            this.config.onComplete();
    }
    onTask(task) {
        task.complete();
        if (this.config.onTask)
            this.config.onTask();
    }
    onParallelError(error) {
        this.parallelList.forEach(task => {
            task.parallel = false;
        });
        this.parallelList.length = 0;
        this.parallelSuccessNumber = 0;
        this.onError(error);
    }
    onError(error) {
        this.pause();
        if (this.config.onError)
            this.config.onError(error);
    }
    destroy() {
        this.stop();
    }
}

const ImageManager = {
    map: {},
    recycledList: [],
    tasker: new TaskProcessor(),
    patternTasker: new TaskProcessor(),
    get isComplete() { return I$1.tasker.isComplete && I$1.patternTasker.isComplete; },
    get(config) {
        let image = I$1.map[config.url];
        if (!image) {
            image = Creator.image(config);
            I$1.map[config.url] = image;
        }
        image.use++;
        return image;
    },
    recycle(image) {
        image.use--;
        setTimeout(() => { if (!image.use)
            I$1.recycledList.push(image); });
    },
    clearRecycled() {
        const list = I$1.recycledList;
        if (list.length) {
            list.forEach(image => {
                if (!image.use && image.url) {
                    delete I$1.map[image.url];
                    image.destroy();
                }
            });
            list.length = 0;
        }
    },
    destroy() {
        I$1.map = {};
    }
};
const I$1 = ImageManager;

const { IMAGE, create: create$1 } = IncrementId;
class LeaferImage {
    get url() { return this.config.url; }
    get completed() { return this.ready || !!this.error; }
    constructor(config) {
        this.use = 0;
        this.waitComplete = [];
        this.innerId = create$1(IMAGE);
        this.config = config || { url: '' };
        const { url } = config;
        if (url.startsWith('data:')) {
            if (url.startsWith('data:image/svg'))
                this.isSVG = true;
        }
        else {
            if (url.includes('.svg'))
                this.isSVG = true;
        }
        if (this.config.format === 'svg')
            this.isSVG = true;
    }
    load(onSuccess, onError) {
        if (!this.loading) {
            this.loading = true;
            ImageManager.tasker.add(() => __awaiter(this, void 0, void 0, function* () {
                return yield Platform.origin.loadImage(this.url).then((img) => {
                    this.ready = true;
                    this.width = img.naturalWidth || img.width;
                    this.height = img.naturalHeight || img.height;
                    this.view = img;
                    this.onComplete(true);
                }).catch((e) => {
                    this.error = e;
                    this.onComplete(false);
                });
            }));
        }
        this.waitComplete.push(onSuccess, onError);
        return this.waitComplete.length - 2;
    }
    unload(index, stopEvent) {
        const l = this.waitComplete;
        if (stopEvent) {
            const error = l[index + 1];
            if (error)
                error({ type: 'stop' });
        }
        l[index] = l[index + 1] = undefined;
    }
    onComplete(isSuccess) {
        let odd;
        this.waitComplete.forEach((item, index) => {
            odd = index % 2;
            if (item) {
                if (isSuccess) {
                    if (!odd)
                        item(this);
                }
                else {
                    if (odd)
                        item(this.error);
                }
            }
        });
        this.waitComplete.length = 0;
        this.loading = false;
    }
    getCanvas(width, height, opacity, _filters) {
        width || (width = this.width);
        height || (height = this.height);
        const canvas = Platform.origin.createCanvas(width, height);
        const ctx = canvas.getContext('2d');
        if (opacity)
            ctx.globalAlpha = opacity;
        ctx.drawImage(this.view, 0, 0, width, height);
        return canvas;
    }
    destroy() {
        this.config = { url: '' };
        this.waitComplete.length = 0;
    }
}

class Event {
    constructor(type, target) {
        this.bubbles = false;
        this.type = type;
        if (target)
            this.target = target;
    }
    stopDefault() {
        this.isStopDefault = true;
    }
    stopNow() {
        this.isStopNow = true;
        this.isStop = true;
    }
    stop() {
        this.isStop = true;
    }
}

class ChildEvent extends Event {
    constructor(type, child, parent) {
        super(type, child);
        this.parent = parent;
        this.child = child;
    }
}
ChildEvent.ADD = 'child.add';
ChildEvent.REMOVE = 'child.remove';

class PropertyEvent extends Event {
    constructor(type, target, attrName, oldValue, newValue) {
        super(type, target);
        this.attrName = attrName;
        this.oldValue = oldValue;
        this.newValue = newValue;
    }
}
PropertyEvent.CHANGE = 'property.change';

class ImageEvent extends Event {
    constructor(type, data) {
        super(type);
        Object.assign(this, data);
    }
}
ImageEvent.LOAD = 'image.load';
ImageEvent.LOADED = 'image.loaded';
ImageEvent.ERROR = 'image.error';

class ResizeEvent extends Event {
    get bigger() {
        if (!this.old)
            return true;
        const { width, height } = this.old;
        return this.width >= width && this.height >= height;
    }
    get smaller() {
        return !this.bigger;
    }
    get samePixelRatio() {
        if (!this.old)
            return true;
        return this.pixelRatio === this.old.pixelRatio;
    }
    constructor(size, oldSize) {
        if (typeof size === 'object') {
            super(ResizeEvent.RESIZE);
            Object.assign(this, size);
        }
        else {
            super(size);
        }
        this.old = oldSize;
    }
}
ResizeEvent.RESIZE = 'resize';

class TransformEvent extends Event {
    constructor(type, params) {
        super(type);
        if (params)
            Object.assign(this, params);
    }
}
TransformEvent.START = 'transform.start';
TransformEvent.CHANGE = 'transform.change';
TransformEvent.END = 'transform.end';
TransformEvent.BEFORE_START = 'transform.before_start';
TransformEvent.BEFORE_CHANGE = 'transform.before_change';
TransformEvent.BEFORE_END = 'transform.before_end';

class WatchEvent extends Event {
    constructor(type, data) {
        super(type);
        this.data = data;
    }
}
WatchEvent.REQUEST = 'watch.request';
WatchEvent.DATA = 'watch.data';

class LayoutEvent extends Event {
    constructor(type, data, times) {
        super(type);
        if (data) {
            this.data = data;
            this.times = times;
        }
    }
}
LayoutEvent.CHECK_UPDATE = 'layout.check_update';
LayoutEvent.REQUEST = 'layout.request';
LayoutEvent.START = 'layout.start';
LayoutEvent.BEFORE = 'layout.before';
LayoutEvent.LAYOUT = 'layout.layout';
LayoutEvent.AFTER = 'layout.after';
LayoutEvent.AGAIN = 'layout.again';
LayoutEvent.END = 'layout.end';

class AnimateEvent extends Event {
}
AnimateEvent.FRAME = 'animate.frame';

class RenderEvent extends Event {
    constructor(type, times, bounds, options) {
        super(type);
        if (times)
            this.times = times;
        if (bounds) {
            this.renderBounds = bounds;
            this.renderOptions = options;
        }
    }
}
RenderEvent.REQUEST = 'render.request';
RenderEvent.START = 'render.start';
RenderEvent.BEFORE = 'render.before';
RenderEvent.RENDER = 'render';
RenderEvent.AFTER = 'render.after';
RenderEvent.AGAIN = 'render.again';
RenderEvent.END = 'render.end';

class LeaferEvent extends Event {
}
LeaferEvent.START = 'leafer.start';
LeaferEvent.BEFORE_READY = 'leafer.before_ready';
LeaferEvent.READY = 'leafer.ready';
LeaferEvent.AFTER_READY = 'leafer.after_ready';
LeaferEvent.VIEW_READY = 'leafer.view_ready';
LeaferEvent.VIEW_COMPLETED = 'leafer.view_completed';
LeaferEvent.STOP = 'leafer.stop';
LeaferEvent.RESTART = 'leafer.restart';
LeaferEvent.END = 'leafer.end';

const downKeyMap = {};
const Keyboard = {
    isHoldSpaceKey() {
        return Keyboard.isHold('Space');
    },
    isHold(code) {
        return downKeyMap[code];
    },
    setDownCode(code) {
        if (!downKeyMap[code])
            downKeyMap[code] = true;
    },
    setUpCode(code) {
        downKeyMap[code] = false;
    }
};

const PointerButton = {
    LEFT: 1,
    RIGHT: 2,
    MIDDLE: 4,
    defaultLeft(event) { if (!event.buttons)
        event.buttons = 1; },
    left(event) { return event.buttons === 1; },
    right(event) { return event.buttons === 2; },
    middle(event) { return event.buttons === 4; }
};

class UIEvent extends Event {
    get spaceKey() { return Keyboard.isHoldSpaceKey(); }
    get left() { return PointerButton.left(this); }
    get right() { return PointerButton.right(this); }
    get middle() { return PointerButton.middle(this); }
    constructor(params) {
        super(params.type);
        this.bubbles = true;
        Object.assign(this, params);
    }
    getInner(target) {
        if (!target)
            target = this.current;
        return target.getInnerPoint(this);
    }
    getLocal(target) {
        if (!target)
            target = this.current;
        return target.getLocalPoint(this);
    }
    static changeName(oldName, newName) {
        EventCreator.changeName(oldName, newName);
    }
}

function defineKey(target, key, descriptor) {
    Object.defineProperty(target, key, descriptor);
}
function getDescriptor(object, name) {
    return Object.getOwnPropertyDescriptor(object, name);
}
function getNames(object) {
    return Object.getOwnPropertyNames(object);
}

function aliasType(name) {
    return (target, key) => {
        defineKey(target, key, {
            get() { return this.__getAttr(name); },
            set(value) {
                this.__setAttr(name, value);
            }
        });
    };
}
function defineLeafAttr(target, key, defaultValue, mergeDescriptor) {
    const defaultDescriptor = {
        get() { return this.__getAttr(key); },
        set(value) { this.__setAttr(key, value); },
        configurable: true,
        enumerable: true
    };
    defineKey(target, key, Object.assign(defaultDescriptor, mergeDescriptor || {}));
    defineDataProcessor(target, key, defaultValue);
}
function dataType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue);
    };
}
function positionType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.positionChanged || this.__layout.positionChange();
            }
        });
    };
}
function scaleType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.scaleChanged || this.__layout.scaleChange();
            }
        });
    };
}
function rotationType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.rotationChanged || this.__layout.rotationChange();
            }
        });
    };
}
function boundsType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.boxChanged || this.__layout.boxChange();
                if (this.__.around)
                    this.__layout.positionChanged || this.__layout.positionChange();
            }
        });
    };
}
const pathType = boundsType;
function affectStrokeBoundsType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.strokeChanged || this.__layout.strokeChange();
            }
        });
    };
}
const strokeType = affectStrokeBoundsType;
function affectRenderBoundsType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.renderChanged || this.__layout.renderChange();
            }
        });
    };
}
function surfaceType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.surfaceChanged || this.__layout.surfaceChange();
            }
        });
    };
}
function opacityType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.opacityChanged || this.__layout.opacityChange();
            }
        });
    };
}
function sortType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.surfaceChanged || this.__layout.surfaceChange();
                this.waitParent(() => { this.parent.__layout.childrenSortChange(); });
            }
        });
    };
}
function maskType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.boxChanged || this.__layout.boxChange();
                this.waitParent(() => { this.parent.__updateMask(value); });
            }
        });
    };
}
function eraserType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.waitParent(() => { this.parent.__updateEraser(value); });
            }
        });
    };
}
function hitType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                if (Debug.showHitView) {
                    this.__layout.surfaceChanged || this.__layout.surfaceChange();
                }
                if (this.leafer)
                    this.leafer.updateCursor();
            }
        });
    };
}
function cursorType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                if (this.leafer)
                    this.leafer.updateCursor();
            }
        });
    };
}
function dataProcessor(processor) {
    return (target, _key) => {
        defineKey(target, '__DataProcessor', {
            get() { return processor; }
        });
    };
}
function layoutProcessor(processor) {
    return (target, _key) => {
        defineKey(target, '__LayoutProcessor', {
            get() { return processor; }
        });
    };
}
function getSetMethodName(key) {
    return 'set' + key.charAt(0).toUpperCase() + key.slice(1);
}
function setDefaultValue(target, key, defaultValue) {
    defineDataProcessor(target.prototype, key, defaultValue);
}
function defineDataProcessor(target, key, defaultValue) {
    const data = target.__DataProcessor.prototype;
    const computedKey = '_' + key;
    const setMethodName = getSetMethodName(key);
    const property = {
        get() {
            const v = this[computedKey];
            return v === undefined ? defaultValue : v;
        },
        set(value) {
            this[computedKey] = value;
        },
        configurable: true,
        enumerable: true
    };
    if (defaultValue === undefined) {
        property.get = function () { return this[computedKey]; };
    }
    else if (key === 'width') {
        property.get = function () {
            const v = this[computedKey];
            return v === undefined ? (this.__naturalWidth || defaultValue) : v;
        };
    }
    else if (key === 'height') {
        property.get = function () {
            const v = this[computedKey];
            return v === undefined ? (this.__naturalHeight || defaultValue) : v;
        };
    }
    const descriptor = getDescriptor(data, key);
    if (descriptor && descriptor.set)
        property.set = descriptor.set;
    if (data[setMethodName]) {
        property.set = data[setMethodName];
        delete data[setMethodName];
    }
    Object.defineProperty(data, key, property);
}

const debug$7 = new Debug('rewrite');
const list$1 = [];
const excludeNames = ['destroy', 'constructor'];
function rewrite(method) {
    return (target, key) => {
        list$1.push({ name: target.constructor.name + '.' + key, run: () => { target[key] = method; } });
    };
}
function rewriteAble() {
    return (_target) => {
        doRewrite();
    };
}
function doRewrite(error) {
    if (list$1.length) {
        list$1.forEach(item => {
            if (error)
                debug$7.error(item.name, '需在Class上装饰@rewriteAble()');
            item.run();
        });
        list$1.length = 0;
    }
}
setTimeout(() => doRewrite(true));
function useModule(module, exclude) {
    return (target) => {
        const names = module.prototype ? getNames(module.prototype) : Object.keys(module);
        names.forEach(name => {
            if (!excludeNames.includes(name) && (!exclude || !exclude.includes(name))) {
                if (module.prototype) {
                    const d = getDescriptor(module.prototype, name);
                    if (d.writable)
                        target.prototype[name] = module.prototype[name];
                }
                else {
                    target.prototype[name] = module[name];
                }
            }
        });
    };
}

function registerUI() {
    return (target) => {
        UICreator.register(target);
    };
}
function registerUIEvent() {
    return (target) => {
        EventCreator.register(target);
    };
}

let PointerEvent = class PointerEvent extends UIEvent {
};
PointerEvent.POINTER = 'pointer';
PointerEvent.BEFORE_DOWN = 'pointer.before_down';
PointerEvent.BEFORE_MOVE = 'pointer.before_move';
PointerEvent.BEFORE_UP = 'pointer.before_up';
PointerEvent.DOWN = 'pointer.down';
PointerEvent.MOVE = 'pointer.move';
PointerEvent.UP = 'pointer.up';
PointerEvent.OVER = 'pointer.over';
PointerEvent.OUT = 'pointer.out';
PointerEvent.ENTER = 'pointer.enter';
PointerEvent.LEAVE = 'pointer.leave';
PointerEvent.TAP = 'tap';
PointerEvent.DOUBLE_TAP = 'double_tap';
PointerEvent.CLICK = 'click';
PointerEvent.DOUBLE_CLICK = 'double_click';
PointerEvent.LONG_PRESS = 'long_press';
PointerEvent.LONG_TAP = 'long_tap';
PointerEvent = __decorate([
    registerUIEvent()
], PointerEvent);

const move = {};
let DragEvent = class DragEvent extends PointerEvent {
    getInnerMove(target, total) {
        if (!target)
            target = this.current;
        this.assignMove(total);
        return target.getInnerPoint(move, null, true);
    }
    getLocalMove(target, total) {
        if (!target)
            target = this.current;
        this.assignMove(total);
        return target.getLocalPoint(move, null, true);
    }
    getInnerTotal(target) {
        return this.getInnerMove(target, true);
    }
    getLocalTotal(target) {
        return this.getLocalMove(target, true);
    }
    assignMove(total) {
        move.x = total ? this.totalX : this.moveX;
        move.y = total ? this.totalY : this.moveY;
    }
};
DragEvent.BEFORE_DRAG = 'drag.before_drag';
DragEvent.START = 'drag.start';
DragEvent.DRAG = 'drag';
DragEvent.END = 'drag.end';
DragEvent.OVER = 'drag.over';
DragEvent.OUT = 'drag.out';
DragEvent.ENTER = 'drag.enter';
DragEvent.LEAVE = 'drag.leave';
DragEvent = __decorate([
    registerUIEvent()
], DragEvent);

var DropEvent_1;
let DropEvent = DropEvent_1 = class DropEvent extends PointerEvent {
    static setList(data) {
        DropEvent_1.dragList = data instanceof LeafList ? data : new LeafList(data);
    }
    static setData(data) {
        this.dragData = data;
    }
};
DropEvent.DROP = 'drop';
DropEvent = DropEvent_1 = __decorate([
    registerUIEvent()
], DropEvent);

let MoveEvent = class MoveEvent extends DragEvent {
};
MoveEvent.BEFORE_MOVE = 'move.before_move';
MoveEvent.START = 'move.start';
MoveEvent.MOVE = 'move';
MoveEvent.END = 'move.end';
MoveEvent = __decorate([
    registerUIEvent()
], MoveEvent);

let RotateEvent = class RotateEvent extends UIEvent {
};
RotateEvent.BEFORE_ROTATE = 'rotate.before_rotate';
RotateEvent.START = 'rotate.start';
RotateEvent.ROTATE = 'rotate';
RotateEvent.END = 'rotate.end';
RotateEvent = __decorate([
    registerUIEvent()
], RotateEvent);

let SwipeEvent = class SwipeEvent extends DragEvent {
};
SwipeEvent.SWIPE = 'swipe';
SwipeEvent.LEFT = 'swipe.left';
SwipeEvent.RIGHT = 'swipe.right';
SwipeEvent.UP = 'swipe.up';
SwipeEvent.DOWN = 'swipe.down';
SwipeEvent = __decorate([
    registerUIEvent()
], SwipeEvent);

let ZoomEvent = class ZoomEvent extends UIEvent {
};
ZoomEvent.BEFORE_ZOOM = 'zoom.before_zoom';
ZoomEvent.START = 'zoom.start';
ZoomEvent.ZOOM = 'zoom';
ZoomEvent.END = 'zoom.end';
ZoomEvent = __decorate([
    registerUIEvent()
], ZoomEvent);

let KeyEvent = class KeyEvent extends UIEvent {
};
KeyEvent.DOWN = 'key.down';
KeyEvent.HOLD = 'key.hold';
KeyEvent.UP = 'key.up';
KeyEvent = __decorate([
    registerUIEvent()
], KeyEvent);

class Transformer {
    constructor(interaction) {
        this.interaction = interaction;
    }
    move(data) {
        const { interaction } = this;
        if (!this.moveData) {
            const { path } = interaction.selector.getByPoint(data, interaction.hitRadius);
            data.path = path;
            this.moveData = Object.assign(Object.assign({}, data), { moveX: 0, moveY: 0 });
            interaction.emit(MoveEvent.START, this.moveData);
        }
        data.path = this.moveData.path;
        interaction.emit(MoveEvent.BEFORE_MOVE, data);
        interaction.emit(MoveEvent.MOVE, data);
        this.transformEndWait();
    }
    zoom(data) {
        const { interaction } = this;
        if (!this.zoomData) {
            const { path } = interaction.selector.getByPoint(data, interaction.hitRadius);
            data.path = path;
            this.zoomData = Object.assign(Object.assign({}, data), { scale: 1 });
            interaction.emit(ZoomEvent.START, this.zoomData);
        }
        data.path = this.zoomData.path;
        interaction.emit(ZoomEvent.BEFORE_ZOOM, data);
        interaction.emit(ZoomEvent.ZOOM, data);
        this.transformEndWait();
    }
    rotate(data) {
        const { interaction } = this;
        if (!this.rotateData) {
            const { path } = interaction.selector.getByPoint(data, interaction.hitRadius);
            data.path = path;
            this.rotateData = Object.assign(Object.assign({}, data), { rotation: 0 });
            interaction.emit(RotateEvent.START, this.rotateData);
        }
        data.path = this.rotateData.path;
        interaction.emit(RotateEvent.BEFORE_ROTATE, data);
        interaction.emit(RotateEvent.ROTATE, data);
        this.transformEndWait();
    }
    transformEndWait() {
        clearTimeout(this.transformTimer);
        this.transformTimer = setTimeout(() => {
            this.transformEnd();
        }, this.interaction.config.pointer.transformTime);
    }
    transformEnd() {
        this.moveEnd();
        this.zoomEnd();
        this.rotateEnd();
        this.transformMode = null;
    }
    moveEnd() {
        if (this.moveData) {
            this.interaction.emit(MoveEvent.END, this.moveData);
            this.moveData = null;
        }
    }
    zoomEnd() {
        if (this.zoomData) {
            this.interaction.emit(ZoomEvent.END, this.zoomData);
            this.zoomData = null;
        }
    }
    rotateEnd() {
        if (this.rotateData) {
            this.interaction.emit(RotateEvent.END, this.rotateData);
            this.rotateData = null;
        }
    }
    destroy() {
        this.zoomData = this.moveData = this.rotateData = null;
    }
}

const { copy: copy$5, translate: translate$2, toInnerPoint: toInnerPoint$1, scaleOfOuter: scaleOfOuter$3, rotateOfOuter: rotateOfOuter$3, skewOfOuter } = MatrixHelper;
const matrix = {};
const LeafHelper = {
    updateAllWorldMatrix(leaf) {
        leaf.__updateWorldMatrix();
        if (leaf.isBranch) {
            const { children } = leaf;
            for (let i = 0, len = children.length; i < len; i++) {
                updateAllWorldMatrix$2(children[i]);
            }
        }
    },
    updateAllWorldOpacity(leaf) {
        leaf.__updateWorldOpacity();
        if (leaf.isBranch) {
            const { children } = leaf;
            for (let i = 0, len = children.length; i < len; i++) {
                updateAllWorldOpacity$1(children[i]);
            }
        }
    },
    updateAllChange(leaf) {
        updateAllWorldOpacity$1(leaf);
        leaf.__updateChange();
        if (leaf.isBranch) {
            const { children } = leaf;
            for (let i = 0, len = children.length; i < len; i++) {
                updateAllChange$1(children[i]);
            }
        }
    },
    worldHittable(t) {
        if (!t.__.hittable)
            return false;
        let { parent } = t;
        while (parent) {
            if (!parent.__.hittable || !parent.__.hitChildren)
                return false;
            parent = parent.parent;
        }
        return true;
    },
    moveWorld(t, x, y) {
        t.__layout.checkUpdate();
        const local = { x, y };
        if (t.parent)
            toInnerPoint$1(t.parent.__world, local, local, true);
        L.moveLocal(t, local.x, local.y);
    },
    moveLocal(t, x, y = 0) {
        t.x += x;
        t.y += y;
    },
    zoomOfWorld(t, origin, scaleX, scaleY, moveLayer) {
        t.__layout.checkUpdate();
        const local = t.parent ? PointHelper.tempToInnerOf(origin, t.parent.__world) : origin;
        this.zoomOfLocal(t, local, scaleX, scaleY, moveLayer);
    },
    zoomOfLocal(t, origin, scaleX, scaleY = scaleX, moveLayer) {
        copy$5(matrix, t.__local);
        if (moveLayer)
            translate$2(matrix, moveLayer.x, moveLayer.y);
        scaleOfOuter$3(matrix, origin, scaleX, scaleY);
        if (!moveLayer)
            moveLayer = t;
        moveLayer.x += matrix.e - t.__local.e;
        moveLayer.y += matrix.f - t.__local.f;
        t.scaleX *= scaleX;
        t.scaleY *= scaleY;
    },
    rotateOfWorld(t, origin, angle, moveLayer) {
        t.__layout.checkUpdate();
        const local = t.parent ? PointHelper.tempToInnerOf(origin, t.parent.__world) : origin;
        this.rotateOfLocal(t, local, angle, moveLayer);
    },
    rotateOfLocal(t, origin, angle, moveLayer) {
        copy$5(matrix, t.__local);
        if (moveLayer)
            translate$2(matrix, moveLayer.x, moveLayer.y);
        rotateOfOuter$3(matrix, origin, angle);
        if (!moveLayer)
            moveLayer = t;
        moveLayer.x += matrix.e - t.__local.e;
        moveLayer.y += matrix.f - t.__local.f;
        t.rotation = MathHelper.formatRotation(t.rotation + angle);
    },
    skewOfWorld(t, origin, skewX, skewY, moveLayer) {
        t.__layout.checkUpdate();
        const local = t.parent ? PointHelper.tempToInnerOf(origin, t.parent.__world) : origin;
        this.skewOfLocal(t, local, skewX, skewY, moveLayer);
    },
    skewOfLocal(t, origin, skewX, skewY, moveLayer) {
        copy$5(matrix, t.__local);
        if (moveLayer)
            translate$2(matrix, moveLayer.x, moveLayer.y);
        skewOfOuter(matrix, origin, skewX, skewY);
        if (!moveLayer)
            moveLayer = t;
        moveLayer.x = matrix.e - t.__local.e;
        moveLayer.y = matrix.f - t.__local.f;
        t.skewX = MathHelper.formatSkew(t.skewX + skewX);
        t.skewY = MathHelper.formatSkew(t.skewY + skewY);
    },
    drop(t, parent) {
        const position = { x: t.x, y: t.y };
        t.localToWorld(position);
        parent.worldToInner(position);
        t.set(position);
        parent.add(t);
    }
};
const L = LeafHelper;
const { updateAllWorldMatrix: updateAllWorldMatrix$2, updateAllWorldOpacity: updateAllWorldOpacity$1, updateAllChange: updateAllChange$1 } = L;

const LeafBoundsHelper = {
    worldBounds(target) {
        return target.__world;
    },
    localBoxBounds(target) {
        return target.__.isEraser ? null : target.__local;
    },
    localEventBounds(target) {
        return target.__.isEraser ? null : target.__layout.localStrokeBounds;
    },
    localRenderBounds(target) {
        return target.__.isEraser ? null : target.__layout.localRenderBounds;
    },
    maskLocalBoxBounds(target) {
        return target.__.isMask ? target.__local : null;
    },
    maskLocalEventBounds(target) {
        return target.__.isMask ? target.__layout.localStrokeBounds : null;
    },
    maskLocalRenderBounds(target) {
        return target.__.isMask ? target.__layout.localRenderBounds : null;
    }
};

const BranchHelper = {
    sort(a, b) {
        return (a.__.zIndex === b.__.zIndex) ? (a.__tempNumber - b.__tempNumber) : (a.__.zIndex - b.__.zIndex);
    },
    pushAllChildBranch(branch, pushList) {
        branch.__tempNumber = 1;
        if (branch.__.__childBranchNumber) {
            const { children } = branch;
            for (let i = 0, len = children.length; i < len; i++) {
                branch = children[i];
                if (branch.isBranch) {
                    branch.__tempNumber = 1;
                    pushList.push(branch);
                    pushAllChildBranch$1(branch, pushList);
                }
            }
        }
    },
    pushAllParent(leaf, pushList) {
        const { keys } = pushList;
        if (keys) {
            while (leaf.parent) {
                if (keys[leaf.parent.innerId] === undefined) {
                    pushList.push(leaf.parent);
                    leaf = leaf.parent;
                }
                else {
                    break;
                }
            }
        }
        else {
            while (leaf.parent) {
                pushList.push(leaf.parent);
                leaf = leaf.parent;
            }
        }
    },
    pushAllBranchStack(branch, pushList) {
        let start = pushList.length;
        const { children } = branch;
        for (let i = 0, len = children.length; i < len; i++) {
            if (children[i].isBranch) {
                pushList.push(children[i]);
            }
        }
        for (let i = start, len = pushList.length; i < len; i++) {
            pushAllBranchStack$1(pushList[i], pushList);
        }
    },
    updateWorldBoundsByBranchStack(branchStack) {
        let branch;
        for (let i = branchStack.length - 1; i > -1; i--) {
            branch = branchStack[i];
            for (let j = 0, len = branch.children.length; j < len; j++) {
                branch.children[j].__updateWorldBounds();
            }
        }
        branch.__updateWorldBounds();
    }
};
const { pushAllChildBranch: pushAllChildBranch$1, pushAllBranchStack: pushAllBranchStack$1 } = BranchHelper;

const WaitHelper = {
    run(wait) {
        for (let i = 0, len = wait.length; i < len; i++) {
            wait[i]();
        }
        wait.length = 0;
    }
};

const InteractionHelper = {
    getMoveEventData(center, move, event) {
        return Object.assign(Object.assign({}, event), { x: center.x, y: center.y, moveX: move.x, moveY: move.y });
    },
    getRotateEventData(center, angle, event) {
        return Object.assign(Object.assign({}, event), { x: center.x, y: center.y, rotation: angle });
    },
    getZoomEventData(center, scale, event) {
        return Object.assign(Object.assign({}, event), { x: center.x, y: center.y, scale });
    },
    getDragEventData(startPoint, lastPoint, event) {
        return Object.assign(Object.assign({}, event), { x: event.x, y: event.y, moveX: event.x - lastPoint.x, moveY: event.y - lastPoint.y, totalX: event.x - startPoint.x, totalY: event.y - startPoint.y });
    },
    getDropEventData(event, list, data) {
        return Object.assign(Object.assign({}, event), { list,
            data });
    },
    getSwipeDirection(angle) {
        if (angle < -45 && angle > -135) {
            return SwipeEvent.UP;
        }
        else if (angle > 45 && angle < 135) {
            return SwipeEvent.DOWN;
        }
        else if (angle <= 45 && angle >= -45) {
            return SwipeEvent.RIGHT;
        }
        else {
            return SwipeEvent.LEFT;
        }
    },
    getSwipeEventData(startPoint, lastDragData, event) {
        return Object.assign(Object.assign({}, event), { moveX: lastDragData.moveX, moveY: lastDragData.moveY, totalX: event.x - startPoint.x, totalY: event.y - startPoint.y, type: I.getSwipeDirection(PointHelper.getAngle(startPoint, event)) });
    },
    getBase(e) {
        return {
            altKey: e.altKey,
            ctrlKey: e.ctrlKey,
            shiftKey: e.shiftKey,
            metaKey: e.metaKey,
            buttons: e.buttons === undefined ? 1 : e.buttons,
            origin: e
        };
    },
    pathHasEventType(path, type) {
        const { list } = path;
        for (let i = 0, len = list.length; i < len; i++) {
            if (list[i].hasEvent(type))
                return true;
        }
        return false;
    },
    filterPathByEventType(path, type) {
        const find = new LeafList();
        const { list } = path;
        for (let i = 0, len = list.length; i < len; i++) {
            if (list[i].hasEvent(type))
                find.push(list[i]);
        }
        return find;
    }
};
const I = InteractionHelper;

const { getDragEventData, getDropEventData, getSwipeEventData, filterPathByEventType } = InteractionHelper;
class Dragger {
    constructor(interaction) {
        this.interaction = interaction;
    }
    setDragData(data) {
        this.dragData = getDragEventData(data, data, data);
    }
    getDragList() {
        return this.dragging ? DropEvent.dragList || this.dragList : null;
    }
    checkDrag(data, canDrag) {
        const { interaction } = this;
        const { downData } = interaction;
        if (this.moving && !(PointerButton.middle(data) || PointerButton.left(data))) {
            interaction.pointerCancel();
            return;
        }
        const { dragData } = this;
        if (!this.moving) {
            const moveOnDragEmpty = interaction.config.move.dragEmpty && downData.target.isLeafer;
            this.moving = (PointerButton.middle(data) || interaction.moveMode || moveOnDragEmpty) && canDrag;
            if (this.moving)
                interaction.emit(MoveEvent.START, dragData);
        }
        if (!this.moving) {
            this.dragStart(data, canDrag);
        }
        const { path, throughPath } = downData;
        this.dragData = getDragEventData(downData, dragData, data);
        if (throughPath)
            this.dragData.throughPath = throughPath;
        this.dragData.path = path;
        if (this.moving) {
            interaction.emit(MoveEvent.BEFORE_MOVE, this.dragData);
            interaction.emit(MoveEvent.MOVE, this.dragData);
        }
        else if (this.dragging) {
            this.dragDragableList();
            interaction.emit(DragEvent.BEFORE_DRAG, this.dragData);
            interaction.emit(DragEvent.DRAG, this.dragData);
        }
    }
    dragStart(data, canDrag) {
        if (!this.dragging) {
            this.dragging = PointerButton.left(data) && canDrag;
            if (this.dragging) {
                this.interaction.emit(DragEvent.START, this.dragData);
                this.getDragableList(this.dragData.path);
                this.dragList = filterPathByEventType(this.dragData.path, DragEvent.DRAG);
                if (!this.dragList.length && this.dragableList)
                    this.dragList.pushList(this.dragableList);
            }
        }
    }
    getDragableList(path) {
        let leaf;
        for (let i = 0, len = path.length; i < len; i++) {
            leaf = path.list[i];
            if (leaf.__.draggable && leaf.__.hitSelf) {
                this.dragableList = [leaf];
                break;
            }
        }
    }
    dragDragableList() {
        const { running } = this.interaction;
        if (this.dragableList && running) {
            const { moveX, moveY } = this.dragData;
            this.dragableList.forEach(leaf => {
                LeafHelper.moveWorld(leaf, moveX, moveY);
            });
        }
    }
    dragOverOrOut(data) {
        const { interaction } = this;
        const { dragOverPath } = this;
        const { path } = data;
        if (dragOverPath) {
            if (path.indexAt(0) !== dragOverPath.indexAt(0)) {
                interaction.emit(DragEvent.OUT, data, dragOverPath);
                interaction.emit(DragEvent.OVER, data, path);
            }
        }
        else {
            interaction.emit(DragEvent.OVER, data, path);
        }
        this.dragOverPath = path;
    }
    dragEnterOrLeave(data) {
        const { interaction } = this;
        const { dragEnterPath } = this;
        const { path } = data;
        interaction.emit(DragEvent.LEAVE, data, dragEnterPath, path);
        interaction.emit(DragEvent.ENTER, data, path, dragEnterPath);
        this.dragEnterPath = path;
    }
    dragEnd(data) {
        const { interaction } = this;
        const { downData } = interaction;
        if (!downData)
            return;
        const { path, throughPath } = downData;
        const endDragData = getDragEventData(downData, data, data);
        if (throughPath)
            endDragData.throughPath = throughPath;
        endDragData.path = path;
        if (this.moving)
            interaction.emit(MoveEvent.END, endDragData);
        if (this.dragging) {
            interaction.emit(DragEvent.END, endDragData);
            this.swipe(data, endDragData);
            this.drop(data);
        }
        this.autoMoveCancel();
        this.dragReset();
    }
    swipe(data, endDragData) {
        const { interaction } = this;
        const { downData } = interaction;
        if (PointHelper.getDistance(downData, data) > interaction.config.pointer.swipeDistance) {
            const swipeData = getSwipeEventData(downData, this.dragData, endDragData);
            this.interaction.emit(swipeData.type, swipeData);
        }
    }
    drop(data) {
        const dropData = getDropEventData(data, this.getDragList(), DropEvent.dragData);
        dropData.path = this.dragEnterPath;
        this.interaction.emit(DropEvent.DROP, dropData);
        this.interaction.emit(DragEvent.LEAVE, data, this.dragEnterPath);
    }
    dragReset() {
        DropEvent.dragList = null;
        this.dragList = null;
        this.dragableList = null;
        this.dragData = null;
        this.dragOverPath = null;
        this.dragEnterPath = null;
        this.dragging = null;
        this.moving = null;
    }
    checkDragOut(data) {
        const { interaction } = this;
        this.autoMoveCancel();
        if (this.dragging && !interaction.shrinkCanvasBounds.hitPoint(data))
            this.autoMoveOnDragOut(data);
    }
    autoMoveOnDragOut(data) {
        const { interaction } = this;
        const { downData } = interaction;
        const { autoDistance, dragOut } = interaction.config.move;
        if (!dragOut || !autoDistance)
            return;
        const bounds = interaction.shrinkCanvasBounds;
        const { x, y } = bounds;
        const right = BoundsHelper.right(bounds);
        const bottom = BoundsHelper.bottom(bounds);
        const moveX = data.x < x ? autoDistance : (right < data.x ? -autoDistance : 0);
        const moveY = data.y < y ? autoDistance : (bottom < data.y ? -autoDistance : 0);
        let totalX = 0, totalY = 0;
        this.autoMoveTimer = setInterval(() => {
            totalX += moveX;
            totalY += moveY;
            PointHelper.move(downData, moveX, moveY);
            PointHelper.move(this.dragData, moveX, moveY);
            interaction.move(Object.assign(Object.assign({}, data), { moveX, moveY, totalX, totalY }));
            interaction.pointerMoveReal(data);
        }, 10);
    }
    autoMoveCancel() {
        if (this.autoMoveTimer) {
            clearInterval(this.autoMoveTimer);
            this.autoMoveTimer = 0;
        }
    }
    destroy() {
        this.dragReset();
    }
}

function emit$1(type, data, path, excludePath) {
    if (!path && !data.path)
        return;
    let leaf;
    data.type = type;
    if (path) {
        data = Object.assign(Object.assign({}, data), { path });
    }
    else {
        path = data.path;
    }
    data.target = path.indexAt(0);
    for (let i = path.length - 1; i > -1; i--) {
        leaf = path.list[i];
        if (emitEvent(leaf, type, data, true, excludePath))
            return;
        if (leaf.isApp)
            emitAppChildren(leaf, type, data, true, excludePath);
    }
    for (let i = 0, len = path.length; i < len; i++) {
        leaf = path.list[i];
        if (leaf.isApp)
            emitAppChildren(leaf, type, data, false, excludePath);
        if (emitEvent(leaf, type, data, false, excludePath))
            return;
    }
}
const allowTypes = ['move', 'zoom', 'rotate', 'key'];
function emitAppChildren(leaf, type, data, capture, excludePath) {
    if (allowTypes.some(name => type.startsWith(name)) && leaf.__.hitChildren && !exclude(leaf, excludePath)) {
        let child;
        for (let i = 0, len = leaf.children.length; i < len; i++) {
            child = leaf.children[i];
            if (!data.path.has(child) && child.__.hittable)
                emitEvent(child, type, data, capture, excludePath);
        }
    }
}
function emitEvent(leaf, type, data, capture, excludePath) {
    if (leaf.destroyed)
        return true;
    if (leaf.__.hitSelf && leaf.hasEvent(type, capture) && !exclude(leaf, excludePath)) {
        data.phase = capture ? 1 : ((leaf === data.target) ? 2 : 3);
        const event = EventCreator.get(type, data);
        leaf.emitEvent(event, capture);
        if (event.isStop)
            return true;
    }
    return false;
}
function exclude(leaf, excludePath) {
    return excludePath && excludePath.has(leaf);
}

const MultiTouchHelper = {
    getData(list) {
        const a = list[0];
        const b = list[1];
        const lastCenter = PointHelper.getCenter(a.from, b.from);
        const center = PointHelper.getCenter(a.to, b.to);
        const move = { x: center.x - lastCenter.x, y: center.y - lastCenter.y };
        const lastDistance = PointHelper.getDistance(a.from, b.from);
        const distance = PointHelper.getDistance(a.to, b.to);
        const scale = distance / lastDistance;
        const angle = PointHelper.getChangeAngle(a.from, b.from, a.to, b.to);
        return { move, scale, angle, center };
    }
};

const { pathHasEventType, getMoveEventData: getMoveEventData$1, getZoomEventData: getZoomEventData$1, getRotateEventData: getRotateEventData$1 } = InteractionHelper;
class InteractionBase {
    get dragging() { return this.dragger.dragging; }
    get moveMode() { return (Keyboard.isHoldSpaceKey() && this.config.move.holdSpaceKey) || (this.downData && PointerButton.middle(this.downData)); }
    get hitRadius() { return this.config.pointer.hitRadius; }
    constructor(target, canvas, selector, userConfig) {
        this.config = {
            wheel: {
                zoomMode: false,
                zoomSpeed: 0.5,
                moveSpeed: 0.5,
                rotateSpeed: 0.5,
                delta: Platform.os === 'Windows' ? { x: 150 / 4, y: 150 / 4 } : { x: 80 / 4, y: 8.0 },
                preventDefault: true
            },
            pointer: {
                hitRadius: 5,
                through: false,
                tapTime: 120,
                longPressTime: 800,
                transformTime: 500,
                dragHover: true,
                dragDistance: 2,
                swipeDistance: 20,
                ignoreMove: false
            },
            cursor: {}
        };
        this.tapCount = 0;
        this.downKeyMap = {};
        this.target = target;
        this.canvas = canvas;
        this.selector = selector;
        this.defaultPath = new LeafList(target);
        this.transformer = new Transformer(this);
        this.dragger = new Dragger(this);
        if (userConfig)
            this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
    }
    start() {
        this.running = true;
    }
    stop() {
        this.running = false;
    }
    receive(_event) { }
    pointerDown(data, useDefaultPath) {
        if (!data)
            data = this.hoverData;
        if (!data)
            return;
        PointerButton.defaultLeft(data);
        this.emit(PointerEvent.BEFORE_DOWN, data, this.defaultPath);
        this.updateDownData(data);
        if (useDefaultPath)
            data.path = this.defaultPath;
        this.emit(PointerEvent.DOWN, data);
        this.downTime = Date.now();
        this.dragger.setDragData(data);
        if (PointerButton.left(data)) {
            this.tapWait();
            this.longPressWait(data);
        }
        this.updateCursor(data);
    }
    pointerMove(data) {
        if (!data)
            data = this.hoverData;
        if (!data)
            return;
        if (this.downData)
            PointerButton.defaultLeft(data);
        const hit = this.canvas.bounds.hitPoint(data);
        if (hit || this.downData) {
            if (hit && !this.downData && PointerButton.left(data))
                this.pointerDown(data, true);
            this.pointerMoveReal(data);
            this.dragger.checkDragOut(data);
        }
    }
    pointerMoveReal(data) {
        this.emit(PointerEvent.BEFORE_MOVE, data, this.defaultPath);
        if (this.downData) {
            const canDrag = PointHelper.getDistance(this.downData, data) > this.config.pointer.dragDistance;
            if (this.waitTap && canDrag)
                this.pointerWaitCancel();
            this.dragger.checkDrag(data, canDrag);
        }
        if (this.dragger.moving || this.config.pointer.ignoreMove)
            return;
        this.updateHoverData(data);
        this.emit(PointerEvent.MOVE, data);
        this.pointerOverOrOut(data);
        this.pointerEnterOrLeave(data);
        if (this.dragger.dragging) {
            this.dragger.dragOverOrOut(data);
            this.dragger.dragEnterOrLeave(data);
        }
        this.updateCursor(data);
    }
    pointerUp(data) {
        if (!data)
            data = this.downData;
        if (!this.downData)
            return;
        PointerButton.defaultLeft(data);
        this.emit(PointerEvent.BEFORE_UP, data, this.defaultPath);
        this.findPath(data);
        this.emit(PointerEvent.UP, data);
        this.emit(PointerEvent.UP, this.downData, undefined, data.path);
        this.touchLeave(data);
        this.tap(data);
        this.dragger.dragEnd(data);
        this.downData = null;
        this.updateCursor(data);
    }
    pointerCancel() {
        this.pointerUp(this.dragger.dragData);
    }
    multiTouch(data, list) {
        const { move, angle, scale, center } = MultiTouchHelper.getData(list);
        this.rotate(getRotateEventData$1(center, angle, data));
        this.zoom(getZoomEventData$1(center, scale, data));
        this.move(getMoveEventData$1(center, move, data));
    }
    move(data) {
        this.transformer.move(data);
    }
    zoom(data) {
        this.transformer.zoom(data);
    }
    rotate(data) {
        this.transformer.rotate(data);
    }
    transformEnd() {
        this.transformer.transformEnd();
    }
    keyDown(data) {
        const { code } = data;
        if (!this.downKeyMap[code]) {
            this.downKeyMap[code] = true;
            Keyboard.setDownCode(code);
            this.emit(KeyEvent.HOLD, data, this.defaultPath);
            if (this.moveMode)
                this.updateCursor();
        }
        this.emit(KeyEvent.DOWN, data, this.defaultPath);
    }
    keyUp(data) {
        const { code } = data;
        this.downKeyMap[code] = false;
        Keyboard.setUpCode(code);
        this.emit(KeyEvent.UP, data, this.defaultPath);
        if (this.cursor === 'grab')
            this.updateCursor();
    }
    pointerOverOrOut(data) {
        if (this.dragger.moving)
            return;
        if (this.dragging && !this.config.pointer.dragHover)
            return;
        const { path } = data;
        if (this.overPath) {
            if (path.indexAt(0) !== this.overPath.indexAt(0)) {
                this.emit(PointerEvent.OUT, data, this.overPath);
                this.emit(PointerEvent.OVER, data, path);
            }
        }
        else {
            this.emit(PointerEvent.OVER, data, path);
        }
        this.overPath = path;
    }
    pointerEnterOrLeave(data) {
        if (this.dragger.moving)
            return;
        if (this.dragging && !this.config.pointer.dragHover)
            return;
        const { path } = data;
        this.emit(PointerEvent.LEAVE, data, this.enterPath, path);
        this.emit(PointerEvent.ENTER, data, path, this.enterPath);
        this.enterPath = path;
    }
    touchLeave(data) {
        if (data.pointerType === 'touch') {
            if (this.enterPath) {
                this.emit(PointerEvent.LEAVE, data);
                if (this.dragger.dragging)
                    this.emit(DropEvent.LEAVE, data);
            }
        }
    }
    tap(data) {
        const { pointer } = this.config;
        const longTap = this.longTap(data);
        if (!pointer.tapMore && longTap)
            return;
        if (!this.waitTap)
            return;
        if (pointer.tapMore)
            this.emitTap(data);
        const useTime = Date.now() - this.downTime;
        const hasDouble = [PointerEvent.DOUBLE_TAP, PointerEvent.DOUBLE_CLICK].some(type => pathHasEventType(data.path, type));
        if (useTime < pointer.tapTime + 50 && hasDouble) {
            this.tapCount++;
            if (this.tapCount === 2) {
                this.tapWaitCancel();
                this.emitDoubleTap(data);
            }
            else {
                clearTimeout(this.tapTimer);
                this.tapTimer = setTimeout(() => {
                    if (!pointer.tapMore) {
                        this.tapWaitCancel();
                        this.emitTap(data);
                    }
                }, pointer.tapTime);
            }
        }
        else {
            if (!pointer.tapMore) {
                this.tapWaitCancel();
                this.emitTap(data);
            }
        }
    }
    findPath(data, options) {
        const { hitRadius, through } = this.config.pointer;
        const find = this.selector.getByPoint(data, hitRadius, options || { through });
        if (find.throughPath)
            data.throughPath = find.throughPath;
        data.path = find.path;
        return find.path;
    }
    updateDownData(data) {
        if (!data)
            data = this.downData;
        if (!data)
            return;
        this.findPath(data);
        this.downData = data;
    }
    updateHoverData(data) {
        if (!data)
            data = this.hoverData;
        if (!data)
            return;
        this.findPath(data, { exclude: this.dragger.getDragList(), name: PointerEvent.MOVE });
        this.hoverData = data;
    }
    updateCursor(data) {
        if (this.config.cursor.stop)
            return;
        if (!data) {
            this.updateHoverData();
            data = this.hoverData;
        }
        if (this.dragger.moving) {
            return this.setCursor('grabbing');
        }
        else if (this.moveMode) {
            return this.setCursor(this.downData ? 'grabbing' : 'grab');
        }
        else if (!data || this.dragger.dragging)
            return;
        let leaf;
        let cursor;
        const { path } = data;
        for (let i = 0, len = path.length; i < len; i++) {
            leaf = path.list[i];
            cursor = leaf.cursor;
            if (cursor)
                break;
        }
        this.setCursor(cursor);
    }
    setCursor(cursor) {
        this.cursor = cursor;
        this.canvas.setCursor(cursor);
    }
    emitTap(data) {
        this.emit(PointerEvent.TAP, data);
        this.emit(PointerEvent.CLICK, data);
    }
    emitDoubleTap(data) {
        this.emit(PointerEvent.DOUBLE_TAP, data);
        this.emit(PointerEvent.DOUBLE_CLICK, data);
    }
    pointerWaitCancel() {
        this.tapWaitCancel();
        this.longPressWaitCancel();
    }
    tapWait() {
        clearTimeout(this.tapTimer);
        this.waitTap = true;
    }
    tapWaitCancel() {
        clearTimeout(this.tapTimer);
        this.waitTap = false;
        this.tapCount = 0;
    }
    longPressWait(data) {
        clearTimeout(this.longPressTimer);
        this.longPressTimer = setTimeout(() => {
            this.longPressed = true;
            this.emit(PointerEvent.LONG_PRESS, data);
        }, this.config.pointer.longPressTime);
    }
    longTap(data) {
        let longTap;
        if (this.longPressed) {
            this.emit(PointerEvent.LONG_TAP, data);
            if (pathHasEventType(data.path, PointerEvent.LONG_TAP))
                longTap = true;
        }
        this.longPressWaitCancel();
        return longTap;
    }
    longPressWaitCancel() {
        clearTimeout(this.longPressTimer);
        this.longPressed = false;
    }
    __onResize() {
        this.shrinkCanvasBounds = new Bounds(this.canvas.bounds);
        this.shrinkCanvasBounds.spread(-2);
    }
    __listenEvents() {
        const { target } = this;
        this.__eventIds = [target.on_(ResizeEvent.RESIZE, this.__onResize, this)];
        target.once(LeaferEvent.READY, () => this.__onResize());
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
        this.__eventIds.length = 0;
    }
    emit(type, data, path, excludePath) {
        if (this.running)
            emit$1(type, data, path, excludePath);
    }
    destroy() {
        if (this.__eventIds.length) {
            this.stop();
            this.__removeListenEvents();
            this.dragger.destroy();
            this.transformer.destroy();
            this.downData = this.overPath = this.enterPath = null;
        }
    }
}

class Cursor {
    static set(name, value) {
        this.custom[name] = value;
    }
    static get(name) {
        return this.custom[name];
    }
}
Cursor.custom = {};

const { toOuterOf: toOuterOf$1 } = BoundsHelper;
class LeafLayout {
    constructor(leaf) {
        this.leaf = leaf;
        this.renderBounds = this.strokeBounds = this.boxBounds = { x: 0, y: 0, width: 0, height: 0 };
        this.localRenderBounds = this.localStrokeBounds = leaf.__local;
        this.boxChange();
        this.positionChange();
    }
    checkUpdate(force) {
        const { leafer } = this.leaf;
        if (leafer) {
            if (leafer.ready) {
                if ((Platform.realtimeLayout || force) && leafer.watcher.changed)
                    leafer.layouter.layout();
            }
            else {
                leafer.start();
            }
        }
        else {
            let root = this.leaf;
            while (root.parent) {
                root = root.parent;
            }
            Platform.layout(root);
        }
    }
    getTransform(locationType) {
        this.checkUpdate();
        return locationType === 'world' ? this.leaf.__world : this.leaf.__local;
    }
    getBounds(type, locationType) {
        this.checkUpdate();
        if (locationType === 'world') {
            switch (type) {
                case 'render':
                    return this.leaf.__world;
                case 'content':
                    if (this.contentBounds)
                        return this.getWorldContentBounds();
                case 'margin':
                case 'box':
                    return this.getWorldBoxBounds();
                case 'margin':
                case 'stroke':
                    return this.getWorldStrokeBounds();
            }
        }
        else if (locationType === 'inner') {
            switch (type) {
                case 'render':
                    return this.renderBounds;
                case 'content':
                    if (this.contentBounds)
                        return this.contentBounds;
                case 'margin':
                case 'box':
                    return this.boxBounds;
                case 'stroke':
                    return this.strokeBounds;
            }
        }
        else {
            switch (type) {
                case 'render':
                    return this.localRenderBounds;
                case 'margin':
                case 'content':
                case 'box':
                    return this.leaf.__local;
                case 'stroke':
                    return this.localStrokeBounds;
            }
        }
    }
    getWorldContentBounds() {
        this._worldContentBounds || (this._worldContentBounds = {});
        toOuterOf$1(this.contentBounds, this.leaf.__world, this._worldContentBounds);
        return this._worldContentBounds;
    }
    getWorldBoxBounds() {
        this._worldBoxBounds || (this._worldBoxBounds = {});
        toOuterOf$1(this.boxBounds, this.leaf.__world, this._worldBoxBounds);
        return this._worldBoxBounds;
    }
    getWorldStrokeBounds() {
        this._worldStrokeBounds || (this._worldStrokeBounds = {});
        toOuterOf$1(this.strokeBounds, this.leaf.__world, this._worldStrokeBounds);
        return this._worldStrokeBounds;
    }
    spreadStrokeCancel() {
        const same = this.renderBounds === this.strokeBounds;
        this.strokeBounds = this.boxBounds;
        this.localStrokeBounds = this.leaf.__local;
        if (same)
            this.spreadRenderCancel();
    }
    spreadRenderCancel() {
        this.renderBounds = this.strokeBounds;
        this.localRenderBounds = this.localStrokeBounds;
    }
    spreadStroke() {
        const { x, y, width, height } = this.strokeBounds;
        this.strokeBounds = { x, y, width, height };
        this.localStrokeBounds = { x, y, width, height };
        if (!this.renderSpread)
            this.spreadRenderCancel();
    }
    spreadRender() {
        const { x, y, width, height } = this.renderBounds;
        this.renderBounds = { x, y, width, height };
        this.localRenderBounds = { x, y, width, height };
    }
    boxChange() {
        this.boxChanged = true;
        this.localBoxChanged || this.localBoxChange();
        this.hitCanvasChanged = true;
    }
    localBoxChange() {
        this.localBoxChanged = true;
        this.boundsChanged = true;
    }
    strokeChange() {
        this.strokeChanged = true;
        this.strokeSpread || (this.strokeSpread = 1);
        this.boundsChanged = true;
        this.hitCanvasChanged = true;
    }
    renderChange() {
        this.renderChanged = true;
        this.renderSpread || (this.renderSpread = 1);
        this.boundsChanged = true;
    }
    positionChange() {
        this.positionChanged = true;
        this.matrixChanged = true;
        this.localBoxChanged || this.localBoxChange();
    }
    scaleChange() {
        this.scaleChanged = true;
        this._scaleOrRotationChange();
    }
    rotationChange() {
        this.rotationChanged = true;
        this.affectRotation = true;
        this._scaleOrRotationChange();
    }
    _scaleOrRotationChange() {
        this.affectScaleOrRotation = true;
        this.matrixChanged = true;
        this.localBoxChanged || this.localBoxChange();
    }
    surfaceChange() {
        this.surfaceChanged = true;
    }
    opacityChange() {
        this.opacityChanged = true;
        this.surfaceChanged || this.surfaceChange();
    }
    childrenSortChange() {
        if (!this.childrenSortChanged) {
            this.childrenSortChanged = true;
            this.leaf.forceUpdate('surface');
        }
    }
    destroy() { }
}

const empty = {};
const LeafEventer = {
    on(type, listener, options) {
        let capture, once;
        if (options) {
            if (typeof options === 'boolean') {
                capture = options;
            }
            else {
                capture = options.capture;
                once = options.once;
            }
        }
        let events;
        const map = __getListenerMap(this, capture, true);
        const typeList = typeof type === 'string' ? type.split(' ') : type;
        const item = once ? { listener, once } : { listener };
        typeList.forEach(type => {
            if (type) {
                events = map[type];
                if (events) {
                    if (events.findIndex(item => item.listener === listener) === -1)
                        events.push(item);
                }
                else {
                    map[type] = [item];
                }
            }
        });
    },
    off(type, listener, options) {
        let capture;
        if (options)
            capture = typeof options === 'boolean' ? options : options.capture;
        let events, index;
        const map = __getListenerMap(this, capture);
        const typeList = typeof type === 'string' ? type.split(' ') : type;
        typeList.forEach(type => {
            if (type) {
                events = map[type];
                if (events) {
                    index = events.findIndex(item => item.listener === listener);
                    if (index > -1)
                        events.splice(index, 1);
                    if (!events.length)
                        delete map[type];
                }
            }
        });
    },
    on_(type, listener, bind, options) {
        if (bind)
            listener = listener.bind(bind);
        this.on(type, listener, options);
        return { type, listener, options };
    },
    off_(id) {
        if (!id)
            return;
        const list = id instanceof Array ? id : [id];
        list.forEach(item => this.off(item.type, item.listener, item.options));
        list.length = 0;
    },
    once(type, listener, capture) {
        this.on(type, listener, { once: true, capture });
    },
    emit(type, event, capture) {
        if (!event && EventCreator.has(type))
            event = EventCreator.get(type, { type, target: this, current: this });
        const map = __getListenerMap(this, capture);
        const list = map[type];
        if (list) {
            let item;
            for (let i = 0, len = list.length; i < len; i++) {
                item = list[i];
                item.listener(event);
                if (item.once) {
                    this.off(type, item.listener, capture);
                    i--, len--;
                }
                if (event && event.isStopNow)
                    break;
            }
        }
    },
    emitEvent(event, capture) {
        event.current = this;
        this.emit(event.type, event, capture);
    },
    hasEvent(type, capture) {
        const { __bubbleMap: b, __captureMap: c } = this;
        if (capture === undefined) {
            return !!((c && c[type]) || (b && b[type]));
        }
        else {
            return !!(capture ? (c && c[type]) : (b && b[type]));
        }
    },
};
function __getListenerMap(eventer, capture, create) {
    if (capture) {
        const { __captureMap: c } = eventer;
        if (c) {
            return c;
        }
        else {
            return create ? eventer.__captureMap = {} : empty;
        }
    }
    else {
        const { __bubbleMap: b } = eventer;
        if (b) {
            return b;
        }
        else {
            return create ? eventer.__bubbleMap = {} : empty;
        }
    }
}

const LeafDataProxy = {
    __setAttr(name, newValue) {
        if (this.leafer && this.leafer.created) {
            if (typeof newValue === 'object' || this.__.__getInput(name) !== newValue) {
                this.__[name] = newValue;
                const { CHANGE } = PropertyEvent;
                const event = new PropertyEvent(CHANGE, this, name, this.__.__get(name), newValue);
                if (this.hasEvent(CHANGE) && !this.isLeafer)
                    this.emitEvent(event);
                this.leafer.emitEvent(event);
            }
        }
        else {
            this.__[name] = newValue;
        }
    },
    __getAttr(name) {
        return this.__.__get(name);
    }
};

const { sin: sin$2, cos: cos$2 } = Math;
const defaultWorld = Object.assign(Object.assign({}, MatrixHelper.defaultMatrix), { scaleX: 1, scaleY: 1, rotation: 0, skewX: 0, skewY: 0 });
const defaultCenter = { x: 0.5, y: 0.5 };
const LeafMatrix = {
    __updateWorldMatrix() {
        const pw = this.parent ? this.parent.__world : defaultWorld;
        const r = this.__local;
        const w = this.__world;
        if (this.__layout.matrixChanged)
            this.__updateLocalMatrix();
        if (this.__layout.affectScaleOrRotation) {
            w.a = r.a * pw.a + r.b * pw.c;
            w.b = r.a * pw.b + r.b * pw.d;
            w.c = r.c * pw.a + r.d * pw.c;
            w.d = r.c * pw.b + r.d * pw.d;
            w.e = r.e * pw.a + r.f * pw.c + pw.e;
            w.f = r.e * pw.b + r.f * pw.d + pw.f;
            const data = this.__;
            w.scaleX = pw.scaleX * data.scaleX;
            w.scaleY = pw.scaleY * data.scaleY;
            w.rotation = pw.rotation + data.rotation;
            w.skewX = pw.skewX + data.skewX;
            w.skewY = pw.skewY + data.skewY;
        }
        else {
            w.a = pw.a;
            w.b = pw.b;
            w.c = pw.c;
            w.d = pw.d;
            w.e = r.e * pw.a + r.f * pw.c + pw.e;
            w.f = r.e * pw.b + r.f * pw.d + pw.f;
            w.scaleX = pw.scaleX;
            w.scaleY = pw.scaleY;
            w.rotation = pw.rotation;
            w.skewX = pw.skewX;
            w.skewY = pw.skewY;
        }
    },
    __updateLocalMatrix() {
        const r = this.__local;
        const layout = this.__layout;
        if (layout.affectScaleOrRotation) {
            const { scaleX, scaleY } = this.__;
            if (layout.affectRotation) {
                if (layout.scaleChanged || layout.rotationChanged) {
                    let { rotation, skewX, skewY } = this.__;
                    if (rotation || skewX || skewY) {
                        rotation *= OneRadian;
                        if (skewX)
                            skewX *= OneRadian;
                        if (skewY)
                            skewY *= OneRadian;
                        r.a = scaleX * cos$2(rotation + skewY);
                        r.b = scaleX * sin$2(rotation + skewY);
                        r.c = scaleY * -sin$2(rotation - skewX);
                        r.d = scaleY * cos$2(rotation - skewX);
                    }
                    else {
                        r.a = scaleX;
                        r.b = 0;
                        r.c = 0;
                        r.d = scaleY;
                        layout.affectRotation = false;
                    }
                    layout.scaleChanged = false;
                    layout.rotationChanged = false;
                }
            }
            else {
                if (layout.scaleChanged) {
                    r.a = scaleX;
                    r.d = scaleY;
                    layout.scaleChanged = false;
                }
            }
        }
        if (layout.positionChanged) {
            r.e = this.__.x;
            r.f = this.__.y;
            const { width, height, around } = this.__;
            if (around && width && height) {
                const origin = (around === 'center') ? defaultCenter : around;
                const offsetX = width * origin.x, offsetY = height * origin.y;
                r.e -= offsetX * r.a + offsetY * r.c;
                r.f -= offsetX * r.b + offsetY * r.d;
            }
            layout.positionChanged = false;
        }
        this.__layout.matrixChanged = false;
    }
};

const { toOuterOf, copyAndSpread: copyAndSpread$1 } = BoundsHelper;
const LeafBounds = {
    __updateWorldBounds() {
        var _a;
        if (this.__layout.boundsChanged) {
            let resize;
            const layout = this.__layout;
            if (layout.boxChanged) {
                this.__updatePath();
                this.__updateRenderPath();
                this.__updateBoxBounds();
                layout.boxChanged = false;
                resize = true;
            }
            if (layout.localBoxChanged) {
                this.__updateLocalBoxBounds();
                layout.localBoxChanged = false;
                if (layout.strokeSpread)
                    layout.strokeChanged = true;
                if (layout.renderSpread)
                    layout.renderChanged = true;
                (_a = this.parent) === null || _a === void 0 ? void 0 : _a.__layout.boxChange();
            }
            if (layout.strokeChanged) {
                layout.strokeSpread = this.__updateStrokeSpread();
                if (layout.strokeSpread) {
                    if (layout.strokeBounds === layout.boxBounds) {
                        layout.spreadStroke();
                    }
                    this.__updateStrokeBounds();
                    this.__updateLocalStrokeBounds();
                }
                else {
                    layout.spreadStrokeCancel();
                }
                layout.strokeChanged = false;
                if (layout.renderSpread)
                    layout.renderChanged = true;
                if (this.parent)
                    this.parent.__layout.strokeChange();
                resize || (resize = true);
            }
            if (layout.renderChanged) {
                layout.renderSpread = this.__updateRenderSpread();
                if (layout.renderSpread) {
                    if (layout.renderBounds === layout.boxBounds || layout.renderBounds === layout.strokeBounds) {
                        layout.spreadRender();
                    }
                    this.__updateRenderBounds();
                    this.__updateLocalRenderBounds();
                }
                else {
                    layout.spreadRenderCancel();
                }
                layout.renderChanged = false;
                if (this.parent)
                    this.parent.__layout.renderChange();
            }
            layout.boundsChanged = false;
            toOuterOf(this.__layout.renderBounds, this.__world, this.__world);
            if (resize)
                this.__onUpdateSize();
        }
        else {
            toOuterOf(this.__layout.renderBounds, this.__world, this.__world);
        }
    },
    __updateLocalBoxBounds() {
        toOuterOf(this.__layout.boxBounds, this.__local, this.__local);
    },
    __updateLocalStrokeBounds() {
        toOuterOf(this.__layout.strokeBounds, this.__local, this.__layout.localStrokeBounds);
    },
    __updateLocalRenderBounds() {
        toOuterOf(this.__layout.renderBounds, this.__local, this.__layout.localRenderBounds);
    },
    __updateBoxBounds() {
        const b = this.__layout.boxBounds;
        const { width, height } = this.__;
        b.x = 0;
        b.y = 0;
        b.width = width;
        b.height = height;
    },
    __updateNaturalSize() {
        const { __: data, __layout: layout } = this;
        data.__naturalWidth = layout.boxBounds.width;
        data.__naturalHeight = layout.boxBounds.height;
        if (this.around) {
            layout.positionChanged = layout.matrixChanged = true;
            this.__updateWorldMatrix();
        }
    },
    __updateStrokeBounds() {
        copyAndSpread$1(this.__layout.strokeBounds, this.__layout.boxBounds, this.__layout.strokeSpread);
    },
    __updateRenderBounds() {
        copyAndSpread$1(this.__layout.renderBounds, this.__layout.strokeBounds, this.__layout.renderSpread);
    },
};

const { toInnerRadiusPointOf, copy: copy$4, setRadius } = PointHelper;
const inner = {};
const LeafHit = {
    __hitWorld(point) {
        if (this.__layout.hitCanvasChanged || !this.__hitCanvas) {
            this.__updateHitCanvas();
            this.__layout.hitCanvasChanged = false;
        }
        if (this.__.hitRadius) {
            copy$4(inner, point), point = inner;
            setRadius(point, this.__.hitRadius);
        }
        toInnerRadiusPointOf(point, this.__world, inner);
        return this.__hit(inner);
    },
    __drawHitPath(canvas) {
        this.__drawRenderPath(canvas);
    }
};

const LeafRender = {
    __render(canvas, options) {
        if (this.__worldOpacity) {
            canvas.setWorld(this.__world, options.matrix);
            canvas.opacity = this.__worldOpacity;
            if (this.__.__single) {
                const tempCanvas = canvas.getSameCanvas(true);
                this.__draw(tempCanvas, options);
                const blendMode = this.__.isEraser ? 'destination-out' : this.__.blendMode;
                if (this.__hasMirror || options.matrix) {
                    canvas.copyWorldByReset(tempCanvas, null, null, blendMode);
                }
                else {
                    canvas.copyWorldToInner(tempCanvas, this.__world, this.__layout.renderBounds, blendMode);
                }
                tempCanvas.recycle();
            }
            else {
                this.__draw(canvas, options);
            }
        }
    },
    __updateWorldOpacity() {
        this.__worldOpacity = this.__.visible ? (this.parent ? this.parent.__worldOpacity * this.__.opacity : this.__.opacity) : 0;
        if (this.__layout.opacityChanged)
            this.__layout.opacityChanged = false;
    }
};

const LeafMask = {
    __updateEraser(value) {
        this.__hasEraser = value ? true : this.children.some(item => item.__.isEraser);
    },
    __updateMask(value) {
        this.__hasMask = value ? true : this.children.some(item => item.__.isMask);
    },
    __renderMask(canvas, content, mask) {
        content.resetTransform();
        content.useMask(mask);
        canvas.resetTransform();
        canvas.opacity = this.__worldOpacity;
        canvas.copyWorld(content);
    },
    __removeMask(child) {
        if (child) {
            child.isMask = false;
            this.remove(child);
        }
        else {
            const { children } = this;
            for (let i = 0, len = children.length; i < len; i++) {
                child = children[i];
                if (child.isMask) {
                    this.__removeMask(child);
                    len--, i--;
                }
            }
        }
    }
};

const BranchRender = {
    __updateChange() {
        const { __layout: layout } = this;
        if (layout.childrenSortChanged) {
            this.__updateSortChildren();
            layout.childrenSortChanged = false;
        }
        this.__.__checkSingle();
    },
    __render(canvas, options) {
        if (this.__worldOpacity) {
            if (this.__.__single) {
                canvas.resetTransform();
                const tempCanvas = canvas.getSameCanvas();
                this.__renderBranch(tempCanvas, options);
                canvas.opacity = this.__worldOpacity;
                const blendMode = this.__.isEraser ? 'destination-out' : this.__.blendMode;
                if (this.__hasMirror || options.matrix) {
                    canvas.copyWorld(tempCanvas, null, null, blendMode);
                }
                else {
                    canvas.copyWorld(tempCanvas, this.__world, this.__world, blendMode);
                }
                tempCanvas.recycle();
            }
            else {
                this.__renderBranch(canvas, options);
            }
        }
    },
    __renderBranch(canvas, options) {
        let child;
        const { children } = this;
        if (this.__hasMask && children.length > 1) {
            let mask;
            let maskCanvas = canvas.getSameCanvas();
            let contentCanvas = canvas.getSameCanvas();
            for (let i = 0, len = children.length; i < len; i++) {
                child = children[i];
                if (child.isMask) {
                    if (mask) {
                        this.__renderMask(canvas, contentCanvas, maskCanvas);
                        maskCanvas.clear();
                        contentCanvas.clear();
                    }
                    else {
                        mask = true;
                    }
                    child.__render(maskCanvas, options);
                    continue;
                }
                child.__render(contentCanvas, options);
            }
            this.__renderMask(canvas, contentCanvas, maskCanvas);
            maskCanvas.recycle();
            contentCanvas.recycle();
        }
        else {
            const { bounds, hideBounds } = options;
            for (let i = 0, len = children.length; i < len; i++) {
                child = children[i];
                if (bounds && !bounds.hit(child.__world, options.matrix))
                    continue;
                if (hideBounds && hideBounds.includes(child.__world, options.matrix))
                    continue;
                child.__render(canvas, options);
            }
        }
    }
};

const { LEAF, create } = IncrementId;
const { toInnerPoint, toOuterPoint } = MatrixHelper;
const { tempToOuterOf, copy: copy$3 } = PointHelper;
const { moveLocal, zoomOfLocal, rotateOfLocal, skewOfLocal } = LeafHelper;
let Leaf = class Leaf {
    get tag() { return this.__tag; }
    set tag(_value) { }
    get __tag() { return 'Leaf'; }
    get innerName() { return this.__.name || this.tag + this.innerId; }
    get __DataProcessor() { return LeafData; }
    get __LayoutProcessor() { return LeafLayout; }
    get worldTransform() { return this.__layout.getTransform('world'); }
    get localTransform() { return this.__layout.getTransform('local'); }
    get boxBounds() { return this.getBounds('box', 'inner'); }
    get worldBoxBounds() { return this.getBounds('box'); }
    get worldStrokeBounds() { return this.getBounds('stroke'); }
    get worldRenderBounds() { return this.getBounds('render'); }
    get worldOpacity() { this.__layout.checkUpdate(); return this.__worldOpacity; }
    get resizeable() { return true; }
    get __hasMirror() { return this.__world.scaleX < 0 || this.__world.scaleY < 0; }
    get __onlyHitMask() { return this.__hasMask && !this.__.hitChildren; }
    get __ignoreHitWorld() { return (this.__hasMask || this.__hasEraser) && this.__.hitChildren; }
    constructor(data) {
        this.innerId = create(LEAF);
        this.__world = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0, scaleX: 1, scaleY: 1, rotation: 0, skewX: 0, skewY: 0 };
        this.__local = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0 };
        this.__worldOpacity = 1;
        this.__ = new this.__DataProcessor(this);
        this.__layout = new this.__LayoutProcessor(this);
        if (data) {
            if (data.children) {
                this.set(data);
            }
            else {
                Object.assign(this, data);
            }
        }
    }
    waitParent(item) {
        this.parent ? item() : (this.__parentWait ? this.__parentWait.push(item) : this.__parentWait = [item]);
    }
    waitLeafer(item) {
        this.leafer ? item() : (this.__leaferWait ? this.__leaferWait.push(item) : this.__leaferWait = [item]);
    }
    nextRender(item) {
        this.leafer ? this.leafer.nextRender(item) : this.waitLeafer(() => this.leafer.nextRender(item));
    }
    __bindLeafer(leafer) {
        if (this.isLeafer) {
            if (leafer !== null)
                leafer = this;
        }
        this.leafer = leafer;
        if (leafer) {
            this.__level = this.parent ? this.parent.__level + 1 : 1;
            if (this.__leaferWait)
                WaitHelper.run(this.__leaferWait);
        }
        if (this.isBranch) {
            const { children } = this;
            for (let i = 0, len = children.length; i < len; i++) {
                children[i].__bindLeafer(leafer);
            }
        }
    }
    set(_data) { }
    toJSON() {
        return this.__.__getInputData();
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
    __setAttr(_attrName, _newValue) { }
    __getAttr(_attrName) { return undefined; }
    forceUpdate(attrName) {
        if (attrName === undefined)
            attrName = 'scaleX';
        else if (attrName === 'surface')
            attrName = 'blendMode';
        const value = this.__.__getInput(attrName);
        this.__[attrName] = value === undefined ? null : undefined;
        this[attrName] = value;
    }
    __updateWorldMatrix() { }
    __updateLocalMatrix() { }
    __updateWorldBounds() { }
    __updateLocalBoxBounds() { }
    __updateLocalStrokeBounds() { }
    __updateLocalRenderBounds() { }
    __updateBoxBounds() { }
    __updateStrokeBounds() { }
    __updateRenderBounds() { }
    __updateNaturalSize() { }
    __updateStrokeSpread() { return 0; }
    __updateRenderSpread() { return 0; }
    __onUpdateSize() { }
    __updateEraser(_value) { }
    __updateMask(_value) { }
    __renderMask(_canvas, _content, _mask) { }
    __removeMask(_child) { }
    getWorld(attrName) {
        this.__layout.checkUpdate();
        if (attrName === 'x')
            return this.__world.e;
        if (attrName === 'y')
            return this.__world.f;
        return this.__world[attrName];
    }
    getBounds(type, locationType = 'world') {
        return this.__layout.getBounds(type, locationType);
    }
    worldToLocal(world, to, distance, relative) {
        if (this.parent) {
            this.parent.worldToInner(world, to, distance, relative);
        }
        else {
            if (to)
                copy$3(to, world);
        }
    }
    localToWorld(local, to, distance, relative) {
        if (this.parent) {
            this.parent.innerToWorld(local, to, distance, relative);
        }
        else {
            if (to)
                copy$3(to, local);
        }
    }
    worldToInner(world, to, distance, relative) {
        if (relative) {
            relative.innerToWorld(world, to, distance);
            world = to ? to : world;
        }
        toInnerPoint(this.worldTransform, world, to, distance);
    }
    innerToWorld(inner, to, distance, relative) {
        toOuterPoint(this.worldTransform, inner, to, distance);
        if (relative)
            relative.worldToInner(to ? to : inner, null, distance);
    }
    getInnerPoint(world, relative, distance, change) {
        const point = change ? world : {};
        this.worldToInner(world, point, distance, relative);
        return point;
    }
    getInnerPointByLocal(local, _relative, distance, change) {
        return this.getInnerPoint(local, this.parent, distance, change);
    }
    getLocalPoint(world, relative, distance, change) {
        const point = change ? world : {};
        this.worldToLocal(world, point, distance, relative);
        return point;
    }
    getLocalPointByInner(inner, _relative, distance, change) {
        return this.getWorldPoint(inner, this.parent, distance, change);
    }
    getWorldPoint(inner, relative, distance, change) {
        const point = change ? inner : {};
        this.innerToWorld(inner, point, distance, relative);
        return point;
    }
    getWorldPointByLocal(local, relative, distance, change) {
        const point = change ? local : {};
        this.localToWorld(local, point, distance, relative);
        return point;
    }
    move(x, y) {
        moveLocal(this, x, y);
    }
    scaleOf(origin, x, y) {
        zoomOfLocal(this, tempToOuterOf(origin, this.localTransform), x, y);
    }
    rotateOf(origin, angle) {
        rotateOfLocal(this, tempToOuterOf(origin, this.localTransform), angle);
    }
    skewOf(origin, x, y) {
        skewOfLocal(this, tempToOuterOf(origin, this.localTransform), x, y);
    }
    __hitWorld(_point) { return true; }
    __hit(_local) { return true; }
    __drawHitPath(_canvas) { }
    __updateHitCanvas() { }
    __render(_canvas, _options) { }
    __drawFast(_canvas, _options) { }
    __draw(_canvas, _options) { }
    __renderShape(_canvas, _options) { }
    __updateWorldOpacity() { }
    __updateChange() { }
    __drawPath(_canvas) { }
    __drawRenderPath(_canvas) { }
    __updatePath() { }
    __updateRenderPath() { }
    __updateSortChildren() { }
    add(_child, _index) { }
    remove(_child, destroy) {
        if (this.parent)
            this.parent.remove(this, destroy);
    }
    on(_type, _listener, _options) { }
    off(_type, _listener, _options) { }
    on_(_type, _listener, _bind, _options) { return undefined; }
    off_(_id) { }
    once(_type, _listener, _capture) { }
    emit(_type, _event, _capture) { }
    emitEvent(_event, _capture) { }
    hasEvent(_type, _capture) { return false; }
    destroy() {
        if (!this.destroyed) {
            if (this.parent)
                this.remove();
            if (this.children)
                this.removeAll(true);
            this.__.destroy();
            this.__layout.destroy();
            this.__captureMap = this.__bubbleMap = this.__parentWait = this.__leaferWait = null;
            this.destroyed = true;
        }
    }
};
Leaf = __decorate([
    useModule(LeafDataProxy),
    useModule(LeafMatrix),
    useModule(LeafBounds),
    useModule(LeafHit),
    useModule(LeafEventer),
    useModule(LeafRender)
], Leaf);

const { setByListWithHandle: setByListWithHandle$1 } = BoundsHelper;
const { sort } = BranchHelper;
const { localBoxBounds, localEventBounds, localRenderBounds, maskLocalBoxBounds, maskLocalEventBounds, maskLocalRenderBounds } = LeafBoundsHelper;
let Branch = class Branch extends Leaf {
    constructor() {
        super();
        this.isBranch = true;
        this.children = [];
    }
    __updateStrokeSpread() {
        const { children } = this;
        for (let i = 0, len = children.length; i < len; i++) {
            if (children[i].__layout.strokeSpread)
                return 1;
        }
        return 0;
    }
    __updateRenderSpread() {
        const { children } = this;
        for (let i = 0, len = children.length; i < len; i++) {
            if (children[i].__layout.renderSpread)
                return 1;
        }
        return 0;
    }
    __updateBoxBounds() {
        setByListWithHandle$1(this.__layout.boxBounds, this.children, this.__hasMask ? maskLocalBoxBounds : localBoxBounds);
    }
    __updateStrokeBounds() {
        setByListWithHandle$1(this.__layout.strokeBounds, this.children, this.__hasMask ? maskLocalEventBounds : localEventBounds);
    }
    __updateRenderBounds() {
        setByListWithHandle$1(this.__layout.renderBounds, this.children, this.__hasMask ? maskLocalRenderBounds : localRenderBounds);
    }
    __updateSortChildren() {
        let affectSort;
        const { children } = this;
        if (children.length > 1) {
            for (let i = 0, len = children.length; i < len; i++) {
                children[i].__tempNumber = i;
                if (children[i].__.zIndex)
                    affectSort = true;
            }
            children.sort(sort);
            this.__layout.affectChildrenSort = affectSort;
        }
    }
    add(child, index) {
        if (child.parent)
            child.parent.remove(child);
        child.parent = this;
        index === undefined ? this.children.push(child) : this.children.splice(index, 0, child);
        if (child.isBranch)
            this.__.__childBranchNumber = (this.__.__childBranchNumber || 0) + 1;
        child.__layout.boundsChanged || child.__layout.positionChange();
        if (child.__parentWait)
            WaitHelper.run(child.__parentWait);
        if (this.leafer) {
            child.__bindLeafer(this.leafer);
            if (this.leafer.created)
                this.__emitChildEvent(ChildEvent.ADD, child);
        }
        this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
    }
    addMany(...children) {
        children.forEach(child => this.add(child));
    }
    remove(child, destroy) {
        if (child) {
            const index = this.children.indexOf(child);
            if (index > -1) {
                this.children.splice(index, 1);
                if (child.isBranch)
                    this.__.__childBranchNumber = (this.__.__childBranchNumber || 1) - 1;
                this.__preRemove();
                this.__realRemoveChild(child);
                if (destroy)
                    child.destroy();
            }
        }
        else if (child === undefined) {
            super.remove(null, destroy);
        }
    }
    removeAll(destroy) {
        const { children } = this;
        if (children.length) {
            this.children = [];
            this.__preRemove();
            this.__.__childBranchNumber = 0;
            children.forEach(child => {
                this.__realRemoveChild(child);
                if (destroy)
                    child.destroy();
            });
        }
    }
    __preRemove() {
        if (this.__hasMask)
            this.__updateMask();
        if (this.__hasEraser)
            this.__updateEraser();
        this.__layout.boxChange();
        this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
    }
    __realRemoveChild(child) {
        child.parent = null;
        if (this.leafer) {
            child.__bindLeafer(null);
            if (this.leafer.created) {
                this.__emitChildEvent(ChildEvent.REMOVE, child);
                if (this.leafer.hitCanvasManager)
                    this.leafer.hitCanvasManager.clear();
            }
        }
    }
    __emitChildEvent(type, child) {
        const event = new ChildEvent(type, child, this);
        if (child.hasEvent(type))
            child.emitEvent(event);
        if (this.hasEvent(type) && !this.isLeafer)
            this.emitEvent(event);
        this.leafer.emitEvent(event);
    }
};
Branch = __decorate([
    useModule(BranchRender),
    useModule(LeafMask)
], Branch);

const debug$6 = Debug.get('plugin');
const PluginManager = {
    power: {},
    list: [],
    onLeafer(leafer) {
        PluginManager.list.forEach(plugin => {
            if (plugin.onLeafer)
                plugin.onLeafer(leafer);
        });
    }
};
function usePlugin(plugin, config) {
    const realParams = {};
    const { power, list } = PluginManager;
    if (!power)
        debug$6.error('need add PluginManager.power = LeaferUI');
    if (list.includes(plugin)) {
        debug$6.warn('repeat run', plugin.name);
        return;
    }
    list.push(plugin);
    if (plugin.import) {
        plugin.import.forEach(item => {
            if (power[item]) {
                realParams[item] = power[item];
            }
            else {
                debug$6.error(item + ' non-existent');
            }
        });
    }
    else {
        debug$6.warn('no import');
    }
    try {
        plugin.run(realParams, config);
    }
    catch (e) {
        debug$6.error(e);
    }
}

class Watcher {
    get childrenChanged() { return this.hasAdd || this.hasRemove || this.hasVisible; }
    get updatedList() {
        if (this.hasRemove) {
            const updatedList = new LeafList();
            this.__updatedList.list.forEach(item => { if (item.leafer)
                updatedList.push(item); });
            return updatedList;
        }
        else {
            return this.__updatedList;
        }
    }
    constructor(target, userConfig) {
        this.totalTimes = 0;
        this.config = {};
        this.__updatedList = new LeafList();
        this.target = target;
        if (userConfig)
            this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
    }
    start() {
        if (this.disabled)
            return;
        this.running = true;
    }
    stop() {
        this.running = false;
    }
    disable() {
        this.stop();
        this.__removeListenEvents();
        this.disabled = true;
    }
    update() {
        this.changed = true;
        if (this.running)
            this.target.emit(RenderEvent.REQUEST);
    }
    __onAttrChange(event) {
        this.__updatedList.push(event.target);
        this.update();
    }
    __onChildEvent(event) {
        if (event.type === ChildEvent.ADD) {
            this.hasAdd = true;
            this.__pushChild(event.child);
        }
        else {
            this.hasRemove = true;
            this.__updatedList.push(event.parent);
        }
        this.update();
    }
    __pushChild(child) {
        this.__updatedList.push(child);
        if (child.isBranch)
            this.__loopChildren(child);
    }
    __loopChildren(parent) {
        const { children } = parent;
        for (let i = 0, len = children.length; i < len; i++)
            this.__pushChild(children[i]);
    }
    __onRquestData() {
        this.target.emitEvent(new WatchEvent(WatchEvent.DATA, { updatedList: this.updatedList }));
        this.__updatedList = new LeafList();
        this.totalTimes++;
        this.changed = false;
        this.hasVisible = false;
        this.hasRemove = false;
        this.hasAdd = false;
    }
    __listenEvents() {
        const { target } = this;
        this.__eventIds = [
            target.on_(PropertyEvent.CHANGE, this.__onAttrChange, this),
            target.on_([ChildEvent.ADD, ChildEvent.REMOVE], this.__onChildEvent, this),
            target.on_(WatchEvent.REQUEST, this.__onRquestData, this)
        ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
    }
    destroy() {
        if (this.target) {
            this.stop();
            this.__removeListenEvents();
            this.target = null;
            this.__updatedList = null;
        }
    }
}

const { updateAllWorldMatrix: updateAllWorldMatrix$1, updateAllWorldOpacity } = LeafHelper;
const { pushAllChildBranch, pushAllParent } = BranchHelper;
function updateMatrix(updateList, levelList) {
    let layout;
    updateList.list.forEach(leaf => {
        layout = leaf.__layout;
        if (levelList.without(leaf) && !layout.useZoomProxy) {
            if (layout.matrixChanged) {
                updateAllWorldMatrix$1(leaf);
                levelList.push(leaf);
                if (leaf.isBranch)
                    pushAllChildBranch(leaf, levelList);
                pushAllParent(leaf, levelList);
            }
            else if (layout.boundsChanged) {
                levelList.push(leaf);
                if (leaf.isBranch)
                    leaf.__tempNumber = 0;
                pushAllParent(leaf, levelList);
            }
        }
    });
}
function updateBounds(boundsList) {
    let itemList, branch;
    boundsList.sort(true);
    boundsList.levels.forEach(level => {
        itemList = boundsList.levelMap[level];
        for (let i = 0, len = itemList.length; i < len; i++) {
            branch = itemList[i];
            if (branch.isBranch && branch.__tempNumber) {
                for (let j = 0, jLen = branch.children.length; j < jLen; j++) {
                    if (!branch.children[j].isBranch) {
                        branch.children[j].__updateWorldBounds();
                    }
                }
            }
            branch.__updateWorldBounds();
        }
    });
}
function updateChange(updateList) {
    updateList.list.forEach(leaf => {
        if (leaf.__layout.opacityChanged)
            updateAllWorldOpacity(leaf);
        leaf.__updateChange();
    });
}

const { worldBounds } = LeafBoundsHelper;
const { setByListWithHandle } = BoundsHelper;
class LayoutBlockData {
    constructor(list) {
        this.updatedBounds = new Bounds();
        this.beforeBounds = new Bounds();
        this.afterBounds = new Bounds();
        if (list instanceof Array)
            list = new LeafList(list);
        this.updatedList = list;
    }
    setBefore() {
        setByListWithHandle(this.beforeBounds, this.updatedList.list, worldBounds);
    }
    setAfter() {
        setByListWithHandle(this.afterBounds, this.updatedList.list, worldBounds);
        this.updatedBounds.setByList([this.beforeBounds, this.afterBounds]);
    }
    merge(data) {
        this.updatedList.pushList(data.updatedList.list);
        this.beforeBounds.add(data.beforeBounds);
        this.afterBounds.add(data.afterBounds);
        this.updatedBounds.add(data.updatedBounds);
    }
    destroy() {
        this.updatedList = null;
    }
}

const { updateAllWorldMatrix, updateAllChange } = LeafHelper;
const { pushAllBranchStack, updateWorldBoundsByBranchStack } = BranchHelper;
const debug$5 = Debug.get('Layouter');
class Layouter {
    constructor(target, userConfig) {
        this.totalTimes = 0;
        this.config = {};
        this.__levelList = new LeafLevelList();
        this.target = target;
        if (userConfig)
            this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
    }
    start() {
        if (this.disabled)
            return;
        this.running = true;
    }
    stop() {
        this.running = false;
    }
    disable() {
        this.stop();
        this.__removeListenEvents();
        this.disabled = true;
    }
    layout() {
        if (!this.running)
            return;
        const { target } = this;
        this.times = 0;
        try {
            target.emit(LayoutEvent.START);
            this.layoutOnce();
            target.emitEvent(new LayoutEvent(LayoutEvent.END, this.layoutedBlocks, this.times));
        }
        catch (e) {
            debug$5.error(e);
        }
        this.layoutedBlocks = null;
    }
    layoutAgain() {
        if (this.layouting) {
            this.waitAgain = true;
        }
        else {
            this.layoutOnce();
        }
    }
    layoutOnce() {
        if (this.layouting)
            return debug$5.warn('layouting');
        if (this.times > 3)
            return debug$5.warn('layout max times');
        this.times++;
        this.totalTimes++;
        this.layouting = true;
        this.target.emit(WatchEvent.REQUEST);
        if (this.totalTimes > 1) {
            this.partLayout();
        }
        else {
            this.fullLayout();
        }
        this.layouting = false;
        if (this.waitAgain) {
            this.waitAgain = false;
            this.layoutOnce();
        }
    }
    partLayout() {
        var _a;
        if (!((_a = this.__updatedList) === null || _a === void 0 ? void 0 : _a.length))
            return;
        const t = Run.start('PartLayout');
        const { target, __updatedList: updateList } = this;
        const { BEFORE, LAYOUT, AFTER } = LayoutEvent;
        const blocks = this.getBlocks(updateList);
        blocks.forEach(item => { item.setBefore(); });
        target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
        updateList.sort();
        updateMatrix(updateList, this.__levelList);
        updateBounds(this.__levelList);
        updateChange(updateList);
        blocks.forEach(item => item.setAfter());
        target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
        target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
        this.addBlocks(blocks);
        this.__levelList.reset();
        this.__updatedList = null;
        Run.end(t);
    }
    fullLayout() {
        const t = Run.start('FullLayout');
        const { target } = this;
        const { BEFORE, LAYOUT, AFTER } = LayoutEvent;
        const blocks = this.getBlocks(new LeafList(target));
        target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
        Layouter.fullLayout(target);
        blocks.forEach(item => { item.setAfter(); });
        target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
        target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
        this.addBlocks(blocks);
        Run.end(t);
    }
    static fullLayout(target) {
        updateAllWorldMatrix(target);
        if (target.isBranch) {
            const branchStack = [target];
            pushAllBranchStack(target, branchStack);
            updateWorldBoundsByBranchStack(branchStack);
        }
        else {
            target.__updateWorldBounds();
        }
        updateAllChange(target);
    }
    createBlock(data) {
        return new LayoutBlockData(data);
    }
    getBlocks(list) {
        return [this.createBlock(list)];
    }
    addBlocks(current) {
        this.layoutedBlocks ? this.layoutedBlocks.push(...current) : this.layoutedBlocks = current;
    }
    __onReceiveWatchData(event) {
        this.__updatedList = event.data.updatedList;
    }
    __listenEvents() {
        const { target } = this;
        this.__eventIds = [
            target.on_(LayoutEvent.REQUEST, this.layout, this),
            target.on_(LayoutEvent.AGAIN, this.layoutAgain, this),
            target.on_(WatchEvent.DATA, this.__onReceiveWatchData, this)
        ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
    }
    destroy() {
        if (this.target) {
            this.stop();
            this.__removeListenEvents();
            this.target = null;
            this.config = null;
        }
    }
}

const debug$4 = Debug.get('Renderer');
class Renderer {
    get needFill() { return !!(!this.canvas.allowBackgroundColor && this.config.fill); }
    constructor(target, canvas, userConfig) {
        this.FPS = 60;
        this.totalTimes = 0;
        this.times = 0;
        this.config = {
            usePartRender: true,
            maxFPS: 60
        };
        this.target = target;
        this.canvas = canvas;
        if (userConfig)
            this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
        this.__requestRender();
    }
    start() {
        this.running = true;
    }
    stop() {
        this.running = false;
    }
    update() {
        this.changed = true;
    }
    requestLayout() {
        this.target.emit(LayoutEvent.REQUEST);
    }
    render(callback) {
        if (!(this.running && this.canvas.view)) {
            this.changed = true;
            return;
        }
        const { target } = this;
        this.times = 0;
        this.totalBounds = new Bounds();
        debug$4.log(target.innerName, '--->');
        try {
            this.emitRender(RenderEvent.START);
            this.renderOnce(callback);
            this.emitRender(RenderEvent.END, this.totalBounds);
            ImageManager.clearRecycled();
        }
        catch (e) {
            this.rendering = false;
            debug$4.error(e);
        }
        debug$4.log('-------------|');
    }
    renderAgain() {
        if (this.rendering) {
            this.waitAgain = true;
        }
        else {
            this.renderOnce();
        }
    }
    renderOnce(callback) {
        if (this.rendering)
            return debug$4.warn('rendering');
        if (this.times > 3)
            return debug$4.warn('render max times');
        this.times++;
        this.totalTimes++;
        this.rendering = true;
        this.changed = false;
        this.renderBounds = new Bounds();
        this.renderOptions = {};
        if (callback) {
            this.emitRender(RenderEvent.BEFORE);
            callback();
        }
        else {
            this.requestLayout();
            this.emitRender(RenderEvent.BEFORE);
            if (this.config.usePartRender && this.totalTimes > 1) {
                this.partRender();
            }
            else {
                this.fullRender();
            }
        }
        this.emitRender(RenderEvent.RENDER, this.renderBounds, this.renderOptions);
        this.emitRender(RenderEvent.AFTER, this.renderBounds, this.renderOptions);
        this.updateBlocks = null;
        this.rendering = false;
        if (this.waitAgain) {
            this.waitAgain = false;
            this.renderOnce();
        }
    }
    partRender() {
        const { canvas, updateBlocks: list } = this;
        if (!list)
            return debug$4.warn('PartRender: need update attr');
        if (list.some(block => block.includes(this.target.__world)))
            this.mergeBlocks();
        list.forEach(block => { if (canvas.bounds.hit(block) && !block.isEmpty())
            this.clipRender(block); });
    }
    clipRender(block) {
        const t = Run.start('PartRender');
        const { canvas } = this;
        const bounds = block.getIntersect(canvas.bounds);
        const includes = block.includes(this.target.__world);
        const realBounds = new Bounds().copy(bounds);
        canvas.save();
        if (includes && !Debug.showRepaint) {
            canvas.clear();
        }
        else {
            bounds.spread(1 + 1 / this.canvas.pixelRatio).ceil();
            canvas.clearWorld(bounds, true);
            canvas.clipWorld(bounds, true);
        }
        this.__render(bounds, realBounds);
        canvas.restore();
        Run.end(t);
    }
    fullRender() {
        const t = Run.start('FullRender');
        const { canvas } = this;
        canvas.save();
        canvas.clear();
        this.__render(canvas.bounds);
        canvas.restore();
        Run.end(t);
    }
    __render(bounds, realBounds) {
        const options = (bounds === null || bounds === void 0 ? void 0 : bounds.includes(this.target.__world)) ? {} : { bounds };
        if (this.needFill)
            this.canvas.fillWorld(bounds, this.config.fill);
        if (Debug.showRepaint)
            this.canvas.strokeWorld(bounds, 'red');
        this.target.__render(this.canvas, options);
        this.renderBounds = realBounds || bounds;
        this.renderOptions = options;
        this.totalBounds.isEmpty() ? this.totalBounds = this.renderBounds : this.totalBounds.add(this.renderBounds);
        if (Debug.showHitView)
            this.renderHitView(options);
        if (Debug.showBoundsView)
            this.renderBoundsView(options);
        this.canvas.updateRender();
    }
    renderHitView(_options) { }
    renderBoundsView(_options) { }
    addBlock(block) {
        if (!this.updateBlocks)
            this.updateBlocks = [];
        this.updateBlocks.push(block);
    }
    mergeBlocks() {
        const { updateBlocks: list } = this;
        if (list) {
            const bounds = new Bounds();
            bounds.setByList(list);
            list.length = 0;
            list.push(bounds);
        }
    }
    __requestRender() {
        const startTime = Date.now();
        Platform.requestRender(() => {
            this.FPS = Math.min(60, Math.ceil(1000 / (Date.now() - startTime)));
            if (this.changed) {
                if (this.running && this.canvas.view)
                    this.render();
            }
            if (this.running)
                this.target.emit(AnimateEvent.FRAME);
            if (this.target)
                this.__requestRender();
        });
    }
    __onResize(e) {
        if (this.canvas.unreal)
            return;
        if (e.bigger || !e.samePixelRatio) {
            const { width, height } = e.old;
            const bounds = new Bounds(0, 0, width, height);
            if (!bounds.includes(this.target.__world) || this.needFill || !e.samePixelRatio) {
                this.addBlock(this.canvas.bounds);
                this.target.forceUpdate('blendMode');
            }
        }
    }
    __onLayoutEnd(event) {
        if (event.data)
            event.data.map(item => {
                let empty;
                if (item.updatedList)
                    item.updatedList.list.some(leaf => {
                        empty = (!leaf.__world.width || !leaf.__world.height);
                        if (empty) {
                            if (!leaf.isLeafer)
                                debug$4.warn(leaf.innerName, ': empty');
                            empty = (!leaf.isBranch || leaf.isBranchLeaf);
                        }
                        return empty;
                    });
                this.addBlock(empty ? this.canvas.bounds : item.updatedBounds);
            });
    }
    emitRender(type, bounds, options) {
        this.target.emitEvent(new RenderEvent(type, this.times, bounds, options));
    }
    __listenEvents() {
        const { target } = this;
        this.__eventIds = [
            target.on_(RenderEvent.REQUEST, this.update, this),
            target.on_(LayoutEvent.END, this.__onLayoutEnd, this),
            target.on_(RenderEvent.AGAIN, this.renderAgain, this),
            target.on_(ResizeEvent.RESIZE, this.__onResize, this)
        ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
    }
    destroy() {
        if (this.target) {
            this.stop();
            this.__removeListenEvents();
            this.target = null;
            this.canvas = null;
            this.config = null;
        }
    }
}

const { hitRadiusPoint } = BoundsHelper;
class FindPath {
    constructor(target, selector) {
        this.target = target;
        this.selector = selector;
    }
    getByPoint(hitPoint, hitRadius, options) {
        if (!hitRadius)
            hitRadius = 0;
        if (!options)
            options = {};
        const through = options.through || false;
        const ignoreHittable = options.ignoreHittable || false;
        this.exclude = options.exclude || null;
        this.point = { x: hitPoint.x, y: hitPoint.y, radiusX: hitRadius, radiusY: hitRadius };
        this.findList = [];
        this.eachFind(this.target.children, this.target.__onlyHitMask);
        const list = this.findList;
        const leaf = this.getBestMatchLeaf();
        const path = ignoreHittable ? this.getPath(leaf) : this.getHitablePath(leaf);
        this.clear();
        return through ? { path, leaf, throughPath: list.length ? this.getThroughPath(list) : path } : { path, leaf };
    }
    getBestMatchLeaf() {
        const { findList: targets } = this;
        if (targets.length > 1) {
            let find;
            this.findList = [];
            const { x, y } = this.point;
            const point = { x, y, radiusX: 0, radiusY: 0 };
            for (let i = 0, len = targets.length; i < len; i++) {
                find = targets[i];
                if (LeafHelper.worldHittable(find)) {
                    this.hitChild(find, point);
                    if (this.findList.length)
                        return this.findList[0];
                }
            }
        }
        return targets[0];
    }
    getPath(leaf) {
        const path = new LeafList();
        while (leaf) {
            path.push(leaf);
            leaf = leaf.parent;
        }
        path.push(this.target);
        return path;
    }
    getHitablePath(leaf) {
        const path = this.getPath(leaf);
        let item, hittablePath = new LeafList();
        for (let i = path.list.length - 1; i > -1; i--) {
            item = path.list[i];
            if (!item.__.hittable)
                break;
            hittablePath.unshift(item);
            if (!item.__.hitChildren)
                break;
        }
        return hittablePath;
    }
    getThroughPath(list) {
        const throughPath = new LeafList();
        const pathList = [];
        for (let i = list.length - 1; i > -1; i--) {
            pathList.push(this.getPath(list[i]));
        }
        let path, nextPath, leaf;
        for (let i = 0, len = pathList.length; i < len; i++) {
            path = pathList[i], nextPath = pathList[i + 1];
            for (let j = 0, jLen = path.length; j < jLen; j++) {
                leaf = path.list[j];
                if (nextPath && nextPath.has(leaf))
                    break;
                throughPath.push(leaf);
            }
        }
        return throughPath;
    }
    eachFind(children, hitMask) {
        let child, hit;
        const { point } = this, len = children.length;
        for (let i = len - 1; i > -1; i--) {
            child = children[i];
            if (!child.__.visible || (hitMask && !child.__.isMask))
                continue;
            hit = child.__.hitRadius ? true : hitRadiusPoint(child.__world, point);
            if (child.isBranch) {
                if (hit || child.__ignoreHitWorld) {
                    this.eachFind(child.children, child.__onlyHitMask);
                    if (child.isBranchLeaf && !this.findList.length)
                        this.hitChild(child, point);
                }
            }
            else {
                if (hit)
                    this.hitChild(child, point);
            }
        }
    }
    hitChild(child, point) {
        if (this.exclude && this.exclude.has(child))
            return;
        if (child.__hitWorld(point))
            this.findList.push(child);
    }
    clear() {
        this.point = null;
        this.findList = null;
        this.exclude = null;
    }
    destroy() {
        this.clear();
    }
}

class Selector {
    constructor(target, userConfig) {
        this.config = {};
        this.innerIdList = {};
        this.idList = {};
        this.classNameList = {};
        this.tagNameList = {};
        this.target = target;
        if (userConfig)
            this.config = DataHelper.default(userConfig, this.config);
        this.findPath = new FindPath(target, this);
        this.__listenEvents();
    }
    getByPoint(hitPoint, hitRadius, options) {
        if (Platform.name === 'node')
            this.target.emit(LayoutEvent.CHECK_UPDATE);
        return this.findPath.getByPoint(hitPoint, hitRadius, options);
    }
    find(name, branch) {
        if (typeof name === 'number') {
            return this.getByInnerId(name, branch);
        }
        else if (name.startsWith('#')) {
            return this.getById(name.substring(1), branch);
        }
        else if (name.startsWith('.')) {
            return this.getByClassName(name.substring(1), branch);
        }
        else {
            return this.getByTagName(name, branch);
        }
    }
    getByInnerId(name, branch) {
        let cache = this.innerIdList[name];
        if (cache)
            return cache;
        if (!branch)
            branch = this.target;
        let find;
        this.loopFind(branch, (leaf) => {
            if (leaf.innerId === name) {
                find = leaf;
                this.innerIdList[name] = find;
                return true;
            }
            else {
                return false;
            }
        });
        return find;
    }
    getById(name, branch) {
        let cache = this.idList[name];
        if (cache)
            return cache;
        if (!branch)
            branch = this.target;
        let find;
        this.loopFind(branch, (leaf) => {
            if (leaf.id === name) {
                find = leaf;
                this.idList[name] = find;
                return true;
            }
            else {
                return false;
            }
        });
        return find;
    }
    getByClassName(name, branch) {
        if (!branch)
            branch = this.target;
        let find = [];
        this.loopFind(branch, (leaf) => {
            if (leaf.className === name)
                find.push(leaf);
            return false;
        });
        return find;
    }
    getByTagName(name, branch) {
        if (!branch)
            branch = this.target;
        let find = [];
        this.loopFind(branch, (leaf) => {
            if (leaf.__tag === name)
                find.push(leaf);
            return false;
        });
        return find;
    }
    loopFind(branch, find) {
        if (find(branch))
            return;
        const { children } = branch;
        for (let i = 0, len = children.length; i < len; i++) {
            branch = children[i];
            if (find(branch))
                return;
            if (branch.isBranch)
                this.loopFind(branch, find);
        }
    }
    __onRemoveChild(event) {
        const target = event.target;
        if (this.idList[target.id])
            this.idList[target.id] = null;
        if (this.innerIdList[target.id])
            this.innerIdList[target.innerId] = null;
    }
    __listenEvents() {
        this.__eventIds = [
            this.target.on_(ChildEvent.REMOVE, this.__onRemoveChild, this)
        ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
        this.__eventIds.length = 0;
    }
    destroy() {
        if (this.__eventIds.length) {
            this.__removeListenEvents();
            this.findPath.destroy();
            this.innerIdList = {};
            this.idList = {};
            this.classNameList = {};
            this.tagNameList = {};
        }
    }
}

Object.assign(Creator, {
    watcher: (target, options) => new Watcher(target, options),
    layouter: (target, options) => new Layouter(target, options),
    renderer: (target, canvas, options) => new Renderer(target, canvas, options),
    selector: (target, options) => new Selector(target, options)
});
Platform.layout = Layouter.fullLayout;

const debug$3 = Debug.get('LeaferCanvas');
class LeaferCanvas extends LeaferCanvasBase {
    init() {
        const { view } = this.config;
        view ? this.__createViewFrom(view) : this.__createView();
        const { style } = this.view;
        style.display || (style.display = 'block');
        this.parentView = this.view.parentElement;
        if (Platform.syncDomFont && !this.parentView) {
            this.view.style.display = 'none';
            document.body.appendChild(this.view);
        }
        this.__createContext();
        if (!this.autoLayout)
            this.resize(this.config);
    }
    set backgroundColor(color) { this.view.style.backgroundColor = color; }
    get backgroundColor() { return this.view.style.backgroundColor; }
    set hittable(hittable) { this.view.style.pointerEvents = hittable ? 'auto' : 'none'; }
    get hittable() { return this.view.style.pointerEvents !== 'none'; }
    __createView() {
        this.view = document.createElement('canvas');
    }
    setCursor(cursor) {
        const list = [];
        this.eachCursor(cursor, list);
        if (typeof list[list.length - 1] === 'object')
            list.push('default');
        this.view.style.cursor = list.map(item => (typeof item === 'object') ? `url(${item.url}) ${item.x || 0} ${item.y || 0}` : item).join(',');
    }
    eachCursor(cursor, list, level = 0) {
        level++;
        if (cursor instanceof Array) {
            cursor.forEach(item => this.eachCursor(item, list, level));
        }
        else {
            const custom = typeof cursor === 'string' && Cursor.get(cursor);
            if (custom && level < 2) {
                this.eachCursor(custom, list, level);
            }
            else {
                list.push(cursor);
            }
        }
    }
    __createViewFrom(inputView) {
        let find = (typeof inputView === 'string') ? document.getElementById(inputView) : inputView;
        if (find) {
            if (find instanceof HTMLCanvasElement) {
                this.view = find;
            }
            else {
                let parent = find;
                if (find === window || find === document) {
                    const div = document.createElement('div');
                    const { style } = div;
                    style.position = 'absolute';
                    style.top = style.bottom = style.left = style.right = '0px';
                    document.body.appendChild(div);
                    parent = div;
                }
                this.__createView();
                const view = this.view;
                if (parent.hasChildNodes()) {
                    const { style } = view;
                    style.position = 'absolute';
                    style.top = style.left = '0px';
                    parent.style.position || (parent.style.position = 'relative');
                }
                parent.appendChild(view);
            }
        }
        else {
            debug$3.error(`no id: ${inputView}`);
            this.__createView();
        }
    }
    updateViewSize() {
        const { width, height, pixelRatio } = this;
        const { style } = this.view;
        style.width = width + 'px';
        style.height = height + 'px';
        this.view.width = width * pixelRatio;
        this.view.height = height * pixelRatio;
    }
    updateClientBounds() {
        this.clientBounds = this.view.getBoundingClientRect();
    }
    startAutoLayout(autoBounds, listener) {
        this.autoBounds = autoBounds;
        this.resizeListener = listener;
        try {
            this.resizeObserver = new ResizeObserver((entries) => {
                this.updateClientBounds();
                for (const entry of entries)
                    this.checkAutoBounds(entry.contentRect);
            });
            const parent = this.parentView;
            if (parent) {
                this.resizeObserver.observe(parent);
                this.checkAutoBounds(parent.getBoundingClientRect());
            }
        }
        catch (_a) {
            this.imitateResizeObserver();
        }
    }
    imitateResizeObserver() {
        if (this.autoLayout) {
            if (this.parentView)
                this.checkAutoBounds(this.parentView.getBoundingClientRect());
            Platform.requestRender(this.imitateResizeObserver.bind(this));
        }
    }
    checkAutoBounds(parentSize) {
        const view = this.view;
        const { x, y, width, height } = this.autoBounds.getBoundsFrom(parentSize);
        if (width !== this.width || height !== this.height) {
            const { style } = view;
            const { pixelRatio } = this;
            style.marginLeft = x + 'px';
            style.marginTop = y + 'px';
            const size = { width, height, pixelRatio };
            const oldSize = {};
            DataHelper.copyAttrs(oldSize, this, canvasSizeAttrs);
            this.resize(size);
            if (this.width !== undefined)
                this.resizeListener(new ResizeEvent(size, oldSize));
        }
    }
    stopAutoLayout() {
        this.autoLayout = false;
        this.resizeListener = null;
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
    }
    unrealCanvas() {
        if (!this.unreal && this.parentView) {
            const view = this.view;
            if (view)
                view.remove();
            this.view = this.parentView;
            this.unreal = true;
        }
    }
    destroy() {
        if (this.view) {
            this.stopAutoLayout();
            if (!this.unreal) {
                const view = this.view;
                if (view.parentElement)
                    view.remove();
            }
            super.destroy();
        }
    }
}

canvasPatch(CanvasRenderingContext2D.prototype);
canvasPatch(Path2D.prototype);

const PointerEventHelper = {
    convert(e, local) {
        const base = InteractionHelper.getBase(e);
        const data = Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: e.width, height: e.height, pointerType: e.pointerType, pressure: e.pressure });
        if (data.pointerType === 'pen') {
            data.tangentialPressure = e.tangentialPressure;
            data.tiltX = e.tiltX;
            data.tiltY = e.tiltY;
            data.twist = e.twist;
        }
        return data;
    },
    convertMouse(e, local) {
        const base = InteractionHelper.getBase(e);
        return Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: 1, height: 1, pointerType: 'mouse', pressure: 0.5 });
    },
    convertTouch(e, local) {
        const touch = PointerEventHelper.getTouch(e);
        const base = InteractionHelper.getBase(e);
        return Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: 1, height: 1, pointerType: 'touch', pressure: touch.force });
    },
    getTouch(e) {
        return e.targetTouches[0] || e.changedTouches[0];
    }
};

const WheelEventHelper = {
    getMove(e, config) {
        let { moveSpeed } = config;
        let { deltaX, deltaY } = e;
        if (e.shiftKey && !deltaX) {
            deltaX = deltaY;
            deltaY = 0;
        }
        if (deltaX > 50)
            deltaX = Math.max(50, deltaX / 3);
        if (deltaY > 50)
            deltaY = Math.max(50, deltaY / 3);
        return { x: -deltaX * moveSpeed * 2, y: -deltaY * moveSpeed * 2 };
    },
    getScale(e, config) {
        let zoom;
        let scale = 1;
        let { zoomMode, zoomSpeed } = config;
        const delta = e.deltaY || e.deltaX;
        if (zoomMode) {
            zoom = !e.deltaX && (Platform.intWheelDeltaY ? Math.abs(delta) > 17 : Math.ceil(delta) !== delta);
            if (e.shiftKey || e.metaKey || e.ctrlKey)
                zoom = true;
        }
        else {
            zoom = !e.shiftKey && (e.metaKey || e.ctrlKey);
        }
        if (zoom) {
            zoomSpeed = MathHelper.within(zoomSpeed, 0, 1);
            const min = e.deltaY ? config.delta.y : config.delta.x;
            scale = 1 - delta / (min * 25 * (1 - zoomSpeed) + 10);
            if (scale < 0.5)
                scale = 0.5;
            if (scale >= 1.5)
                scale = 1.5;
        }
        return scale;
    }
};

const KeyEventHelper = {
    convert(e) {
        const base = InteractionHelper.getBase(e);
        const data = Object.assign(Object.assign({}, base), { code: e.code, key: e.key });
        return data;
    }
};

const { getMoveEventData, getZoomEventData, getRotateEventData } = InteractionHelper;
class Interaction extends InteractionBase {
    __listenEvents() {
        super.__listenEvents();
        const view = this.view = this.canvas.view;
        this.viewEvents = {
            'pointerdown': this.onPointerDown,
            'mousedown': this.onMouseDown,
            'touchstart': this.onTouchStart,
            'wheel': this.onWheel,
            'gesturestart': this.onGesturestart,
            'gesturechange': this.onGesturechange,
            'gestureend': this.onGestureend
        };
        this.windowEvents = {
            'pointermove': this.onPointerMove,
            'pointerup': this.onPointerUp,
            'pointercancel': this.onPointerCancel,
            'mousemove': this.onMouseMove,
            'mouseup': this.onMouseUp,
            'touchmove': this.onTouchMove,
            'touchend': this.onTouchEnd,
            'touchcancel': this.onTouchCancel,
            'keydown': this.onKeyDown,
            'keyup': this.onKeyUp,
            'scroll': this.onScroll
        };
        const { viewEvents, windowEvents } = this;
        for (let name in viewEvents) {
            viewEvents[name] = viewEvents[name].bind(this);
            view.addEventListener(name, viewEvents[name]);
        }
        for (let name in windowEvents) {
            windowEvents[name] = windowEvents[name].bind(this);
            window.addEventListener(name, windowEvents[name]);
        }
    }
    __removeListenEvents() {
        super.__removeListenEvents();
        const { viewEvents, windowEvents } = this;
        for (let name in viewEvents) {
            this.view.removeEventListener(name, viewEvents[name]);
            this.viewEvents = {};
        }
        for (let name in windowEvents) {
            window.removeEventListener(name, windowEvents[name]);
            this.windowEvents = {};
        }
    }
    getLocal(p, updateClient) {
        if (updateClient)
            this.canvas.updateClientBounds();
        const { clientBounds } = this.canvas;
        return { x: p.clientX - clientBounds.x, y: p.clientY - clientBounds.y };
    }
    getTouches(touches) {
        const list = [];
        for (let i = 0, len = touches.length; i < len; i++) {
            list.push(touches[i]);
        }
        return list;
    }
    preventDefaultPointer(e) {
        const { pointer } = this.config;
        if (pointer.preventDefault)
            e.preventDefault();
    }
    preventDefaultWheel(e) {
        const { wheel } = this.config;
        if (wheel.preventDefault)
            e.preventDefault();
    }
    preventWindowPointer(e) {
        return !this.downData && e.target !== this.view;
    }
    onKeyDown(e) {
        this.keyDown(KeyEventHelper.convert(e));
    }
    onKeyUp(e) {
        this.keyUp(KeyEventHelper.convert(e));
    }
    onScroll() {
        this.canvas.updateClientBounds();
    }
    onPointerDown(e) {
        this.preventDefaultPointer(e);
        this.usePointer || (this.usePointer = true);
        if (this.useMultiTouch)
            return;
        this.pointerDown(PointerEventHelper.convert(e, this.getLocal(e)));
    }
    onPointerMove(e) {
        this.usePointer || (this.usePointer = true);
        if (this.useMultiTouch || this.preventWindowPointer(e))
            return;
        this.pointerMove(PointerEventHelper.convert(e, this.getLocal(e, true)));
    }
    onPointerUp(e) {
        if (this.downData)
            this.preventDefaultPointer(e);
        if (this.useMultiTouch || this.preventWindowPointer(e))
            return;
        this.pointerUp(PointerEventHelper.convert(e, this.getLocal(e)));
    }
    onPointerCancel() {
        if (this.useMultiTouch)
            return;
        this.pointerCancel();
    }
    onMouseDown(e) {
        this.preventDefaultPointer(e);
        if (this.useTouch || this.usePointer)
            return;
        this.pointerDown(PointerEventHelper.convertMouse(e, this.getLocal(e)));
    }
    onMouseMove(e) {
        if (this.useTouch || this.usePointer || this.preventWindowPointer(e))
            return;
        this.pointerMove(PointerEventHelper.convertMouse(e, this.getLocal(e, true)));
    }
    onMouseUp(e) {
        if (this.downData)
            this.preventDefaultPointer(e);
        if (this.useTouch || this.usePointer || this.preventWindowPointer(e))
            return;
        this.pointerUp(PointerEventHelper.convertMouse(e, this.getLocal(e)));
    }
    onMouseCancel() {
        if (this.useTouch || this.usePointer)
            return;
        this.pointerCancel();
    }
    onTouchStart(e) {
        e.preventDefault();
        this.multiTouchStart(e);
        if (this.usePointer)
            return;
        if (this.touchTimer) {
            window.clearTimeout(this.touchTimer);
            this.touchTimer = 0;
        }
        this.useTouch = true;
        const touch = PointerEventHelper.getTouch(e);
        this.pointerDown(PointerEventHelper.convertTouch(e, this.getLocal(touch, true)));
    }
    onTouchMove(e) {
        this.multiTouchMove(e);
        if (this.usePointer || this.preventWindowPointer(e))
            return;
        const touch = PointerEventHelper.getTouch(e);
        this.pointerMove(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
    }
    onTouchEnd(e) {
        this.multiTouchEnd();
        if (this.usePointer || this.preventWindowPointer(e))
            return;
        if (this.touchTimer)
            clearTimeout(this.touchTimer);
        this.touchTimer = setTimeout(() => {
            this.useTouch = false;
        }, 500);
        const touch = PointerEventHelper.getTouch(e);
        this.pointerUp(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
    }
    onTouchCancel() {
        if (this.usePointer)
            return;
        this.pointerCancel();
    }
    multiTouchStart(e) {
        this.useMultiTouch = (e.touches.length >= 2);
        this.touches = this.useMultiTouch ? this.getTouches(e.touches) : undefined;
        if (this.useMultiTouch)
            this.pointerCancel();
    }
    multiTouchMove(e) {
        if (!this.useMultiTouch)
            return;
        if (e.touches.length > 1) {
            const touches = this.getTouches(e.touches);
            const list = this.getKeepTouchList(this.touches, touches);
            if (list.length > 1) {
                this.multiTouch(InteractionHelper.getBase(e), list);
                this.touches = touches;
            }
        }
    }
    multiTouchEnd() {
        this.touches = null;
        this.useMultiTouch = false;
        this.transformEnd();
    }
    getKeepTouchList(old, touches) {
        let to;
        const list = [];
        old.forEach(from => {
            to = touches.find(touch => touch.identifier === from.identifier);
            if (to)
                list.push({ from: this.getLocal(from), to: this.getLocal(to) });
        });
        return list;
    }
    getLocalTouchs(points) {
        return points.map(point => this.getLocal(point));
    }
    onWheel(e) {
        this.preventDefaultWheel(e);
        const { wheel } = this.config;
        const scale = wheel.getScale ? wheel.getScale(e, wheel) : WheelEventHelper.getScale(e, wheel);
        const local = this.getLocal(e);
        const eventBase = InteractionHelper.getBase(e);
        scale !== 1 ? this.zoom(getZoomEventData(local, scale, eventBase)) : this.move(getMoveEventData(local, wheel.getMove ? wheel.getMove(e, wheel) : WheelEventHelper.getMove(e, wheel), eventBase));
    }
    onGesturestart(e) {
        this.preventDefaultWheel(e);
        this.lastGestureScale = 1;
        this.lastGestureRotation = 0;
    }
    onGesturechange(e) {
        this.preventDefaultWheel(e);
        const local = this.getLocal(e);
        const eventBase = InteractionHelper.getBase(e);
        const changeScale = e.scale / this.lastGestureScale;
        const changeAngle = e.rotation - this.lastGestureRotation;
        let { rotateSpeed } = this.config.wheel;
        rotateSpeed = MathHelper.within(rotateSpeed, 0, 1);
        this.zoom(getZoomEventData(local, changeScale * changeScale, eventBase));
        this.rotate(getRotateEventData(local, changeAngle / Math.PI * 180 * (rotateSpeed / 4 + 0.1), eventBase));
        this.lastGestureScale = e.scale;
        this.lastGestureRotation = e.rotation;
    }
    onGestureend(e) {
        this.preventDefaultWheel(e);
        this.transformEnd();
    }
    destroy() {
        if (this.view) {
            super.destroy();
            this.view = null;
            this.touches = null;
        }
    }
}

const { mineType, fileType } = FileHelper;
Object.assign(Creator, {
    canvas: (options, manager) => new LeaferCanvas(options, manager),
    image: (options) => new LeaferImage(options),
    hitCanvas: (options, manager) => new LeaferCanvas(options, manager),
    interaction: (target, canvas, selector, options) => new Interaction(target, canvas, selector, options),
});
function useCanvas(_canvasType, _power) {
    Platform.origin = {
        createCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        },
        canvasToDataURL: (canvas, type, quality) => canvas.toDataURL(mineType(type), quality),
        canvasToBolb: (canvas, type, quality) => new Promise((resolve) => canvas.toBlob(resolve, mineType(type), quality)),
        canvasSaveAs: (canvas, filename, quality) => {
            return new Promise((resolve) => {
                let el = document.createElement('a');
                el.href = canvas.toDataURL(mineType(fileType(filename)), quality);
                el.download = filename;
                document.body.appendChild(el);
                el.click();
                document.body.removeChild(el);
                resolve();
            });
        },
        loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.setAttribute('crossOrigin', 'anonymous');
                img.crossOrigin = 'anonymous';
                img.onload = () => { resolve(img); };
                img.onerror = (e) => { reject(e); };
                if (!src.startsWith('data:') && Platform.imageSuffix)
                    src += (src.includes("?") ? "&" : "?") + Platform.imageSuffix;
                img.src = src;
            });
        }
    };
    Platform.canvas = Creator.canvas();
    Platform.conicGradientSupport = !!Platform.canvas.context.createConicGradient;
}
Platform.name = 'web';
Platform.isMobile = 'ontouchstart' in window;
Platform.requestRender = function (render) { window.requestAnimationFrame(render); };
Platform.devicePixelRatio = devicePixelRatio;
Platform.realtimeLayout = true;
const { userAgent } = navigator;
if (userAgent.indexOf("Firefox") > -1) {
    Platform.conicGradientRotate90 = true;
    Platform.intWheelDeltaY = true;
    Platform.syncDomFont = true;
}
else if (userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") === -1) {
    Platform.fullImageShadow = true;
}
if (userAgent.indexOf('Windows') > -1) {
    Platform.os = 'Windows';
    Platform.intWheelDeltaY = true;
}
else if (userAgent.indexOf('Mac') > -1) {
    Platform.os = 'Mac';
}
else if (userAgent.indexOf('Linux') > -1) {
    Platform.os = 'Linux';
}

function draw(leafer) {
    const { config } = leafer;
    config.move.dragOut = false;
}

function design(leafer) {
    if (leafer.isApp)
        return;
    leafer.__eventIds.push(leafer.on_(MoveEvent.BEFORE_MOVE, (e) => { LeafHelper.moveWorld(leafer.moveLayer, e.moveX, e.moveY); }), leafer.on_(ZoomEvent.BEFORE_ZOOM, (e) => {
        const { scaleX } = leafer.zoomLayer.__, { min, max } = leafer.config.zoom;
        let { scale } = e;
        if (scale * Math.abs(scaleX) < min)
            scale = min / scaleX;
        else if (scale * Math.abs(scaleX) > max)
            scale = max / scaleX;
        if (scale !== 1)
            LeafHelper.zoomOfWorld(leafer.zoomLayer, e, scale);
    }));
}

const debug$2 = Debug.get('LeaferTypeCreator');
const LeaferTypeCreator = {
    list: {},
    register(name, fn) {
        if (list[name]) {
            debug$2.repeat(name);
        }
        else {
            list[name] = fn;
        }
    },
    run(name, leafer) {
        const fn = LeaferTypeCreator.list[name];
        if (fn) {
            fn(leafer);
        }
        else {
            debug$2.error('no', name);
        }
    }
};
const { list } = LeaferTypeCreator;
LeaferTypeCreator.register('draw', draw);
LeaferTypeCreator.register('user', draw);
LeaferTypeCreator.register('design', design);

const Effect = {};
const Paint = {};
const Animate = {};
const TextConvert$1 = {};
const ColorConvert$1 = {};
const Export$1 = {};

const emptyPaint = {};
const debug$1 = Debug.get('UIData');
class UIData extends LeafData {
    setVisible(value) {
        if (this.__leaf.leafer)
            this.__leaf.leafer.watcher.hasVisible = true;
        this._visible = value;
    }
    setWidth(value) {
        if (value < 0) {
            this._width = -value;
            this.__leaf.scaleX *= -1;
            debug$1.warn('width < 0, instead -scaleX ', this);
        }
        else {
            this._width = value;
        }
    }
    setHeight(value) {
        if (value < 0) {
            this._height = -value;
            this.__leaf.scaleY *= -1;
            debug$1.warn('height < 0, instead -scaleY', this);
        }
        else {
            this._height = value;
        }
    }
    setFill(value) {
        if (this.__naturalWidth)
            this.__naturalWidth = this.__naturalHeight = undefined;
        if (typeof value === 'string' || !value) {
            if (this.__isFills) {
                this.__removeInput('fill');
                Paint.recycleImage('fill', this);
                this.__isFills = false;
            }
            this._fill = value;
        }
        else if (typeof value === 'object') {
            this.__setInput('fill', value);
            this.__leaf.__layout.boxChanged || this.__leaf.__layout.boxChange();
            this.__isFills = true;
            this._fill || (this._fill = emptyPaint);
        }
    }
    setStroke(value) {
        if (typeof value === 'string' || !value) {
            if (this.__isStrokes) {
                this.__removeInput('stroke');
                Paint.recycleImage('stroke', this);
                this.__isStrokes = false;
            }
            this._stroke = value;
        }
        else if (typeof value === 'object') {
            this.__setInput('stroke', value);
            this.__leaf.__layout.boxChanged || this.__leaf.__layout.boxChange();
            this.__isStrokes = true;
            this._stroke || (this._stroke = emptyPaint);
        }
    }
    setShadow(value) {
        this.__setInput('shadow', value);
        if (value instanceof Array) {
            if (value.some((item) => item.visible === false))
                value = value.filter((item) => item.visible !== false);
            this._shadow = value.length ? value : null;
        }
        else if (value) {
            this._shadow = value.visible === false ? null : [value];
        }
        else {
            this._shadow = null;
        }
    }
    setInnerShadow(value) {
        this.__setInput('innerShadow', value);
        if (value instanceof Array) {
            if (value.some((item) => item.visible === false))
                value = value.filter((item) => item.visible !== false);
            this._innerShadow = value.length ? value : null;
        }
        else if (value) {
            this._innerShadow = value.visible === false ? null : [value];
        }
        else {
            this._innerShadow = null;
        }
    }
}
const UnitConvert = {
    number(value, percentRefer) {
        if (typeof value === 'object')
            return value.type === 'percent' ? value.value / 100 * percentRefer : value.value;
        return value;
    }
};

class GroupData extends UIData {
}

class BoxData extends GroupData {
    get __boxStroke() { return true; }
}

class LeaferData extends GroupData {
}

class FrameData extends BoxData {
}

class LineData extends UIData {
}

class RectData extends UIData {
    get __boxStroke() { return true; }
}

class EllipseData extends UIData {
    get __boxStroke() { return true; }
}

class PolygonData extends UIData {
}

class StarData extends UIData {
}

const { parse } = PathConvert;
class PathData extends UIData {
    setPath(value) {
        if (typeof value === 'string') {
            this.__setInput('path', value);
            this._path = parse(value);
        }
        else {
            if (this.__input)
                this.__removeInput('path');
            this._path = value;
        }
    }
}

class PenData extends GroupData {
}

const fontWeightMap = {
    'thin': 100,
    'extra-light': 200,
    'light': 300,
    'normal': 400,
    'medium': 500,
    'semi-bold': 600,
    'bold': 700,
    'extra-bold': 800,
    'black': 900
};
class TextData extends UIData {
    setFontWeight(value) {
        if (typeof value === 'string') {
            this.__setInput('fontWeight', value);
            this._fontWeight = fontWeightMap[value] || 400;
        }
        else {
            if (this.__input)
                this.__removeInput('fontWeight');
            this._fontWeight = value;
        }
    }
}

class ImageData extends RectData {
}

function effectType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                if (value)
                    this.__.__useEffect = true;
                this.__layout.renderChanged || this.__layout.renderChange();
            }
        });
    };
}
function resizeType(defaultValue) {
    return (target, key) => {
        defineLeafAttr(target, key, defaultValue, {
            set(value) {
                this.__setAttr(key, value);
                this.__layout.boxChanged || this.__layout.boxChange();
                this.__updateSize();
            }
        });
    };
}

const UIBounds = {
    __updateStrokeSpread() {
        let width = 0, boxWidth = 0;
        const { stroke, hitStroke, strokeAlign, strokeWidth } = this.__;
        if ((stroke || hitStroke === 'all') && strokeWidth && strokeAlign !== 'inside') {
            boxWidth = width = strokeAlign === 'center' ? strokeWidth / 2 : strokeWidth;
            if (!this.__.__boxStroke) {
                const { miterLimit, strokeCap } = this.__;
                const miterLimitAddWidth = this.__tag !== 'Line' ? 1 / Math.sin(miterLimit * OneRadian / 2) * Math.sqrt(strokeWidth) - width : 0;
                const storkeCapAddWidth = strokeCap === 'none' ? 0 : strokeWidth;
                width += Math.max(miterLimitAddWidth, storkeCapAddWidth);
            }
        }
        this.__layout.strokeBoxSpread = boxWidth;
        return width;
    },
    __updateRenderSpread() {
        let width = 0;
        const { shadow, innerShadow, blur, backgroundBlur } = this.__;
        if (shadow)
            shadow.forEach(item => {
                width = Math.max(width, Math.max(Math.abs(item.y), Math.abs(item.x)) + (item.spread > 0 ? item.spread : 0) + item.blur * 1.5);
            });
        if (blur)
            width = Math.max(width, blur);
        let shapeWidth = width = Math.ceil(width);
        if (innerShadow)
            innerShadow.forEach(item => {
                shapeWidth = Math.max(shapeWidth, Math.max(Math.abs(item.y), Math.abs(item.x)) + (item.spread < 0 ? -item.spread : 0) + item.blur * 1.5);
            });
        if (backgroundBlur)
            shapeWidth = Math.max(shapeWidth, backgroundBlur);
        this.__layout.renderShapeSpread = shapeWidth;
        return width;
    }
};

const UIHit = {
    __updateHitCanvas() {
        if (!this.__hitCanvas)
            this.__hitCanvas = this.leafer.hitCanvasManager.getPathType(this);
        const h = this.__hitCanvas;
        this.__drawHitPath(h);
        h.setStrokeOptions(this.__);
    },
    __hit(inner) {
        const { __hitCanvas: h } = this;
        if (Platform.name === 'miniapp')
            this.__drawHitPath(h);
        const { fill, hitFill, windingRule } = this.__;
        const needHitFill = (fill && hitFill === 'path') || hitFill === 'all';
        const isHitFill = h.hitFill(inner, windingRule);
        if (needHitFill && isHitFill)
            return true;
        const { stroke, hitStroke, strokeWidth, strokeAlign } = this.__;
        const needHitStroke = (stroke && hitStroke === 'path') || hitStroke === 'all';
        const radiusWidth = inner.radiusX * 2;
        let hitWidth = radiusWidth;
        if (needHitStroke) {
            switch (strokeAlign) {
                case 'inside':
                    hitWidth += strokeWidth * 2;
                    if (!needHitFill && (isHitFill && h.hitStroke(inner, hitWidth)))
                        return true;
                    hitWidth = radiusWidth;
                    break;
                case 'center':
                    hitWidth += strokeWidth;
                    break;
                case 'outside':
                    hitWidth += strokeWidth * 2;
                    if (!needHitFill) {
                        if (!isHitFill && h.hitStroke(inner, hitWidth))
                            return true;
                        hitWidth = radiusWidth;
                    }
                    break;
            }
        }
        return hitWidth ? h.hitStroke(inner, hitWidth) : false;
    }
};

const UIRender = {
    __updateChange() {
        const data = this.__;
        if (data.__useEffect) {
            const { shadow, innerShadow, blur, backgroundBlur } = this.__;
            data.__useEffect = !!(shadow || innerShadow || blur || backgroundBlur);
        }
        data.__checkSingle();
        const complex = data.__isFills || data.__isStrokes || data.cornerRadius || data.__useEffect;
        if (complex) {
            data.__complex = true;
        }
        else {
            data.__complex && (data.__complex = false);
        }
    },
    __drawFast(canvas, options) {
        const { fill, stroke, __drawAfterFill } = this.__;
        this.__drawRenderPath(canvas);
        if (fill)
            Paint.fill(fill, this, canvas);
        if (__drawAfterFill)
            this.__drawAfterFill(canvas, options);
        if (stroke)
            Paint.stroke(stroke, this, canvas, options);
    },
    __draw(canvas, options) {
        if (this.__.__complex) {
            const { fill, stroke, __drawAfterFill } = this.__;
            this.__drawRenderPath(canvas);
            if (this.__.__useEffect) {
                const shape = Paint.shape(this, canvas, options);
                const { shadow, innerShadow } = this.__;
                if (shadow)
                    Effect.shadow(this, canvas, shape, options);
                if (fill)
                    this.__.__isFills ? Paint.fills(fill, this, canvas) : Paint.fill(fill, this, canvas);
                if (__drawAfterFill)
                    this.__drawAfterFill(canvas, options);
                if (innerShadow)
                    Effect.innerShadow(this, canvas, shape, options);
                if (stroke)
                    this.__.__isStrokes ? Paint.strokes(stroke, this, canvas, options) : Paint.stroke(stroke, this, canvas, options);
                if (shape.worldCanvas)
                    shape.worldCanvas.recycle();
                shape.canvas.recycle();
            }
            else {
                if (fill)
                    this.__.__isFills ? Paint.fills(fill, this, canvas) : Paint.fill(fill, this, canvas);
                if (__drawAfterFill)
                    this.__drawAfterFill(canvas, options);
                if (stroke)
                    this.__.__isStrokes ? Paint.strokes(stroke, this, canvas, options) : Paint.stroke(stroke, this, canvas, options);
            }
        }
        else {
            this.__drawFast(canvas, options);
        }
    },
    __renderShape(canvas, renderOptions) {
        if (!this.__worldOpacity)
            return;
        canvas.setWorld(this.__world, renderOptions.matrix);
        const { fill, stroke } = this.__;
        this.__drawRenderPath(canvas);
        if (fill)
            Paint.fill('#000000', this, canvas);
        if (stroke)
            Paint.stroke('#000000', this, canvas, renderOptions);
    }
};

const RectRender = {
    __drawFast(canvas, options) {
        const { width, height, fill, stroke, __drawAfterFill } = this.__;
        if (fill) {
            canvas.fillStyle = fill;
            canvas.fillRect(0, 0, width, height);
        }
        if (__drawAfterFill)
            this.__drawAfterFill(canvas, options);
        if (stroke) {
            const { strokeAlign, strokeWidth } = this.__;
            canvas.setStroke(stroke, strokeWidth, this.__);
            const half = strokeWidth / 2;
            switch (strokeAlign) {
                case 'center':
                    canvas.strokeRect(0, 0, width, height);
                    break;
                case 'inside':
                    canvas.strokeRect(half, half, width - strokeWidth, height - strokeWidth);
                    break;
                case 'outside':
                    canvas.strokeRect(-half, -half, width + strokeWidth, height + strokeWidth);
                    break;
            }
        }
    }
};

var UI_1;
let UI = UI_1 = class UI extends Leaf {
    set scale(value) {
        if (typeof value === 'number') {
            this.scaleX = this.scaleY = value;
        }
        else {
            this.scaleX = value.x;
            this.scaleY = value.y;
        }
    }
    get scale() {
        const { scaleX, scaleY } = this;
        return scaleX !== scaleY ? { x: scaleX, y: scaleY } : scaleX;
    }
    constructor(data) {
        super(data);
    }
    set(data) {
        Object.assign(this, data);
    }
    get() {
        return this.__.__getInputData();
    }
    getPath(curve) {
        const path = this.__.path;
        if (!path)
            return [];
        return curve ? PathConvert.toCanvasData(path, true) : path;
    }
    getPathString(curve) {
        return PathConvert.stringify(this.getPath(curve));
    }
    __onUpdateSize() {
        if (this.__.__input) {
            const { fill, stroke } = this.__.__input;
            if (fill)
                Paint.compute('fill', this);
            if (stroke)
                Paint.compute('stroke', this);
        }
    }
    __updateRenderPath() {
        if (this.__.path) {
            const { __: data } = this;
            data.__pathForRender = data.cornerRadius ? PathCorner.smooth(data.path, data.cornerRadius, data.cornerSmoothing) : data.path;
        }
    }
    __drawRenderPath(canvas) {
        canvas.beginPath();
        this.__drawPathByData(canvas, this.__.__pathForRender);
    }
    __drawPath(canvas) {
        canvas.beginPath();
        this.__drawPathByData(canvas, this.__.path);
    }
    __drawPathByData(_drawer, _data) { }
    export(filename, options) {
        return Export$1.export(this, filename, options);
    }
    clone() {
        return UI_1.one(this.toJSON());
    }
    static one(data, x, y, width, height) {
        return UICreator.get(data.tag || this.prototype.__tag, data, x, y, width, height);
    }
    destroy() {
        this.fill = this.stroke = null;
        super.destroy();
    }
};
__decorate([
    dataProcessor(UIData)
], UI.prototype, "__", void 0);
__decorate([
    dataType('')
], UI.prototype, "id", void 0);
__decorate([
    dataType('')
], UI.prototype, "name", void 0);
__decorate([
    dataType('')
], UI.prototype, "className", void 0);
__decorate([
    surfaceType('pass-through')
], UI.prototype, "blendMode", void 0);
__decorate([
    opacityType(1)
], UI.prototype, "opacity", void 0);
__decorate([
    opacityType(true)
], UI.prototype, "visible", void 0);
__decorate([
    maskType(false)
], UI.prototype, "isMask", void 0);
__decorate([
    eraserType(false)
], UI.prototype, "isEraser", void 0);
__decorate([
    sortType(0)
], UI.prototype, "zIndex", void 0);
__decorate([
    dataType()
], UI.prototype, "locked", void 0);
__decorate([
    positionType(0)
], UI.prototype, "x", void 0);
__decorate([
    positionType(0)
], UI.prototype, "y", void 0);
__decorate([
    boundsType(100)
], UI.prototype, "width", void 0);
__decorate([
    boundsType(100)
], UI.prototype, "height", void 0);
__decorate([
    scaleType(1)
], UI.prototype, "scaleX", void 0);
__decorate([
    scaleType(1)
], UI.prototype, "scaleY", void 0);
__decorate([
    rotationType(0)
], UI.prototype, "rotation", void 0);
__decorate([
    rotationType(0)
], UI.prototype, "skewX", void 0);
__decorate([
    rotationType(0)
], UI.prototype, "skewY", void 0);
__decorate([
    positionType()
], UI.prototype, "around", void 0);
__decorate([
    dataType(false)
], UI.prototype, "draggable", void 0);
__decorate([
    hitType(true)
], UI.prototype, "hittable", void 0);
__decorate([
    hitType('path')
], UI.prototype, "hitFill", void 0);
__decorate([
    strokeType('path')
], UI.prototype, "hitStroke", void 0);
__decorate([
    hitType(true)
], UI.prototype, "hitChildren", void 0);
__decorate([
    hitType(true)
], UI.prototype, "hitSelf", void 0);
__decorate([
    hitType()
], UI.prototype, "hitRadius", void 0);
__decorate([
    cursorType('')
], UI.prototype, "cursor", void 0);
__decorate([
    surfaceType()
], UI.prototype, "fill", void 0);
__decorate([
    strokeType()
], UI.prototype, "stroke", void 0);
__decorate([
    strokeType('inside')
], UI.prototype, "strokeAlign", void 0);
__decorate([
    strokeType(1)
], UI.prototype, "strokeWidth", void 0);
__decorate([
    strokeType('none')
], UI.prototype, "strokeCap", void 0);
__decorate([
    strokeType('miter')
], UI.prototype, "strokeJoin", void 0);
__decorate([
    strokeType()
], UI.prototype, "dashPattern", void 0);
__decorate([
    strokeType()
], UI.prototype, "dashOffset", void 0);
__decorate([
    strokeType(10)
], UI.prototype, "miterLimit", void 0);
__decorate([
    pathType()
], UI.prototype, "cornerRadius", void 0);
__decorate([
    pathType()
], UI.prototype, "cornerSmoothing", void 0);
__decorate([
    effectType()
], UI.prototype, "shadow", void 0);
__decorate([
    effectType()
], UI.prototype, "innerShadow", void 0);
__decorate([
    effectType()
], UI.prototype, "blur", void 0);
__decorate([
    effectType()
], UI.prototype, "backgroundBlur", void 0);
__decorate([
    effectType()
], UI.prototype, "grayscale", void 0);
__decorate([
    rewrite(PathDrawer.drawPathByData)
], UI.prototype, "__drawPathByData", null);
UI = UI_1 = __decorate([
    useModule(UIBounds),
    useModule(UIHit),
    useModule(UIRender),
    rewriteAble()
], UI);

let Group = class Group extends UI {
    get __tag() { return 'Group'; }
    get resizeable() { return false; }
    set mask(child) {
        if (this.__hasMask)
            this.__removeMask();
        if (child) {
            child.isMask = true;
            this.addAt(child, 0);
        }
    }
    get mask() {
        return this.children.find(item => item.isMask);
    }
    constructor(data) {
        super(data);
        this.__setBranch();
    }
    __setBranch() {
        this.isBranch = true;
        if (!this.children)
            this.children = [];
    }
    set(data) {
        if (data.children) {
            const { children } = data;
            delete data.children;
            if (!this.children)
                this.__setBranch();
            super.set(data);
            let child;
            children.forEach(childData => {
                child = UICreator.get(childData.tag, childData);
                this.add(child);
            });
            data.children = children;
        }
        else {
            super.set(data);
        }
    }
    toJSON() {
        const data = super.toJSON();
        data.children = this.children.map(child => child.toJSON());
        return data;
    }
    addAt(child, index) {
        this.add(child, index);
    }
    addAfter(child, after) {
        this.add(child, this.children.indexOf(after) + 1);
    }
    addBefore(child, before) {
        this.add(child, this.children.indexOf(before));
    }
    add(_child, _index) { }
    addMany(..._children) { }
    remove(_child, _destroy) { }
    removeAll(_destroy) { }
};
__decorate([
    dataProcessor(GroupData)
], Group.prototype, "__", void 0);
Group = __decorate([
    useModule(Branch),
    registerUI()
], Group);

let Rect = class Rect extends UI {
    get __tag() { return 'Rect'; }
    constructor(data) {
        super(data);
    }
    __drawPathByData(drawer, _data) {
        const { width, height, cornerRadius } = this.__;
        if (cornerRadius) {
            drawer.roundRect(0, 0, width, height, cornerRadius);
        }
        else {
            drawer.rect(0, 0, width, height);
        }
    }
};
__decorate([
    dataProcessor(RectData)
], Rect.prototype, "__", void 0);
Rect = __decorate([
    useModule(RectRender),
    registerUI()
], Rect);

const rect = Rect.prototype;
const group = Group.prototype;
const bounds$1 = {};
const { copy: copy$2, add } = BoundsHelper;
let Box = class Box extends Group {
    get __tag() { return 'Box'; }
    get resizeable() { return true; }
    constructor(data) {
        super(data);
        this.isBranchLeaf = true;
        this.__layout.renderChanged || this.__layout.renderChange();
    }
    __updateStrokeSpread() { return 0; }
    __updateRectRenderSpread() { return 0; }
    __updateRenderSpread() {
        let width = this.__updateRectRenderSpread() || super.__updateRenderSpread();
        this.__.__drawAfterFill = this.__.overflow === 'hide';
        if (!width)
            width = this.__.__drawAfterFill ? 0 : 1;
        return width;
    }
    __updateBoxBounds() { }
    __updateStrokeBounds() { }
    __updateRenderBounds() {
        this.__updateRectRenderBounds();
        if (!this.__.__drawAfterFill) {
            const { renderBounds } = this.__layout;
            copy$2(bounds$1, renderBounds);
            super.__updateRenderBounds();
            add(renderBounds, bounds$1);
        }
    }
    __updateRectRenderBounds() { }
    __updateRectChange() { }
    __updateChange() {
        super.__updateChange();
        this.__updateRectChange();
    }
    __drawPathByData(_drawer, _data) { }
    __renderRect(_canvas, _options) { }
    __renderGroup(_canvas, _options) { }
    __render(canvas, options) {
        if (this.__.__drawAfterFill) {
            this.__renderRect(canvas, options);
        }
        else {
            this.__renderRect(canvas, options);
            this.__renderGroup(canvas, options);
        }
    }
    __drawAfterFill(canvas, options) {
        canvas.save();
        canvas.clip();
        this.__renderGroup(canvas, options);
        canvas.restore();
        if (this.__.stroke)
            this.__drawRenderPath(canvas);
    }
};
__decorate([
    dataProcessor(BoxData)
], Box.prototype, "__", void 0);
__decorate([
    affectRenderBoundsType('show')
], Box.prototype, "overflow", void 0);
__decorate([
    rewrite(rect.__updateStrokeSpread)
], Box.prototype, "__updateStrokeSpread", null);
__decorate([
    rewrite(rect.__updateRenderSpread)
], Box.prototype, "__updateRectRenderSpread", null);
__decorate([
    rewrite(rect.__updateBoxBounds)
], Box.prototype, "__updateBoxBounds", null);
__decorate([
    rewrite(rect.__updateStrokeBounds)
], Box.prototype, "__updateStrokeBounds", null);
__decorate([
    rewrite(rect.__updateRenderBounds)
], Box.prototype, "__updateRectRenderBounds", null);
__decorate([
    rewrite(rect.__updateChange)
], Box.prototype, "__updateRectChange", null);
__decorate([
    rewrite(rect.__drawPathByData)
], Box.prototype, "__drawPathByData", null);
__decorate([
    rewrite(rect.__render)
], Box.prototype, "__renderRect", null);
__decorate([
    rewrite(group.__render)
], Box.prototype, "__renderGroup", null);
Box = __decorate([
    rewriteAble(),
    registerUI()
], Box);

let Frame = class Frame extends Box {
    get __tag() { return 'Frame'; }
    constructor(data) {
        super(data);
        if (!this.__.fill)
            this.__.fill = '#FFFFFF';
    }
};
__decorate([
    dataProcessor(FrameData)
], Frame.prototype, "__", void 0);
__decorate([
    affectRenderBoundsType('hide')
], Frame.prototype, "overflow", void 0);
Frame = __decorate([
    registerUI()
], Frame);

const { moveTo: moveTo$3, closePath: closePath$2, ellipse } = PathCommandDataHelper;
let Ellipse = class Ellipse extends UI {
    get __tag() { return 'Ellipse'; }
    constructor(data) {
        super(data);
    }
    __updatePath() {
        const { width, height, innerRadius, startAngle, endAngle } = this.__;
        const rx = width / 2, ry = height / 2;
        const path = this.__.path = [];
        if (innerRadius) {
            if (startAngle || endAngle) {
                if (innerRadius < 1)
                    ellipse(path, rx, ry, rx * innerRadius, ry * innerRadius, 0, startAngle, endAngle, false);
                ellipse(path, rx, ry, rx, ry, 0, endAngle, startAngle, true);
                if (innerRadius < 1)
                    closePath$2(path);
            }
            else {
                if (innerRadius < 1) {
                    ellipse(path, rx, ry, rx * innerRadius, ry * innerRadius);
                    moveTo$3(path, width, ry);
                }
                ellipse(path, rx, ry, rx, ry, 0, 0, 360, true);
            }
        }
        else {
            if (startAngle || endAngle) {
                moveTo$3(path, rx, ry);
                ellipse(path, rx, ry, rx, ry, 0, startAngle, endAngle, false);
                closePath$2(path);
            }
            else {
                ellipse(path, rx, ry, rx, ry);
            }
        }
    }
};
__decorate([
    dataProcessor(EllipseData)
], Ellipse.prototype, "__", void 0);
__decorate([
    pathType(0)
], Ellipse.prototype, "innerRadius", void 0);
__decorate([
    pathType(0)
], Ellipse.prototype, "startAngle", void 0);
__decorate([
    pathType(0)
], Ellipse.prototype, "endAngle", void 0);
Ellipse = __decorate([
    registerUI()
], Ellipse);

const { sin: sin$1, cos: cos$1, PI: PI$1 } = Math;
const { moveTo: moveTo$2, lineTo: lineTo$2, closePath: closePath$1, drawPoints: drawPoints$1 } = PathCommandDataHelper;
const { toBounds: toBounds$2 } = PathBounds;
let Polygon = class Polygon extends UI {
    get __tag() { return 'Polygon'; }
    get resizeable() { return !this.points; }
    constructor(data) {
        super(data);
    }
    __updatePath() {
        const path = this.__.path = [];
        if (this.__.points) {
            drawPoints$1(path, this.__.points, false, true);
        }
        else {
            const { width, height, sides } = this.__;
            const rx = width / 2, ry = height / 2;
            moveTo$2(path, rx, 0);
            for (let i = 1; i < sides; i++) {
                lineTo$2(path, rx + rx * sin$1((i * 2 * PI$1) / sides), ry - ry * cos$1((i * 2 * PI$1) / sides));
            }
        }
        closePath$1(path);
    }
    __updateRenderPath() {
        if (this.__.points && this.__.curve) {
            drawPoints$1(this.__.__pathForRender = [], this.__.points, this.__.curve, true);
        }
        else {
            super.__updateRenderPath();
        }
    }
    __updateBoxBounds() {
        if (this.__.points) {
            toBounds$2(this.__.__pathForRender, this.__layout.boxBounds);
            this.__updateNaturalSize();
        }
        else {
            super.__updateBoxBounds();
        }
    }
};
__decorate([
    dataProcessor(PolygonData)
], Polygon.prototype, "__", void 0);
__decorate([
    pathType(3)
], Polygon.prototype, "sides", void 0);
__decorate([
    pathType()
], Polygon.prototype, "points", void 0);
__decorate([
    pathType(0)
], Polygon.prototype, "curve", void 0);
Polygon = __decorate([
    registerUI()
], Polygon);

const { sin, cos, PI } = Math;
const { moveTo: moveTo$1, lineTo: lineTo$1, closePath } = PathCommandDataHelper;
let Star = class Star extends UI {
    get __tag() { return 'Star'; }
    constructor(data) {
        super(data);
    }
    __updatePath() {
        const { width, height, corners, innerRadius } = this.__;
        const rx = width / 2, ry = height / 2;
        const path = this.__.path = [];
        moveTo$1(path, rx, 0);
        for (let i = 1; i < corners * 2; i++) {
            lineTo$1(path, rx + (i % 2 === 0 ? rx : rx * innerRadius) * sin((i * PI) / corners), ry - (i % 2 === 0 ? ry : ry * innerRadius) * cos((i * PI) / corners));
        }
        closePath(path);
    }
};
__decorate([
    dataProcessor(StarData)
], Star.prototype, "__", void 0);
__decorate([
    pathType(5)
], Star.prototype, "corners", void 0);
__decorate([
    pathType(0.382)
], Star.prototype, "innerRadius", void 0);
Star = __decorate([
    registerUI()
], Star);

const { moveTo, lineTo, drawPoints } = PathCommandDataHelper;
const { rotate: rotate$1, getAngle: getAngle$2, getDistance: getDistance$2, defaultPoint } = PointHelper;
const { toBounds: toBounds$1 } = PathBounds;
let Line = class Line extends UI {
    get __tag() { return 'Line'; }
    get resizeable() { return !this.points; }
    get toPoint() {
        const { width, rotation } = this.__;
        const to = { x: 0, y: 0 };
        if (width)
            to.x = width;
        if (rotation)
            rotate$1(to, rotation);
        return to;
    }
    set toPoint(value) {
        this.width = getDistance$2(defaultPoint, value);
        this.rotation = getAngle$2(defaultPoint, value);
        if (this.height)
            this.height = 0;
    }
    constructor(data) {
        super(data);
    }
    __updatePath() {
        const path = this.__.path = [];
        if (this.__.points) {
            drawPoints(path, this.__.points, false);
        }
        else {
            moveTo(path, 0, 0);
            lineTo(path, this.width, 0);
        }
    }
    __updateRenderPath() {
        if (this.__.points && this.__.curve) {
            drawPoints(this.__.__pathForRender = [], this.__.points, this.__.curve, false);
        }
        else {
            super.__updateRenderPath();
        }
    }
    __updateBoxBounds() {
        if (this.points) {
            toBounds$1(this.__.__pathForRender, this.__layout.boxBounds);
            this.__updateNaturalSize();
        }
        else {
            super.__updateBoxBounds();
        }
    }
};
__decorate([
    dataProcessor(LineData)
], Line.prototype, "__", void 0);
__decorate([
    affectStrokeBoundsType('center')
], Line.prototype, "strokeAlign", void 0);
__decorate([
    boundsType(0)
], Line.prototype, "height", void 0);
__decorate([
    pathType()
], Line.prototype, "points", void 0);
__decorate([
    pathType(0)
], Line.prototype, "curve", void 0);
Line = __decorate([
    registerUI()
], Line);

let Image$1 = class Image extends Rect {
    get __tag() { return 'Image'; }
    get ready() { return this.image ? this.image.ready : false; }
    constructor(data) {
        super(data);
    }
    __updateBoxBounds() {
        let update;
        const { url } = this;
        const fill = this.fill;
        if (fill) {
            if (fill.url !== url)
                update = true;
        }
        else {
            if (url)
                update = true;
        }
        if (update) {
            if (this.image)
                this.image = null;
            this.fill = url ? { type: 'image', mode: 'strench', url } : undefined;
            this.once(ImageEvent.LOADED, (e) => this.image = e.image);
        }
        super.__updateBoxBounds();
    }
    destroy() {
        this.image = null;
        super.destroy();
    }
};
__decorate([
    dataProcessor(ImageData)
], Image$1.prototype, "__", void 0);
__decorate([
    boundsType('')
], Image$1.prototype, "url", void 0);
Image$1 = __decorate([
    registerUI()
], Image$1);

let Canvas = class Canvas extends Rect {
    get __tag() { return 'Canvas'; }
    constructor(data) {
        super(data);
        this.canvas = Creator.canvas(this.__);
        this.context = this.canvas.context;
        this.__.__drawAfterFill = true;
    }
    draw(ui, offset, scale, rotation) {
        ui.__layout.checkUpdate();
        const matrix = new Matrix(ui.__world);
        matrix.invert();
        const m = new Matrix();
        if (offset)
            m.translate(offset.x, offset.y);
        if (scale)
            typeof scale === 'number' ? m.scale(scale) : m.scale(scale.x, scale.y);
        if (rotation)
            m.rotate(rotation);
        matrix.preMultiply(m);
        ui.__render(this.canvas, { matrix });
        this.paint();
    }
    paint() {
        this.forceUpdate('fill');
    }
    __drawAfterFill(canvas, _options) {
        const origin = this.canvas.view;
        const { width, height } = this;
        if (this.__.cornerRadius) {
            canvas.save();
            canvas.clip();
            canvas.drawImage(this.canvas.view, 0, 0, origin.width, origin.height, 0, 0, width, height);
            canvas.restore();
        }
        else {
            canvas.drawImage(this.canvas.view, 0, 0, origin.width, origin.height, 0, 0, width, height);
        }
    }
    __updateSize() {
        const { canvas } = this;
        if (canvas) {
            const { smooth } = this.__;
            if (canvas.smooth !== smooth)
                canvas.smooth = smooth;
            canvas.resize(this.__);
        }
    }
    destroy() {
        if (this.canvas) {
            this.canvas.destroy();
            this.canvas = null;
            this.context = null;
        }
        super.destroy();
    }
};
__decorate([
    dataProcessor(ImageData)
], Canvas.prototype, "__", void 0);
__decorate([
    resizeType(100)
], Canvas.prototype, "width", void 0);
__decorate([
    resizeType(100)
], Canvas.prototype, "height", void 0);
__decorate([
    resizeType(Platform.devicePixelRatio)
], Canvas.prototype, "pixelRatio", void 0);
__decorate([
    resizeType(true)
], Canvas.prototype, "smooth", void 0);
__decorate([
    hitType('all')
], Canvas.prototype, "hitFill", void 0);
Canvas = __decorate([
    registerUI()
], Canvas);

const { copyAndSpread, includes, spread } = BoundsHelper;
let Text = class Text extends UI {
    get __tag() { return 'Text'; }
    get textDrawData() {
        this.__layout.checkUpdate();
        return this.__.__textDrawData;
    }
    constructor(data) {
        super(data);
    }
    __drawHitPath(canvas) {
        const { __lineHeight, __baseLine, __textDrawData: data } = this.__;
        canvas.beginPath();
        if (this.__.__letterSpacing < 0) {
            this.__drawPathByData(canvas);
        }
        else {
            data.rows.forEach(row => canvas.rect(row.x, row.y - __baseLine, row.width, __lineHeight));
        }
    }
    __drawPathByData(drawer, _data) {
        const { x, y, width, height } = this.__layout.boxBounds;
        drawer.rect(x, y, width, height);
    }
    __drawRenderPath(canvas) {
        canvas.font = this.__.__font;
    }
    __updateTextDrawData() {
        const data = this.__;
        data.__textDrawData = TextConvert$1.getDrawData(data.text, this.__);
    }
    __updateBoxBounds() {
        const data = this.__;
        const layout = this.__layout;
        const { lineHeight, letterSpacing, fontFamily, fontSize, fontWeight, italic, textCase } = data;
        data.__lineHeight = UnitConvert.number(lineHeight, fontSize);
        data.__letterSpacing = UnitConvert.number(letterSpacing, fontSize);
        data.__baseLine = data.__lineHeight - (data.__lineHeight - fontSize * 0.7) / 2;
        data.__font = `${italic ? 'italic ' : ''}${textCase === 'small-caps' ? 'small-caps ' : ''}${fontWeight !== 'normal' ? fontWeight + ' ' : ''}${fontSize}px ${fontFamily}`;
        this.__updateTextDrawData();
        const { bounds } = data.__textDrawData;
        const b = layout.boxBounds;
        if (data.__lineHeight < fontSize)
            spread(bounds, fontSize / 2);
        const width = data.__getInput('width');
        const height = data.__getInput('height');
        if (width && height) {
            super.__updateBoxBounds();
        }
        else {
            b.x = width ? 0 : bounds.x;
            b.y = height ? 0 : bounds.y;
            b.width = width ? width : bounds.width;
            b.height = height ? height : bounds.height;
            this.__updateNaturalSize();
        }
        const contentBounds = includes(b, bounds) ? b : bounds;
        if (contentBounds !== layout.contentBounds) {
            layout.contentBounds = contentBounds;
            layout.renderChanged = true;
        }
    }
    __updateRenderSpread() {
        let width = super.__updateRenderSpread();
        if (!width)
            width = this.__layout.boxBounds === this.__layout.contentBounds ? 0 : 1;
        return width;
    }
    __updateRenderBounds() {
        copyAndSpread(this.__layout.renderBounds, this.__layout.contentBounds, this.__layout.renderSpread);
    }
};
__decorate([
    dataProcessor(TextData)
], Text.prototype, "__", void 0);
__decorate([
    boundsType(0)
], Text.prototype, "width", void 0);
__decorate([
    boundsType(0)
], Text.prototype, "height", void 0);
__decorate([
    boundsType(0)
], Text.prototype, "padding", void 0);
__decorate([
    affectStrokeBoundsType('outside')
], Text.prototype, "strokeAlign", void 0);
__decorate([
    boundsType('')
], Text.prototype, "text", void 0);
__decorate([
    boundsType('L')
], Text.prototype, "fontFamily", void 0);
__decorate([
    boundsType(12)
], Text.prototype, "fontSize", void 0);
__decorate([
    boundsType('normal')
], Text.prototype, "fontWeight", void 0);
__decorate([
    boundsType(false)
], Text.prototype, "italic", void 0);
__decorate([
    boundsType('none')
], Text.prototype, "textCase", void 0);
__decorate([
    boundsType('none')
], Text.prototype, "textDecoration", void 0);
__decorate([
    boundsType(0)
], Text.prototype, "letterSpacing", void 0);
__decorate([
    boundsType({ type: 'percent', value: 150 })
], Text.prototype, "lineHeight", void 0);
__decorate([
    boundsType(0)
], Text.prototype, "paraIndent", void 0);
__decorate([
    boundsType(0)
], Text.prototype, "paraSpacing", void 0);
__decorate([
    boundsType('left')
], Text.prototype, "textAlign", void 0);
__decorate([
    boundsType('top')
], Text.prototype, "verticalAlign", void 0);
__decorate([
    boundsType('show')
], Text.prototype, "textOverflow", void 0);
Text = __decorate([
    registerUI()
], Text);

const { toBounds } = PathBounds;
let Path = class Path extends UI {
    get __tag() { return 'Path'; }
    get resizeable() { return false; }
    constructor(data) {
        super(data);
    }
    __updateBoxBounds() {
        toBounds(this.__.path, this.__layout.boxBounds);
        this.__updateNaturalSize();
    }
};
__decorate([
    dataProcessor(PathData)
], Path.prototype, "__", void 0);
__decorate([
    pathType()
], Path.prototype, "path", void 0);
__decorate([
    pathType()
], Path.prototype, "windingRule", void 0);
__decorate([
    affectStrokeBoundsType('center')
], Path.prototype, "strokeAlign", void 0);
Path = __decorate([
    registerUI()
], Path);

let Pen = class Pen extends Group {
    get __tag() { return 'Pen'; }
    constructor(data) {
        super(data);
    }
    setStyle(data) {
        const path = this.pathElement = new Path(data);
        this.pathStyle = data;
        this.path = path.path || (path.path = []);
        this.add(path);
        return this;
    }
    beginPath() {
        this.path.length = 0;
        this.paint();
        return this;
    }
    moveTo(_x, _y) { return this; }
    lineTo(_x, _y) { return this; }
    bezierCurveTo(_x1, _y1, _x2, _y2, _x, _y) { return this; }
    quadraticCurveTo(_x1, _y1, _x, _y) { return this; }
    closePath() { return this; }
    rect(_x, _y, _width, _height) { return this; }
    roundRect(_x, _y, _width, _height, _cornerRadius) { return this; }
    ellipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) { return this; }
    arc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) { return this; }
    arcTo(_x1, _y1, _x2, _y2, _radius) { return this; }
    drawEllipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) { return this; }
    drawArc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) { return this; }
    drawPoints(_points, _curve, _close) { return this; }
    paint() {
        this.pathElement.forceUpdate('path');
    }
    clear() {
        this.removeAll(true);
    }
};
__decorate([
    dataProcessor(PenData)
], Pen.prototype, "__", void 0);
Pen = __decorate([
    useModule(PathCreator, ['beginPath']),
    registerUI()
], Pen);

const debug = Debug.get('Leafer');
let Leafer = class Leafer extends Group {
    get __tag() { return 'Leafer'; }
    get isApp() { return false; }
    get app() { return this.parent || this; }
    constructor(userConfig, data) {
        super(data);
        this.zoomLayer = this;
        this.moveLayer = this;
        this.config = {
            type: 'design',
            start: true,
            hittable: true,
            smooth: true,
            zoom: {
                min: 0.02,
                max: 256
            },
            move: {
                holdSpaceKey: true,
                dragOut: true,
                autoDistance: 2
            }
        };
        this.__eventIds = [];
        this.__controllers = [];
        this.__readyWait = [];
        this.__viewReadyWait = [];
        this.__viewCompletedWait = [];
        this.__nextRenderWait = [];
        this.userConfig = userConfig;
        if (userConfig && (userConfig.view || userConfig.width))
            this.init(userConfig);
    }
    init(userConfig, parentApp) {
        if (this.canvas)
            return;
        this.__setLeafer(this);
        if (userConfig)
            DataHelper.assign(this.config, userConfig);
        let start;
        const { config } = this;
        LeaferTypeCreator.run(config.type, this);
        this.canvas = Creator.canvas(config);
        this.__controllers.push(this.renderer = Creator.renderer(this, this.canvas, config), this.watcher = Creator.watcher(this, config), this.layouter = Creator.layouter(this, config));
        if (this.isApp)
            this.__setApp();
        this.__checkAutoLayout(config);
        this.view = this.canvas.view;
        if (parentApp) {
            this.__bindApp(parentApp);
            start = parentApp.running;
        }
        else {
            this.selector = Creator.selector(this);
            this.__controllers.unshift(this.interaction = Creator.interaction(this, this.canvas, this.selector, config));
            this.canvasManager = new CanvasManager();
            this.hitCanvasManager = new HitCanvasManager();
            start = config.start;
        }
        this.hittable = config.hittable;
        this.fill = config.fill;
        this.canvasManager.add(this.canvas);
        this.__listenEvents();
        if (start)
            this.__startTimer = setTimeout(this.start.bind(this));
        PluginManager.onLeafer(this);
    }
    set(data) {
        if (!this.children) {
            setTimeout(() => {
                super.set(data);
            });
        }
        else {
            super.set(data);
        }
    }
    start() {
        clearTimeout(this.__startTimer);
        if (!this.running && this.canvas) {
            this.ready ? this.emitLeafer(LeaferEvent.RESTART) : this.emitLeafer(LeaferEvent.START);
            this.__controllers.forEach(item => item.start());
            if (!this.isApp)
                this.renderer.render();
            this.running = true;
        }
    }
    stop() {
        clearTimeout(this.__startTimer);
        if (this.running && this.canvas) {
            this.__controllers.forEach(item => item.stop());
            this.running = false;
            this.emitLeafer(LeaferEvent.STOP);
        }
    }
    resize(size) {
        const data = DataHelper.copyAttrs({}, size, canvasSizeAttrs);
        Object.keys(data).forEach(key => this[key] = data[key]);
    }
    forceLayout() {
        this.__layout.checkUpdate(true);
    }
    forceFullRender() {
        this.renderer.addBlock(this.canvas.bounds);
        if (this.viewReady)
            this.renderer.update();
    }
    updateCursor() {
        if (this.interaction)
            this.interaction.updateCursor();
    }
    __doResize(size) {
        if (!this.canvas || this.canvas.isSameSize(size))
            return;
        const old = DataHelper.copyAttrs({}, this.canvas, canvasSizeAttrs);
        this.canvas.resize(size);
        this.__onResize(new ResizeEvent(size, old));
    }
    __onResize(event) {
        this.emitEvent(event);
        DataHelper.copyAttrs(this.__, event, canvasSizeAttrs);
        setTimeout(() => { if (this.canvasManager)
            this.canvasManager.clearRecycled(); }, 0);
    }
    __setApp() { }
    __bindApp(app) {
        this.selector = app.selector;
        this.interaction = app.interaction;
        this.canvasManager = app.canvasManager;
        this.hitCanvasManager = app.hitCanvasManager;
    }
    __setLeafer(leafer) {
        this.leafer = leafer;
        this.isLeafer = !!leafer;
        this.__level = 1;
    }
    setZoomLayer(zoomLayer, moveLayer) {
        this.zoomLayer = zoomLayer;
        this.moveLayer = moveLayer || zoomLayer;
    }
    __checkAutoLayout(config) {
        if (!config.width || !config.height) {
            this.autoLayout = new AutoBounds(config);
            this.canvas.startAutoLayout(this.autoLayout, this.__onResize.bind(this));
        }
    }
    __setAttr(attrName, newValue) {
        if (this.canvas) {
            if (canvasSizeAttrs.includes(attrName)) {
                this.__changeCanvasSize(attrName, newValue);
            }
            else if (attrName === 'fill') {
                this.__changeFill(newValue);
            }
            else if (attrName === 'hittable') {
                this.canvas.hittable = newValue;
            }
        }
        super.__setAttr(attrName, newValue);
    }
    __getAttr(attrName) {
        if (this.canvas && canvasSizeAttrs.includes(attrName))
            return this.canvas[attrName];
        return super.__getAttr(attrName);
    }
    __changeCanvasSize(attrName, newValue) {
        const data = DataHelper.copyAttrs({}, this.canvas, canvasSizeAttrs);
        data[attrName] = this.config[attrName] = newValue;
        if (newValue)
            this.canvas.stopAutoLayout();
        this.__doResize(data);
    }
    __changeFill(newValue) {
        this.config.fill = newValue;
        if (this.canvas.allowBackgroundColor) {
            this.canvas.backgroundColor = newValue;
        }
        else {
            this.forceFullRender();
        }
    }
    __onCreated() {
        this.created = true;
    }
    __onReady() {
        if (this.ready)
            return;
        this.ready = true;
        this.emitLeafer(LeaferEvent.BEFORE_READY);
        this.emitLeafer(LeaferEvent.READY);
        this.emitLeafer(LeaferEvent.AFTER_READY);
        WaitHelper.run(this.__readyWait);
    }
    __onViewReady() {
        if (this.viewReady)
            return;
        this.viewReady = true;
        this.emitLeafer(LeaferEvent.VIEW_READY);
        WaitHelper.run(this.__viewReadyWait);
    }
    __onRenderEnd(_e) {
        if (!this.viewReady)
            this.__onViewReady();
        const completed = this.__checkViewCompleted();
        if (completed)
            this.__onViewCompleted();
        this.viewCompleted = completed;
        WaitHelper.run(this.__nextRenderWait);
    }
    __checkViewCompleted() {
        return this.viewReady && !this.watcher.changed && ImageManager.isComplete;
    }
    __onViewCompleted() {
        if (!this.viewCompleted) {
            this.emitLeafer(LeaferEvent.VIEW_COMPLETED);
            WaitHelper.run(this.__viewCompletedWait);
        }
    }
    __onWatchData() {
        if (this.watcher.childrenChanged && this.interaction) {
            this.nextRender(() => this.interaction.updateCursor());
        }
    }
    waitReady(item) {
        this.ready ? item() : this.__readyWait.push(item);
    }
    waitViewReady(item) {
        this.viewReady ? item() : this.__viewReadyWait.push(item);
    }
    waitViewCompleted(item) {
        if (this.viewCompleted) {
            item();
        }
        else {
            this.__viewCompletedWait.push(item);
            if (!this.running)
                this.start();
        }
    }
    nextRender(item) {
        if (this.watcher && !this.watcher.changed) {
            item();
        }
        else {
            this.__nextRenderWait.push(item);
        }
    }
    __checkUpdateLayout() {
        this.__layout.checkUpdate();
    }
    emitLeafer(type) {
        this.emitEvent(new LeaferEvent(type, this));
    }
    __listenEvents() {
        const runId = Run.start('FirstCreate ' + this.innerName);
        this.once(LeaferEvent.START, () => Run.end(runId));
        this.once(LayoutEvent.END, () => this.__onReady());
        this.once(RenderEvent.START, () => this.__onCreated());
        this.__eventIds.push(this.on_(WatchEvent.DATA, this.__onWatchData, this), this.on_(RenderEvent.END, this.__onRenderEnd, this), this.on_(LayoutEvent.CHECK_UPDATE, this.__checkUpdateLayout, this));
    }
    __removeListenEvents() {
        this.off_(this.__eventIds);
        this.__eventIds.length = 0;
    }
    destroy() {
        setTimeout(() => {
            if (!this.destroyed) {
                try {
                    this.stop();
                    this.emitEvent(new LeaferEvent(LeaferEvent.END, this));
                    this.__removeListenEvents();
                    this.__controllers.forEach(item => {
                        if (!(this.parent && item === this.interaction))
                            item.destroy();
                    });
                    this.__controllers.length = 0;
                    if (!this.parent) {
                        this.selector.destroy();
                        this.canvasManager.destroy();
                        this.hitCanvasManager.destroy();
                    }
                    this.canvas.destroy();
                    this.config.view = this.view = null;
                    if (this.userConfig)
                        this.userConfig.view = null;
                    super.destroy();
                    setTimeout(() => { ImageManager.clearRecycled(); }, 100);
                }
                catch (e) {
                    debug.error(e);
                }
            }
        });
    }
};
__decorate([
    dataProcessor(LeaferData)
], Leafer.prototype, "__", void 0);
__decorate([
    boundsType()
], Leafer.prototype, "pixelRatio", void 0);
Leafer = __decorate([
    registerUI()
], Leafer);

let App = class App extends Leafer {
    get __tag() { return 'App'; }
    get isApp() { return true; }
    __setApp() {
        const { canvas } = this;
        const { realCanvas, view } = this.config;
        if (realCanvas || view === this.canvas.view || !canvas.parentView) {
            this.realCanvas = true;
        }
        else {
            canvas.unrealCanvas();
        }
        this.leafer = this;
        this.watcher.disable();
        this.layouter.disable();
        this.__eventIds.push(this.on_(PropertyEvent.CHANGE, this.__onPropertyChange, this));
    }
    start() {
        super.start();
        this.children.forEach(leafer => { leafer.start(); });
    }
    stop() {
        this.children.forEach(leafer => { leafer.stop(); });
        super.stop();
    }
    addLeafer(merge) {
        const leafer = new Leafer(merge);
        this.add(leafer);
        return leafer;
    }
    add(leafer) {
        if (!leafer.view) {
            if (this.realCanvas && !this.canvas.bounds) {
                setTimeout(() => this.add(leafer), 10);
                return;
            }
            leafer.init(this.__getChildConfig(leafer.userConfig), this);
        }
        super.add(leafer);
        this.__listenChildEvents(leafer);
    }
    __onPropertyChange() {
        if (Debug.showHitView)
            this.children.forEach(leafer => { leafer.forceUpdate('surface'); });
    }
    __onCreated() {
        this.created = this.children.every(child => child.created);
    }
    __onReady() {
        if (this.children.every(child => child.ready))
            super.__onReady();
    }
    __onViewReady() {
        if (this.children.every(child => child.viewReady))
            super.__onViewReady();
    }
    __checkViewCompleted() {
        return this.children.every(item => item.viewCompleted);
    }
    __onChildRenderEnd(e) {
        this.renderer.addBlock(e.renderBounds);
        if (this.viewReady)
            this.renderer.update();
    }
    __render(canvas, _options) {
        this.children.forEach(leafer => { canvas.copyWorld(leafer.canvas); });
    }
    __onResize(event) {
        this.children.forEach(leafer => { leafer.resize(event); });
        super.__onResize(event);
    }
    __checkUpdateLayout() {
        this.children.forEach(leafer => { leafer.__layout.checkUpdate(); });
    }
    __getChildConfig(userConfig) {
        let config = Object.assign({}, this.config);
        config.hittable = config.realCanvas = undefined;
        if (userConfig)
            DataHelper.assign(config, userConfig);
        if (this.autoLayout)
            DataHelper.copyAttrs(config, this, canvasSizeAttrs);
        config.view = this.realCanvas ? undefined : this.view;
        config.fill = undefined;
        return config;
    }
    __listenChildEvents(leafer) {
        leafer.once(LayoutEvent.END, () => this.__onReady());
        leafer.once(RenderEvent.START, () => this.__onCreated());
        leafer.once(RenderEvent.END, (e) => this.__onRenderEnd(e));
        if (this.realCanvas)
            this.__eventIds.push(leafer.on_(RenderEvent.END, this.__onChildRenderEnd, this));
    }
};
App = __decorate([
    registerUI()
], App);

const { get: get$4, rotateOfOuter: rotateOfOuter$2, translate: translate$1, scaleOfOuter: scaleOfOuter$2, scale: scaleHelper$1, rotate } = MatrixHelper;
function fillOrFitMode(data, mode, box, width, height, rotation) {
    const transform = get$4();
    const swap = rotation && rotation !== 180;
    const sw = box.width / (swap ? height : width);
    const sh = box.height / (swap ? width : height);
    const scale = mode === 'fit' ? Math.min(sw, sh) : Math.max(sw, sh);
    const x = box.x + (box.width - width * scale) / 2;
    const y = box.y + (box.height - height * scale) / 2;
    translate$1(transform, x, y);
    scaleHelper$1(transform, scale);
    if (rotation)
        rotateOfOuter$2(transform, { x: box.x + box.width / 2, y: box.y + box.height / 2 }, rotation);
    data.scaleX = data.scaleY = scale;
    data.transform = transform;
}
function clipMode(data, box, offset, scale, rotation) {
    const transform = get$4();
    translate$1(transform, box.x, box.y);
    if (offset)
        translate$1(transform, offset.x, offset.y);
    if (scale) {
        typeof scale === 'number' ? scaleHelper$1(transform, scale) : scaleHelper$1(transform, scale.x, scale.y);
        data.scaleX = transform.a;
        data.scaleY = transform.d;
    }
    if (rotation)
        rotate(transform, rotation);
    data.transform = transform;
}
function repeatMode(data, box, width, height, scale, rotation) {
    const transform = get$4();
    if (rotation) {
        rotate(transform, rotation);
        switch (rotation) {
            case 90:
                translate$1(transform, height, 0);
                break;
            case 180:
                translate$1(transform, width, height);
                break;
            case 270:
                translate$1(transform, 0, width);
                break;
        }
    }
    translate$1(transform, box.x, box.y);
    if (scale) {
        scaleOfOuter$2(transform, box, scale);
        data.scaleX = data.scaleY = scale;
    }
    data.transform = transform;
}

const { get: get$3, translate } = MatrixHelper;
function createData(leafPaint, image, paint, box) {
    let { width, height } = image;
    const { opacity, mode, offset, scale, rotation, blendMode } = paint;
    const sameBox = box.width === width && box.height === height;
    if (blendMode)
        leafPaint.blendMode = blendMode;
    const data = leafPaint.data = { mode };
    switch (mode) {
        case 'strench':
            if (!sameBox)
                width = box.width, height = box.height;
            if (box.x || box.y) {
                data.transform = get$3();
                translate(data.transform, box.x, box.y);
            }
            break;
        case 'clip':
            if (offset || scale || rotation)
                clipMode(data, box, offset, scale, rotation);
            break;
        case 'repeat':
            if (!sameBox || scale || rotation)
                repeatMode(data, box, width, height, scale, rotation);
            break;
        case 'fit':
        case 'cover':
        default:
            if (!sameBox || rotation)
                fillOrFitMode(data, mode, box, width, height, rotation);
    }
    data.width = width;
    data.height = height;
    if (opacity)
        data.opacity = opacity;
}

function image(ui, attrName, attrValue, box, firstUse) {
    const leafPaint = { type: attrValue.type };
    const image = leafPaint.image = ImageManager.get(attrValue);
    const event = (firstUse || image.loading) && { target: ui, image, attrName, attrValue };
    if (image.ready) {
        if (hasNaturalSize(ui, attrName, image))
            createData(leafPaint, image, attrValue, box);
        if (firstUse) {
            emit(ImageEvent.LOAD, event);
            emit(ImageEvent.LOADED, event);
        }
    }
    else if (image.error) {
        if (firstUse) {
            ui.forceUpdate('surface');
            event.error = image.error;
            emit(ImageEvent.ERROR, event);
        }
    }
    else {
        if (firstUse)
            emit(ImageEvent.LOAD, event);
        leafPaint.loadId = image.load(() => {
            if (!ui.destroyed) {
                if (hasNaturalSize(ui, attrName, image)) {
                    createData(leafPaint, image, attrValue, box);
                    ui.forceUpdate('surface');
                }
                emit(ImageEvent.LOADED, event);
            }
        }, (error) => {
            ui.forceUpdate('surface');
            event.error = error;
            emit(ImageEvent.ERROR, event);
        });
    }
    return leafPaint;
}
function hasNaturalSize(ui, attrName, image) {
    if (attrName === 'fill' && !ui.__.__naturalWidth) {
        const { __: d } = ui;
        d.__naturalWidth = image.width;
        d.__naturalHeight = image.height;
        if (!d.__getInput('width') || !d.__getInput('height')) {
            ui.forceUpdate('width');
            return false;
        }
    }
    return true;
}
function emit(type, data) {
    if (data.target.hasEvent(type))
        data.target.emitEvent(new ImageEvent(type, data));
}

const { get: get$2, scale: scaleHelper, copy: copy$1 } = MatrixHelper;
function createPattern(ui, paint, pixelRatio) {
    let { scaleX, scaleY } = ui.__world;
    const id = scaleX + '-' + scaleY;
    if (paint.patternId !== id && !ui.destroyed) {
        paint.patternId = id;
        scaleX = Math.abs(scaleX);
        scaleY = Math.abs(scaleY);
        const { image, data } = paint;
        const maxWidth = image.isSVG ? 4096 : Math.min(image.width, 4096);
        const maxHeight = image.isSVG ? 4096 : Math.min(image.height, 4096);
        let scale, matrix, { width, height, scaleX: sx, scaleY: sy, opacity, transform, mode } = data;
        if (sx) {
            matrix = get$2();
            copy$1(matrix, transform);
            scaleHelper(matrix, 1 / sx, 1 / sy);
            scaleX *= sx;
            scaleY *= sy;
        }
        scaleX *= pixelRatio;
        scaleY *= pixelRatio;
        width *= scaleX;
        height *= scaleY;
        if (width > maxWidth || height > maxHeight) {
            scale = Math.max(width / maxWidth, height / maxHeight);
        }
        if (scale) {
            scaleX /= scale;
            scaleY /= scale;
            width /= scale;
            height /= scale;
        }
        if (sx) {
            scaleX /= sx;
            scaleY /= sy;
        }
        if (transform || scaleX !== 1 || scaleY !== 1) {
            if (!matrix) {
                matrix = get$2();
                if (transform)
                    copy$1(matrix, transform);
            }
            scaleHelper(matrix, 1 / scaleX, 1 / scaleY);
        }
        const style = Platform.canvas.createPattern(image.getCanvas(width < 1 ? 1 : width, height < 1 ? 1 : height, opacity), mode === 'repeat' ? 'repeat' : (Platform.origin.noRepeat || 'no-repeat'));
        try {
            if (paint.transform)
                paint.transform = null;
            if (matrix)
                style.setTransform ? style.setTransform(matrix) : paint.transform = matrix;
        }
        catch (_a) {
            paint.transform = matrix;
        }
        paint.style = style;
        return true;
    }
    else {
        return false;
    }
}

function checkImage(ui, canvas, paint, allowPaint) {
    const { scaleX, scaleY } = ui.__world;
    if (!paint.data || paint.patternId === scaleX + '-' + scaleY) {
        return false;
    }
    else {
        if (allowPaint) {
            if (paint.image.isSVG && paint.data.mode !== 'repeat') {
                let { width, height } = paint.data;
                width *= scaleX * canvas.pixelRatio;
                height *= scaleY * canvas.pixelRatio;
                allowPaint = width > 4096 || height > 4096;
            }
            else {
                allowPaint = false;
            }
        }
        if (allowPaint) {
            canvas.save();
            canvas.clip();
            const { data } = paint;
            if (paint.blendMode)
                canvas.blendMode = paint.blendMode;
            if (data.opacity)
                canvas.opacity *= data.opacity;
            if (data.transform)
                canvas.transform(data.transform);
            canvas.drawImage(paint.image.view, 0, 0, data.width, data.height);
            canvas.restore();
            return true;
        }
        else {
            if (!paint.style) {
                createPattern(ui, paint, canvas.pixelRatio);
            }
            else {
                ImageManager.patternTasker.add(() => __awaiter(this, void 0, void 0, function* () {
                    if (canvas.bounds.hit(ui.__world) && createPattern(ui, paint, canvas.pixelRatio))
                        ui.forceUpdate('surface');
                }), 300);
            }
            return false;
        }
    }
}

function recycleImage(attrName, data) {
    const paints = (attrName === 'fill' ? data._fill : data._stroke);
    if (paints instanceof Array) {
        let image, recycleMap, input, url;
        for (let i = 0, len = paints.length; i < len; i++) {
            image = paints[i].image;
            url = image && image.url;
            if (url) {
                if (!recycleMap)
                    recycleMap = {};
                recycleMap[url] = true;
                ImageManager.recycle(image);
                if (image.loading) {
                    if (!input) {
                        input = (data.__input && data.__input[attrName]) || [];
                        if (!(input instanceof Array))
                            input = [input];
                    }
                    image.unload(paints[i].loadId, !input.some((item) => item.url === url));
                }
            }
        }
        return recycleMap;
    }
    return null;
}

function fillText(ui, canvas) {
    let row;
    const { rows, decorationY, decorationHeight } = ui.__.__textDrawData;
    for (let i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        if (row.text) {
            canvas.fillText(row.text, row.x, row.y);
        }
        else if (row.data) {
            row.data.forEach(charData => {
                canvas.fillText(charData.char, charData.x, row.y);
            });
        }
        if (decorationY)
            canvas.fillRect(row.x, row.y + decorationY, row.width, decorationHeight);
    }
}

function fill(fill, ui, canvas) {
    canvas.fillStyle = fill;
    ui.__.__font ? fillText(ui, canvas) : (ui.__.windingRule ? canvas.fill(ui.__.windingRule) : canvas.fill());
}
function fills(fills, ui, canvas) {
    let item;
    const { windingRule, __font } = ui.__;
    for (let i = 0, len = fills.length; i < len; i++) {
        item = fills[i];
        if (item.image && checkImage(ui, canvas, item, !__font))
            continue;
        if (item.style) {
            canvas.fillStyle = item.style;
            if (item.transform) {
                canvas.save();
                canvas.transform(item.transform);
                if (item.blendMode)
                    canvas.blendMode = item.blendMode;
                __font ? fillText(ui, canvas) : (windingRule ? canvas.fill(windingRule) : canvas.fill());
                canvas.restore();
            }
            else {
                if (item.blendMode) {
                    canvas.saveBlendMode(item.blendMode);
                    __font ? fillText(ui, canvas) : (windingRule ? canvas.fill(windingRule) : canvas.fill());
                    canvas.restoreBlendMode();
                }
                else {
                    __font ? fillText(ui, canvas) : (windingRule ? canvas.fill(windingRule) : canvas.fill());
                }
            }
        }
    }
}

function strokeText(stroke, ui, canvas, renderOptions) {
    const { strokeAlign } = ui.__;
    const isStrokes = typeof stroke !== 'string';
    switch (strokeAlign) {
        case 'center':
            canvas.setStroke(isStrokes ? undefined : stroke, ui.__.strokeWidth, ui.__);
            isStrokes ? drawStrokesStyle(stroke, true, ui, canvas) : drawTextStroke(ui, canvas);
            break;
        case 'inside':
            drawAlignStroke('inside', stroke, isStrokes, ui, canvas, renderOptions);
            break;
        case 'outside':
            drawAlignStroke('outside', stroke, isStrokes, ui, canvas, renderOptions);
            break;
    }
}
function drawAlignStroke(align, stroke, isStrokes, ui, canvas, renderOptions) {
    const { strokeWidth, __font } = ui.__;
    const out = canvas.getSameCanvas(true);
    out.setStroke(isStrokes ? undefined : stroke, strokeWidth * 2, ui.__);
    out.font = __font;
    isStrokes ? drawStrokesStyle(stroke, true, ui, out) : drawTextStroke(ui, out);
    out.blendMode = align === 'outside' ? 'destination-out' : 'destination-in';
    fillText(ui, out);
    out.blendMode = 'normal';
    if (ui.__hasMirror || renderOptions.matrix) {
        canvas.copyWorldByReset(out);
    }
    else {
        canvas.copyWorldToInner(out, ui.__world, ui.__layout.renderBounds);
    }
    out.recycle();
}
function drawTextStroke(ui, canvas) {
    let row;
    const { rows, decorationY, decorationHeight } = ui.__.__textDrawData;
    for (let i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        if (row.text) {
            canvas.strokeText(row.text, row.x, row.y);
        }
        else if (row.data) {
            row.data.forEach(charData => {
                canvas.strokeText(charData.char, charData.x, row.y);
            });
        }
        if (decorationY)
            canvas.strokeRect(row.x, row.y + decorationY, row.width, decorationHeight);
    }
}
function drawStrokesStyle(strokes, isText, ui, canvas) {
    let item;
    for (let i = 0, len = strokes.length; i < len; i++) {
        item = strokes[i];
        if (item.image && checkImage(ui, canvas, item, false))
            continue;
        if (item.style) {
            canvas.strokeStyle = item.style;
            if (item.blendMode) {
                canvas.saveBlendMode(item.blendMode);
                isText ? drawTextStroke(ui, canvas) : canvas.stroke();
                canvas.restoreBlendMode();
            }
            else {
                isText ? drawTextStroke(ui, canvas) : canvas.stroke();
            }
        }
    }
}

function stroke(stroke, ui, canvas, renderOptions) {
    const options = ui.__;
    const { strokeWidth, strokeAlign, __font } = options;
    if (!strokeWidth)
        return;
    if (__font) {
        strokeText(stroke, ui, canvas, renderOptions);
    }
    else {
        switch (strokeAlign) {
            case 'center':
                canvas.setStroke(stroke, strokeWidth, options);
                canvas.stroke();
                break;
            case 'inside':
                canvas.save();
                canvas.setStroke(stroke, strokeWidth * 2, options);
                options.windingRule ? canvas.clip(options.windingRule) : canvas.clip();
                canvas.stroke();
                canvas.restore();
                break;
            case 'outside':
                const out = canvas.getSameCanvas(true);
                out.setStroke(stroke, strokeWidth * 2, ui.__);
                ui.__drawRenderPath(out);
                out.stroke();
                options.windingRule ? out.clip(options.windingRule) : out.clip();
                out.clearWorld(ui.__layout.renderBounds);
                if (ui.__hasMirror || renderOptions.matrix) {
                    canvas.copyWorldByReset(out);
                }
                else {
                    canvas.copyWorldToInner(out, ui.__world, ui.__layout.renderBounds);
                }
                out.recycle();
                break;
        }
    }
}
function strokes(strokes, ui, canvas, renderOptions) {
    const options = ui.__;
    const { strokeWidth, strokeAlign, __font } = options;
    if (!strokeWidth)
        return;
    if (__font) {
        strokeText(strokes, ui, canvas, renderOptions);
    }
    else {
        switch (strokeAlign) {
            case 'center':
                canvas.setStroke(undefined, strokeWidth, options);
                drawStrokesStyle(strokes, false, ui, canvas);
                break;
            case 'inside':
                canvas.save();
                canvas.setStroke(undefined, strokeWidth * 2, options);
                options.windingRule ? canvas.clip(options.windingRule) : canvas.clip();
                drawStrokesStyle(strokes, false, ui, canvas);
                canvas.restore();
                break;
            case 'outside':
                const { renderBounds } = ui.__layout;
                const out = canvas.getSameCanvas(true);
                ui.__drawRenderPath(out);
                out.setStroke(undefined, strokeWidth * 2, ui.__);
                drawStrokesStyle(strokes, false, ui, out);
                options.windingRule ? out.clip(options.windingRule) : out.clip();
                out.clearWorld(renderBounds);
                if (ui.__hasMirror || renderOptions.matrix) {
                    canvas.copyWorldByReset(out);
                }
                else {
                    canvas.copyWorldToInner(out, ui.__world, renderBounds);
                }
                out.recycle();
                break;
        }
    }
}

const { getSpread, getOuterOf, getByMove, getIntersectData } = BoundsHelper;
function shape(ui, current, options) {
    const canvas = current.getSameCanvas();
    let bounds, matrix, shapeBounds;
    let worldCanvas;
    const { __world } = ui;
    let { scaleX, scaleY } = __world;
    if (scaleX < 0)
        scaleX = -scaleX;
    if (scaleY < 0)
        scaleY = -scaleY;
    if (!current.bounds.includes(__world, options.matrix)) {
        const { renderShapeSpread: spread } = ui.__layout;
        const worldClipBounds = getIntersectData(spread ? getSpread(current.bounds, spread * scaleX, spread * scaleY) : current.bounds, __world, options.matrix);
        matrix = current.bounds.getFitMatrix(worldClipBounds);
        if (matrix.a < 1) {
            worldCanvas = current.getSameCanvas();
            ui.__renderShape(worldCanvas, options);
            scaleX *= matrix.a;
            scaleY *= matrix.d;
        }
        shapeBounds = getOuterOf(__world, matrix);
        bounds = getByMove(shapeBounds, -matrix.e, -matrix.f);
        if (options.matrix)
            matrix.multiply(options.matrix);
        options = Object.assign(Object.assign({}, options), { matrix });
    }
    else {
        if (options.matrix) {
            scaleX *= options.matrix.a;
            scaleY *= options.matrix.d;
            bounds = shapeBounds = getOuterOf(__world, options.matrix);
        }
        else {
            bounds = shapeBounds = __world;
        }
        worldCanvas = canvas;
    }
    ui.__renderShape(canvas, options);
    return {
        canvas, matrix, bounds,
        worldCanvas, shapeBounds, scaleX, scaleY
    };
}

const defaultFrom$2 = { x: 0.5, y: 0 };
const defaultTo$2 = { x: 0.5, y: 1 };
function linearGradient(paint, box) {
    let { from, to, type, blendMode, opacity } = paint;
    from || (from = defaultFrom$2);
    to || (to = defaultTo$2);
    const style = Platform.canvas.createLinearGradient(box.x + from.x * box.width, box.y + from.y * box.height, box.x + to.x * box.width, box.y + to.y * box.height);
    applyStops(style, paint.stops, opacity);
    const data = { type, style };
    if (blendMode)
        data.blendMode = blendMode;
    return data;
}
function applyStops(gradient, stops, opacity) {
    let stop;
    for (let i = 0, len = stops.length; i < len; i++) {
        stop = stops[i];
        gradient.addColorStop(stop.offset, ColorConvert$1.string(stop.color, opacity));
    }
}

const { set: set$1, getAngle: getAngle$1, getDistance: getDistance$1 } = PointHelper;
const { get: get$1, rotateOfOuter: rotateOfOuter$1, scaleOfOuter: scaleOfOuter$1 } = MatrixHelper;
const defaultFrom$1 = { x: 0.5, y: 0.5 };
const defaultTo$1 = { x: 0.5, y: 1 };
const realFrom$1 = {};
const realTo$1 = {};
function radialGradient(paint, box) {
    let { from, to, type, opacity, blendMode, stretch } = paint;
    from || (from = defaultFrom$1);
    to || (to = defaultTo$1);
    const { x, y, width, height } = box;
    set$1(realFrom$1, x + from.x * width, y + from.y * height);
    set$1(realTo$1, x + to.x * width, y + to.y * height);
    let transform;
    if (width !== height || stretch) {
        transform = get$1();
        scaleOfOuter$1(transform, realFrom$1, width / height * (stretch || 1), 1);
        rotateOfOuter$1(transform, realFrom$1, getAngle$1(realFrom$1, realTo$1) + 90);
    }
    const style = Platform.canvas.createRadialGradient(realFrom$1.x, realFrom$1.y, 0, realFrom$1.x, realFrom$1.y, getDistance$1(realFrom$1, realTo$1));
    applyStops(style, paint.stops, opacity);
    const data = { type, style, transform };
    if (blendMode)
        data.blendMode = blendMode;
    return data;
}

const { set, getAngle, getDistance } = PointHelper;
const { get, rotateOfOuter, scaleOfOuter } = MatrixHelper;
const defaultFrom = { x: 0.5, y: 0.5 };
const defaultTo = { x: 0.5, y: 1 };
const realFrom = {};
const realTo = {};
function conicGradient(paint, box) {
    let { from, to, type, opacity, blendMode, stretch } = paint;
    from || (from = defaultFrom);
    to || (to = defaultTo);
    const { x, y, width, height } = box;
    set(realFrom, x + from.x * width, y + from.y * height);
    set(realTo, x + to.x * width, y + to.y * height);
    const transform = get();
    const angle = getAngle(realFrom, realTo);
    if (Platform.conicGradientRotate90) {
        scaleOfOuter(transform, realFrom, width / height * (stretch || 1), 1);
        rotateOfOuter(transform, realFrom, angle + 90);
    }
    else {
        scaleOfOuter(transform, realFrom, 1, width / height * (stretch || 1));
        rotateOfOuter(transform, realFrom, angle);
    }
    const style = Platform.conicGradientSupport ? Platform.canvas.createConicGradient(0, realFrom.x, realFrom.y) : Platform.canvas.createRadialGradient(realFrom.x, realFrom.y, 0, realFrom.x, realFrom.y, getDistance(realFrom, realTo));
    applyStops(style, paint.stops, opacity);
    const data = { type, style, transform };
    if (blendMode)
        data.blendMode = blendMode;
    return data;
}

let recycleMap;
function compute(attrName, ui) {
    const value = [];
    let item;
    let paints = ui.__.__input[attrName];
    if (!(paints instanceof Array))
        paints = [paints];
    recycleMap = recycleImage(attrName, ui.__);
    for (let i = 0, len = paints.length; i < len; i++) {
        item = getLeafPaint(attrName, paints[i], ui);
        if (item)
            value.push(item);
    }
    ui.__['_' + attrName] = value.length ? value : undefined;
}
function getLeafPaint(attrName, paint, ui) {
    if (typeof paint !== 'object' || paint.visible === false || paint.opacity === 0)
        return undefined;
    const { boxBounds } = ui.__layout;
    switch (paint.type) {
        case 'solid':
            let { type, blendMode, color, opacity } = paint;
            return { type, blendMode, style: ColorConvert$1.string(color, opacity) };
        case 'image':
            return image(ui, attrName, paint, boxBounds, !recycleMap || !recycleMap[paint.url]);
        case 'linear':
            return linearGradient(paint, boxBounds);
        case 'radial':
            return radialGradient(paint, boxBounds);
        case 'angular':
            return conicGradient(paint, boxBounds);
        default:
            return paint.r ? { type: 'solid', style: ColorConvert$1.string(paint) } : undefined;
    }
}

var UIPaint = /*#__PURE__*/Object.freeze({
    __proto__: null,
    compute: compute,
    drawTextStroke: drawTextStroke,
    fill: fill,
    fillText: fillText,
    fills: fills,
    recycleImage: recycleImage,
    shape: shape,
    stroke: stroke,
    strokeText: strokeText,
    strokes: strokes
});

const { copy, toOffsetOutBounds: toOffsetOutBounds$1 } = BoundsHelper;
const tempBounds = {};
const offsetOutBounds$1 = {};
function shadow(ui, current, shape, renderOptions) {
    let copyBounds, spreadScale;
    const { __world, __layout } = ui;
    const { shadow } = ui.__;
    const { worldCanvas, bounds, shapeBounds, scaleX, scaleY } = shape;
    const other = current.getSameCanvas();
    const end = shadow.length - 1;
    toOffsetOutBounds$1(bounds, offsetOutBounds$1);
    shadow.forEach((item, index) => {
        other.setWorldShadow((offsetOutBounds$1.offsetX + item.x * scaleX), (offsetOutBounds$1.offsetY + item.y * scaleY), item.blur * scaleX, item.color);
        spreadScale = item.spread ? 1 + item.spread * 2 / (__layout.boxBounds.width + (__layout.strokeBoxSpread || 0) * 2) : 0;
        drawWorldShadow(other, offsetOutBounds$1, spreadScale, shape);
        copyBounds = bounds;
        if (item.box) {
            other.restore();
            other.save();
            if (worldCanvas) {
                other.copyWorld(other, bounds, __world, 'copy');
                copyBounds = __world;
            }
            worldCanvas ? other.copyWorld(worldCanvas, __world, __world, 'destination-out') : other.copyWorld(shape.canvas, shapeBounds, bounds, 'destination-out');
        }
        if (ui.__hasMirror || renderOptions.matrix) {
            current.copyWorldByReset(other, copyBounds, __world, item.blendMode);
        }
        else {
            current.copyWorldToInner(other, copyBounds, __layout.renderBounds, item.blendMode);
        }
        if (end && index < end)
            other.clear();
    });
    other.recycle();
}
function drawWorldShadow(canvas, outBounds, spreadScale, shape) {
    const { bounds, shapeBounds } = shape;
    if (Platform.fullImageShadow) {
        copy(tempBounds, canvas.bounds);
        tempBounds.x += (outBounds.x - shapeBounds.x);
        tempBounds.y += (outBounds.y - shapeBounds.y);
        if (spreadScale) {
            const { matrix } = shape;
            tempBounds.x -= (bounds.x + (matrix ? matrix.e : 0) + bounds.width / 2) * (spreadScale - 1);
            tempBounds.y -= (bounds.y + (matrix ? matrix.f : 0) + bounds.height / 2) * (spreadScale - 1);
            tempBounds.width *= spreadScale;
            tempBounds.height *= spreadScale;
        }
        canvas.copyWorld(shape.canvas, canvas.bounds, tempBounds);
    }
    else {
        if (spreadScale) {
            copy(tempBounds, outBounds);
            tempBounds.x -= (outBounds.width / 2) * (spreadScale - 1);
            tempBounds.y -= (outBounds.height / 2) * (spreadScale - 1);
            tempBounds.width *= spreadScale;
            tempBounds.height *= spreadScale;
        }
        canvas.copyWorld(shape.canvas, shapeBounds, spreadScale ? tempBounds : outBounds);
    }
}

const { toOffsetOutBounds } = BoundsHelper;
const offsetOutBounds = {};
function innerShadow(ui, current, shape, renderOptions) {
    let copyBounds, spreadScale;
    const { __world, __layout: __layout } = ui;
    const { innerShadow } = ui.__;
    const { worldCanvas, bounds, shapeBounds, scaleX, scaleY } = shape;
    const other = current.getSameCanvas();
    const end = innerShadow.length - 1;
    toOffsetOutBounds(bounds, offsetOutBounds);
    innerShadow.forEach((item, index) => {
        other.save();
        other.setWorldShadow((offsetOutBounds.offsetX + item.x * scaleX), (offsetOutBounds.offsetY + item.y * scaleY), item.blur * scaleX);
        spreadScale = item.spread ? 1 - item.spread * 2 / (__layout.boxBounds.width + (__layout.strokeBoxSpread || 0) * 2) : 0;
        drawWorldShadow(other, offsetOutBounds, spreadScale, shape);
        other.restore();
        if (worldCanvas) {
            other.copyWorld(other, bounds, __world, 'copy');
            other.copyWorld(worldCanvas, __world, __world, 'source-out');
            copyBounds = __world;
        }
        else {
            other.copyWorld(shape.canvas, shapeBounds, bounds, 'source-out');
            copyBounds = bounds;
        }
        other.fillWorld(copyBounds, item.color, 'source-in');
        if (ui.__hasMirror || renderOptions.matrix) {
            current.copyWorldByReset(other, copyBounds, __world, item.blendMode);
        }
        else {
            current.copyWorldToInner(other, copyBounds, __layout.renderBounds, item.blendMode);
        }
        if (end && index < end)
            other.clear();
    });
    other.recycle();
}

function blur(ui, current, origin) {
    const { blur } = ui.__;
    origin.setWorldBlur(blur * ui.__world.a);
    origin.copyWorldToInner(current, ui.__world, ui.__layout.renderBounds);
    origin.filter = 'none';
}

var UIEffect = /*#__PURE__*/Object.freeze({
    __proto__: null,
    blur: blur,
    innerShadow: innerShadow,
    shadow: shadow
});

const money = '¥￥＄€£￡¢￠';
const letter = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz';
const langBefore = '《（「〈『〖【〔｛┌＜‘“＝' + money;
const langAfter = '》）」〉』〗】〕｝┐＞’”！？，、。：；‰';
const langSymbol = '≮≯≈≠＝…';
const langBreak$1 = '—／～｜┆·';
const beforeChar = '{[(<\'"' + langBefore;
const afterChar = '>)]}%!?,.:;\'"' + langAfter;
const symbolChar = afterChar + '_#~&*+\\=|' + langSymbol;
const breakChar = '- ' + langBreak$1;
const cjkRangeList = [
    [0x4E00, 0x9FFF],
    [0x3400, 0x4DBF],
    [0x20000, 0x2A6DF],
    [0x2A700, 0x2B73F],
    [0x2B740, 0x2B81F],
    [0x2B820, 0x2CEAF],
    [0x2CEB0, 0x2EBEF],
    [0x30000, 0x3134F],
    [0x31350, 0x323AF],
    [0x2E80, 0x2EFF],
    [0x2F00, 0x2FDF],
    [0x2FF0, 0x2FFF],
    [0x3000, 0x303F],
    [0x31C0, 0x31EF],
    [0x3200, 0x32FF],
    [0x3300, 0x33FF],
    [0xF900, 0xFAFF],
    [0xFE30, 0xFE4F],
    [0x1F200, 0x1F2FF],
    [0x2F800, 0x2FA1F],
];
const cjkReg = new RegExp(cjkRangeList.map(([start, end]) => `[\\u${start.toString(16)}-\\u${end.toString(16)}]`).join('|'));
function mapChar(str) {
    const map = {};
    str.split('').forEach(char => map[char] = true);
    return map;
}
const letterMap = mapChar(letter);
const beforeMap = mapChar(beforeChar);
const afterMap = mapChar(afterChar);
const symbolMap = mapChar(symbolChar);
const breakMap = mapChar(breakChar);
var CharType;
(function (CharType) {
    CharType[CharType["Letter"] = 0] = "Letter";
    CharType[CharType["Single"] = 1] = "Single";
    CharType[CharType["Before"] = 2] = "Before";
    CharType[CharType["After"] = 3] = "After";
    CharType[CharType["Symbol"] = 4] = "Symbol";
    CharType[CharType["Break"] = 5] = "Break";
})(CharType || (CharType = {}));
const { Letter: Letter$1, Single: Single$1, Before: Before$1, After: After$1, Symbol: Symbol$1, Break: Break$1 } = CharType;
function getCharType(char) {
    if (letterMap[char]) {
        return Letter$1;
    }
    else if (breakMap[char]) {
        return Break$1;
    }
    else if (beforeMap[char]) {
        return Before$1;
    }
    else if (afterMap[char]) {
        return After$1;
    }
    else if (symbolMap[char]) {
        return Symbol$1;
    }
    else if (cjkReg.test(char)) {
        return Single$1;
    }
    else {
        return Letter$1;
    }
}

const TextRowHelper = {
    trimRight(row) {
        const { words } = row;
        let trimRight = 0, len = words.length, char;
        for (let i = len - 1; i > -1; i--) {
            char = words[i].data[0];
            if (char.char === ' ') {
                trimRight++;
                row.width -= char.width;
            }
            else {
                break;
            }
        }
        if (trimRight)
            words.splice(len - trimRight, trimRight);
    }
};

function getTextCase(char, textCase, firstChar) {
    switch (textCase) {
        case 'title':
            return firstChar ? char.toUpperCase() : char;
        case 'upper':
            return char.toUpperCase();
        case 'lower':
            return char.toLowerCase();
        default:
            return char;
    }
}

const { trimRight } = TextRowHelper;
const { Letter, Single, Before, After, Symbol, Break } = CharType;
let word, row, wordWidth, rowWidth, realWidth;
let char, charWidth, startCharSize, charSize, charType, lastCharType, langBreak, afterBreak, paraStart;
let textDrawData, rows = [], bounds;
function createRows(drawData, content, style) {
    textDrawData = drawData;
    rows = drawData.rows;
    bounds = drawData.bounds;
    const { __letterSpacing, paraIndent, textCase } = style;
    const { canvas } = Platform;
    const { width, height } = bounds;
    const charMode = width || height || __letterSpacing || (textCase !== 'none');
    if (charMode) {
        paraStart = true;
        lastCharType = null;
        startCharSize = charWidth = charSize = wordWidth = rowWidth = 0;
        word = { data: [] }, row = { words: [] };
        for (let i = 0, len = content.length; i < len; i++) {
            char = content[i];
            if (char === '\n') {
                if (wordWidth)
                    addWord();
                row.paraEnd = true;
                addRow();
                paraStart = true;
            }
            else {
                charType = getCharType(char);
                if (charType === Letter && textCase !== 'none')
                    char = getTextCase(char, textCase, !wordWidth);
                charWidth = canvas.measureText(char).width;
                if (__letterSpacing) {
                    if (__letterSpacing < 0)
                        charSize = charWidth;
                    charWidth += __letterSpacing;
                }
                langBreak = (charType === Single && (lastCharType === Single || lastCharType === Letter)) || (lastCharType === Single && charType !== After);
                afterBreak = ((charType === Before || charType === Single) && (lastCharType === Symbol || lastCharType === After));
                realWidth = paraStart && paraIndent ? width - paraIndent : width;
                if (width && rowWidth + wordWidth + charWidth > realWidth) {
                    if (!afterBreak)
                        afterBreak = charType === Letter && lastCharType == After;
                    if (langBreak || afterBreak || charType === Break || charType === Before || charType === Single || (wordWidth + charWidth > realWidth)) {
                        if (wordWidth)
                            addWord();
                        addRow();
                    }
                    else {
                        addRow();
                    }
                }
                if (char === ' ' && paraStart !== true && (rowWidth + wordWidth) === 0) ;
                else {
                    if (charType === Break) {
                        if (char === ' ' && wordWidth)
                            addWord();
                        addChar(char, charWidth);
                        addWord();
                    }
                    else if (langBreak || afterBreak) {
                        if (wordWidth)
                            addWord();
                        addChar(char, charWidth);
                    }
                    else {
                        addChar(char, charWidth);
                    }
                }
                lastCharType = charType;
            }
        }
        if (wordWidth)
            addWord();
        if (rowWidth)
            addRow();
        rows.length > 0 && (rows[rows.length - 1].paraEnd = true);
    }
    else {
        content.split('\n').forEach(content => {
            textDrawData.paraNumber++;
            rows.push({ x: paraIndent || 0, text: content, width: canvas.measureText(content).width, paraStart: true });
        });
    }
}
function addChar(char, width) {
    if (charSize && !startCharSize)
        startCharSize = charSize;
    word.data.push({ char, width });
    wordWidth += width;
}
function addWord() {
    rowWidth += wordWidth;
    word.width = wordWidth;
    row.words.push(word);
    word = { data: [] };
    wordWidth = 0;
}
function addRow() {
    if (paraStart) {
        textDrawData.paraNumber++;
        row.paraStart = true;
        paraStart = false;
    }
    if (charSize) {
        row.startCharSize = startCharSize;
        row.endCharSize = charSize;
        startCharSize = 0;
    }
    row.width = rowWidth;
    if (bounds.width)
        trimRight(row);
    rows.push(row);
    row = { words: [] };
    rowWidth = 0;
}

const CharMode = 0;
const WordMode = 1;
const RowMode = 2;
function layoutChar(drawData, style, width, _height) {
    const { rows } = drawData;
    const { textAlign, paraIndent, letterSpacing } = style;
    let charX, addWordWidth, indentWidth, mode, wordChar;
    rows.forEach(row => {
        if (row.words) {
            indentWidth = paraIndent && row.paraStart ? paraIndent : 0;
            addWordWidth = (width && textAlign === 'justify' && row.words.length > 1) ? (width - row.width - indentWidth) / (row.words.length - 1) : 0;
            mode = (letterSpacing || row.isOverflow) ? CharMode : (addWordWidth > 0.01 ? WordMode : RowMode);
            if (mode === RowMode) {
                row.text = '';
                row.x += indentWidth;
                row.words.forEach(word => {
                    word.data.forEach(char => {
                        row.text += char.char;
                    });
                });
            }
            else {
                row.x += indentWidth;
                charX = row.x;
                row.data = [];
                row.words.forEach(word => {
                    if (mode === WordMode) {
                        wordChar = { char: '', x: charX };
                        charX = toWordChar(word.data, charX, wordChar);
                        if (wordChar.char !== ' ')
                            row.data.push(wordChar);
                    }
                    else {
                        charX = toChar(word.data, charX, row.data);
                    }
                    if (!row.paraEnd && addWordWidth) {
                        charX += addWordWidth;
                        row.width += addWordWidth;
                    }
                });
            }
            row.words = null;
        }
    });
}
function toWordChar(data, charX, wordChar) {
    data.forEach(char => {
        wordChar.char += char.char;
        charX += char.width;
    });
    return charX;
}
function toChar(data, charX, rowData) {
    data.forEach(char => {
        if (char.char !== ' ') {
            char.x = charX;
            rowData.push(char);
        }
        charX += char.width;
    });
    return charX;
}

function layoutText(drawData, style) {
    const { rows, bounds } = drawData;
    const { __lineHeight, __baseLine, __letterSpacing, textAlign, verticalAlign, paraSpacing, textOverflow } = style;
    let { x, y, width, height } = bounds, realHeight = __lineHeight * rows.length + (paraSpacing ? paraSpacing * (drawData.paraNumber - 1) : 0);
    let starY = __baseLine;
    if (textOverflow !== 'show' && realHeight > height) {
        realHeight = Math.max(height, __lineHeight);
        drawData.overflow = rows.length;
    }
    else {
        switch (verticalAlign) {
            case 'middle':
                y += (height - realHeight) / 2;
                break;
            case 'bottom':
                y += (height - realHeight);
        }
    }
    starY += y;
    let row, rowX, rowWidth;
    for (let i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        row.x = x;
        switch (textAlign) {
            case 'center':
                row.x += (width - row.width) / 2;
                break;
            case 'right':
                row.x += width - row.width;
        }
        if (row.paraStart && paraSpacing && i > 0)
            starY += paraSpacing;
        row.y = starY;
        starY += __lineHeight;
        if (drawData.overflow > i && starY > realHeight) {
            row.isOverflow = true;
            drawData.overflow = i + 1;
        }
        rowX = row.x;
        rowWidth = row.width;
        if (__letterSpacing < 0) {
            if (row.width < 0) {
                rowWidth = -row.width + style.fontSize + __letterSpacing;
                rowX -= rowWidth;
                rowWidth += style.fontSize;
            }
            else {
                rowWidth -= __letterSpacing;
            }
        }
        if (rowX < bounds.x)
            bounds.x = rowX;
        if (rowWidth > bounds.width)
            bounds.width = rowWidth;
    }
    bounds.y = y;
    bounds.height = realHeight;
}

function clipText(drawData, textOverflow) {
    const { rows, overflow } = drawData;
    rows.splice(overflow);
    if (textOverflow !== 'hide') {
        if (textOverflow === 'ellipsis')
            textOverflow = '...';
        const ellipsisWidth = Platform.canvas.measureText(textOverflow).width;
        const row = rows[overflow - 1];
        let char, end = row.data.length - 1, charRight;
        const { x, width } = drawData.bounds;
        const right = x + width - ellipsisWidth;
        for (let i = end; i > -1; i--) {
            char = row.data[i];
            charRight = char.x + char.width;
            if (i === end && charRight < right) {
                break;
            }
            else if (charRight < right && char.char !== ' ') {
                row.data.splice(i + 1);
                row.width -= char.width;
                break;
            }
            row.width -= char.width;
        }
        row.width += ellipsisWidth;
        row.data.push({ char: textOverflow, x: charRight });
    }
}

function decorationText(drawData, style) {
    const { fontSize } = style;
    drawData.decorationHeight = fontSize / 11;
    switch (style.textDecoration) {
        case 'under':
            drawData.decorationY = fontSize * 0.15;
            break;
        case 'delete':
            drawData.decorationY = -fontSize * 0.35;
    }
}

const TextConvert = {
    getDrawData(content, style) {
        if (typeof content !== 'string')
            content = String(content);
        let x = 0, y = 0;
        let width = style.__getInput('width') || 0;
        let height = style.__getInput('height') || 0;
        const { textDecoration, textOverflow, __font, padding } = style;
        if (padding) {
            const [top, right, bottom, left] = MathHelper.fourNumber(padding);
            if (width) {
                x = left;
                width -= (right + left);
            }
            if (height) {
                y = top;
                height -= (top + bottom);
            }
        }
        const drawData = {
            bounds: { x, y, width, height },
            rows: [],
            paraNumber: 0,
            font: Platform.canvas.font = __font
        };
        createRows(drawData, content, style);
        layoutText(drawData, style);
        layoutChar(drawData, style, width);
        if (drawData.overflow)
            clipText(drawData, textOverflow);
        if (textDecoration !== 'none')
            decorationText(drawData, style);
        return drawData;
    }
};

const ColorConvert = {
    string(color, opacity) {
        if (typeof color === 'string')
            return color;
        let a = color.a === undefined ? 1 : color.a;
        if (opacity)
            a *= opacity;
        const rgb = color.r + ',' + color.g + ',' + color.b;
        return a === 1 ? 'rgb(' + rgb + ')' : 'rgba(' + rgb + ',' + a + ')';
    }
};

const Export = {
    export(leaf, filename, options) {
        return addTask((success) => new Promise((resolve) => {
            const { leafer } = leaf;
            if (leafer) {
                leafer.waitViewCompleted(() => __awaiter(this, void 0, void 0, function* () {
                    let quality, blob;
                    let { canvas } = leafer;
                    let { unreal } = canvas;
                    if (unreal) {
                        canvas = canvas.getSameCanvas();
                        canvas.backgroundColor = leafer.config.fill;
                        leafer.__render(canvas, {});
                    }
                    switch (typeof options) {
                        case 'object':
                            if (options.quality)
                                quality = options.quality;
                            if (options.blob)
                                blob = true;
                            break;
                        case 'number':
                            quality = options;
                            break;
                        case 'boolean':
                            blob = options;
                    }
                    let data;
                    if (filename.includes('.')) {
                        data = yield canvas.saveAs(filename, quality);
                    }
                    else if (blob) {
                        data = yield canvas.toBlob(filename, quality);
                    }
                    else {
                        data = yield canvas.toDataURL(filename, quality);
                    }
                    success({ data });
                    resolve();
                    if (unreal)
                        canvas.recycle();
                }));
            }
            else {
                success({ data: false });
                resolve();
            }
        }));
    }
};
let tasker;
function addTask(task) {
    if (!tasker)
        tasker = new TaskProcessor();
    return new Promise((resolve) => {
        tasker.add(() => __awaiter(this, void 0, void 0, function* () { return yield task(resolve); }), { parallel: false });
    });
}

Object.assign(Paint, UIPaint);
Object.assign(Effect, UIEffect);
Object.assign(TextConvert$1, TextConvert);
Object.assign(ColorConvert$1, ColorConvert);
Object.assign(Export$1, Export);

useCanvas();

export { Animate, AnimateEvent, App, AutoBounds, BezierHelper, Bounds, BoundsHelper, Box, Branch, BranchHelper, BranchRender, Canvas, CanvasManager, ChildEvent, ColorConvert$1 as ColorConvert, Creator, Cursor, DataHelper, Debug, DragEvent, DropEvent, Effect, Ellipse, EllipseHelper, Event, EventCreator, Export$1 as Export, FileHelper, Frame, Group, HitCanvasManager, Image$1 as Image, ImageEvent, ImageManager, IncrementId, Interaction, InteractionBase, InteractionHelper, KeyEvent, Keyboard, LayoutEvent, Layouter, Leaf, LeafBounds, LeafBoundsHelper, LeafData, LeafDataProxy, LeafEventer, LeafHelper, LeafHit, LeafLayout, LeafLevelList, LeafList, LeafMask, LeafMatrix, LeafRender, Leafer, LeaferCanvas, LeaferCanvasBase, LeaferEvent, LeaferImage, LeaferTypeCreator, Line, MathHelper, Matrix, MatrixHelper, MoveEvent, MultiTouchHelper, NeedConvertToCanvasCommandMap, OneRadian, PI2, PI_2, Paint, Path, PathBounds, PathCommandDataHelper, PathCommandMap, PathConvert, PathCorner, PathCreator, PathDrawer, PathHelper, PathNumberCommandLengthMap, PathNumberCommandMap, Pen, Platform, PluginManager, Point, PointHelper, PointerButton, PointerEvent, Polygon, PropertyEvent, Rect, RectHelper, RectRender, RenderEvent, Renderer, ResizeEvent, RotateEvent, Run, Selector, Star, StringNumberMap, SwipeEvent, TaskItem, TaskProcessor, Text, TextConvert$1 as TextConvert, TransformEvent, TwoPointBounds, TwoPointBoundsHelper, UI, UIBounds, UICreator, UIEvent, UIHit, UIRender, WaitHelper, WatchEvent, Watcher, ZoomEvent, affectRenderBoundsType, affectStrokeBoundsType, aliasType, boundsType, canvasPatch, canvasSizeAttrs, cursorType, dataProcessor, dataType, defineDataProcessor, defineKey, defineLeafAttr, effectType, eraserType, getDescriptor, hitType, layoutProcessor, maskType, opacityType, pathType, positionType, registerUI, registerUIEvent, resizeType, rewrite, rewriteAble, rotationType, scaleType, setDefaultValue, sortType, strokeType, surfaceType, useCanvas, useModule, usePlugin };
